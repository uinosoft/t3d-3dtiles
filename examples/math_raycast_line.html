<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>t3d - 3dtiles</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="main.css">
</head>
<body>
	<div id="info">
		<a href="" target="_blank">t3d 3dtiles</a> - Raycasting for line segment<br/>
		The resource 'ayutthaya' is sourced from <a href="https://ebeaufay.github.io/ThreedTilesViewer.github.io/" target="_blank">jdultra.com</a>
	</div>

	<!-- Import maps polyfill -->
    <!-- Remove this when import maps will be widely supported -->
    <script async src="./node_modules/es-module-shims/dist/es-module-shims.js"></script>

    <script type="importmap">
        {
            "imports": {
                "t3d": "./node_modules/t3d/build/t3d.module.js",
                "t3d/addons/": "./node_modules/t3d/examples/jsm/",
				"tweakpane": "./node_modules/tweakpane/dist/tweakpane.js",
				"@tweakpane/plugin-essentials": "./node_modules/@tweakpane/plugin-essentials/dist/tweakpane-plugin-essentials.js",
				"t3d-3dtiles": "../build/t3d.3dtiles.module.js"
            }
        }
    </script>

	<script type="module">
		import * as t3d from 't3d';
		import { OrbitControls } from 't3d/addons/controls/OrbitControls.js';
		import { ForwardRenderer } from 't3d/addons/render/ForwardRenderer.js';
		import { DRACOLoader } from 't3d/addons/loaders/DRACOLoader.js';
		import { TransformControls } from 't3d/addons/controls/TransformControls.js';
		import { Raycaster } from 't3d/addons/Raycaster.js';

		import { TilesRenderer, ReorientationPlugin, DebugTilesPlugin, TilesFadePlugin } from 't3d-3dtiles';

		import { Pane } from 'tweakpane';
		import * as EssentialsPlugin from '@tweakpane/plugin-essentials';

		let width = window.innerWidth || 2;
		let height = window.innerHeight || 2;

		const canvas = document.createElement('canvas');
		canvas.width = width * window.devicePixelRatio;
		canvas.height = height * window.devicePixelRatio;
		canvas.style.width = width + 'px';
		canvas.style.height = height + 'px';
		document.body.appendChild(canvas);

		const forwardRenderer = new ForwardRenderer(canvas);
		forwardRenderer.setClearColor(0.6, 0.7, 0.8, 1);

		const scene = new t3d.Scene();

		const ambientLight = new t3d.AmbientLight(0xffffff, 0.2);
		scene.add(ambientLight);

		const directionalLight = new t3d.DirectionalLight(0xffffff, 0.8);
		directionalLight.position.set(20, 30, 40);
		directionalLight.lookAt(new t3d.Vector3(), new t3d.Vector3(0, 1, 0));
		scene.add(directionalLight);

		const camera = new t3d.Camera();
		camera.outputEncoding = t3d.TEXEL_ENCODING_TYPE.SRGB;
		camera.position.set(120, 80, 120);
		camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 10000);
		scene.add(camera);

		const controller = new OrbitControls(camera, canvas);
		controller.enablePan = true;
		controller.minDistance = 1;
		controller.maxDistance = 10000;

		// Create 3D tiles

		const tiles = new TilesRenderer('https://storage.googleapis.com/ogc-3d-tiles/ayutthaya/tiledWithSkirts/tileset.json');
		scene.add(tiles.group);

		const dracoLoader = new DRACOLoader();
		dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.4.3/');
		tiles.setDRACOLoader(dracoLoader);
		
		tiles.addCamera(camera);
		tiles.resize(width * window.devicePixelRatio, height * window.devicePixelRatio);

		tiles.registerPlugin(new ReorientationPlugin());
		tiles.registerPlugin(new DebugTilesPlugin());
		tiles.registerPlugin(new TilesFadePlugin());

		// Ray casting

		class LineSegment extends t3d.Object3D {

			constructor() {
				super();

				const boxGeometry = new t3d.SphereGeometry(1);

				this.start = new t3d.Mesh(boxGeometry, new t3d.BasicMaterial());
				this.start.scale.setScalar(1);
				this.add(this.start);

				this.end = new t3d.Mesh(boxGeometry, new t3d.BasicMaterial());
				this.end.scale.setScalar(1);
				this.add(this.end);

				const lineArray = new Float32Array([0, 0, 0, 0, 0, 0]);
				const lineGeometry = new t3d.Geometry();
				lineGeometry.addAttribute('a_Position', new t3d.Attribute(new t3d.Buffer(lineArray, 3)));
				const lineMaterial = new t3d.BasicMaterial();
				lineMaterial.drawMode = t3d.DRAW_MODE.LINES;
				this.line = new t3d.Mesh(lineGeometry, lineMaterial);
				this.add(this.line);

				this._ray = new t3d.Ray();
				this._points = [this.start, this.end];

				this.start.material.diffuse.setHex(0x00ffff);
				this.end.material.diffuse.setHex(0x00ffff);
			}

			getPoints() {
				return this._points;
			}

			getLength() {
				return this.start.position.distanceTo(this.end.position);
			}

			getRay() {
				this._ray.origin.copy(this.start.position);
				this._ray.direction.subVectors(this.end.position, this.start.position).normalize();
				return this._ray;
			}

			getRayInverse() {
				this._ray.origin.copy(this.end.position);
				this._ray.direction.subVectors(this.start.position, this.end.position).normalize();
				return this._ray;
			}

			syncLine() {
				const lineBuffer = this.line.geometry.attributes.a_Position.buffer;
				const lineArray = lineBuffer.array;
				this.start.position.toArray(lineArray, 0);
				this.end.position.toArray(lineArray, 3);
				lineBuffer.version++;
			}

			highlightLine(value) {
				this.line.material.diffuse.setHex(value ? 0xff0000 : 0x00ff00);
			}
		
		}
		
		let timing = 0;
		function doRaycast(force) {
			if (!force && (new Date().getTime() - timing < 100)) return;
			timing = new Date().getTime();

			let intersects = [];

			const ray = lineSegment.getRay();
			tiles.raycast(ray, intersects);
			const rayInverse = lineSegment.getRayInverse();
			tiles.raycast(rayInverse, intersects); // TODO intersect with segment

			const segmentLength = lineSegment.getLength();
			intersects = intersects.filter(intersect => {
				return segmentLength - intersect.distance > 0;
			});

			if (intersects.length > 0) {
				lineSegment.highlightLine(true);
			} else {
				lineSegment.highlightLine(false);
			}

			clearIntersectPoints();
			showIntersectPoints(intersects);
		}

		const intersectPointContainer = new t3d.Object3D();
		scene.add(intersectPointContainer);
		const intersectPointPool = [];
		function clearIntersectPoints() {
			intersectPointContainer.children.slice(0).forEach(point => {
				intersectPointPool.push(point);
				intersectPointContainer.remove(point);
			});
		}
		function showIntersectPoints(intersects) {
			intersects.forEach(intersect => {
				const point = intersectPointPool.pop() || createIntersectPoint();
				point.position.copy(intersect.point);
				intersectPointContainer.add(point);
			});
		}

		function createIntersectPoint() {
			const material = new t3d.BasicMaterial();
			material.diffuse.setHex(0xffff00);
			const geometry = new t3d.SphereGeometry(0.4);
			return new t3d.Mesh(geometry, material);
		}

		const lineSegment = new LineSegment();
		lineSegment.start.position.set(-30, 20, 20);
		lineSegment.end.position.set(0, 10, -20);
		lineSegment.syncLine();
		scene.add(lineSegment);

		lineSegment.start.updateMatrix();
		camera.updateMatrix();
		const transformControls = new TransformControls(camera, canvas);
		transformControls.size = 0.8;
		scene.add(transformControls);
		transformControls.group.addObject(lineSegment.start);

		transformControls.onDragStart = function() {
			controller.enabled = false;
		};

		transformControls.onDragEnd = function() {
			controller.enabled = true;
			doRaycast(false);
		};

		transformControls.onDrag = function() {
			lineSegment.syncLine();
			doRaycast();
		};

		const raycaster = new Raycaster();
		const mouse = new t3d.Vector2();

		document.addEventListener('mousedown', event => {
			mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
			mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

			raycaster.setFromCamera(mouse, camera);

			const array = raycaster.intersectObjects(lineSegment.getPoints(), false);
			if (array.length) {
				const object = array[0].object;
				transformControls.group.reset();
				transformControls.group.addObject(object);
			}
		});

		tiles.addEventListener('load-model', ({ scene, tile }) => {
			doRaycast();
		});

		// GUI

		const pane = new Pane();
		pane.registerPlugin(EssentialsPlugin);

		const optionsFolder = pane.addFolder({ title: 'Tiles Options', expanded: false });
		optionsFolder.addBinding(tiles, 'errorTarget', { label: 'Error Target', min: 0, step: 1 });

		const debugFolder = pane.addFolder({ title: 'Tiles Debug', expanded: false });
		const debugTilesPlugin = tiles.getPluginByName('DEBUG_TILES_PLUGIN');
		debugFolder.addBinding(debugTilesPlugin, 'displayBoxBounds', { label: 'Display Box Bounds' });

		const monitorFolder = pane.addFolder({ title: 'Tiles Monitor', expanded: true });
		const monitorOptions = { readonly: true, format: v => v.toFixed(0) };
		monitorFolder.addBinding(tiles.stats, 'downloading', monitorOptions);
		monitorFolder.addBinding(tiles.stats, 'parsing', monitorOptions);
		monitorFolder.addBinding(tiles.stats, 'visible', monitorOptions);

		const fpsGraph = monitorFolder.addBlade({
			view: 'fpsgraph',
			label: 'FPS',
			rows: 2
		});

		//

		function loop(count) {
			requestAnimationFrame(loop);

			fpsGraph.begin();

			controller.update();

			transformControls.update();

			tiles.update();

			forwardRenderer.render(scene, camera);

			fpsGraph.end();
		}
		requestAnimationFrame(loop);

		function onWindowResize() {
			width = window.innerWidth || 2;
			height = window.innerHeight || 2;

			camera.setPerspective(45 / 180 * Math.PI, width / height, 1, 10000);

			forwardRenderer.backRenderTarget.resize(width * window.devicePixelRatio, height * window.devicePixelRatio);
			tiles.resize(width * window.devicePixelRatio, height * window.devicePixelRatio);

			canvas.style.width = width + 'px';
			canvas.style.height = height + 'px';
		}
		window.addEventListener('resize', onWindowResize, false);
	</script>
</body>
</html>