// t3d-3dtiles
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).t3d=e.t3d||{},e.t3d)}(this,function(e,t){"use strict";class i{constructor(){this.fetchOptions={},this.workingPath=""}load(...e){return console.warn('Loader: "load" function has been deprecated in favor of "loadAsync".'),this.loadAsync(...e)}loadAsync(e){return fetch(e,this.fetchOptions).then(t=>{if(!t.ok)throw new Error(`Failed to load file "${e}" with status ${t.status} : ${t.statusText}`);return t.arrayBuffer()}).then(t=>(""===this.workingPath&&(this.workingPath=this.workingPathForURL(e)),this.parse(t)))}resolveExternalURL(e){return/^[^\\/]/.test(e)&&!/^http/.test(e)?this.workingPath+"/"+e:e}workingPathForURL(e){const t=e.split(/[\\/]/g);t.pop();return t.join("/")+"/"}parse(e){throw new Error("LoaderBase: Parse not implemented.")}}function r(e){if(null===e||e.byteLength<4)return"";let t;if(t=e instanceof DataView?e:new DataView(e),"{"===String.fromCharCode(t.getUint8(0)))return null;let i="";for(let e=0;e<4;e++)i+=String.fromCharCode(t.getUint8(e));return i}const s=new TextDecoder;function n(e){return s.decode(e)}function o(e){return"OCTREE"===e.__implicitRoot.implicitTiling.subdivisionScheme}function a(e){return o(e)?8:4}class l{constructor(e,t){this.parent=e,this.children=[],this.__level=e.__level+1,this.__implicitRoot=e.__implicitRoot,this.__subtreeIdx=t,[this.__x,this.__y,this.__z]=function(e,t){return t?[2*t.__x+e.__subtreeIdx%2,2*t.__y+Math.floor(e.__subtreeIdx/2)%2,o(e)?2*t.__z+Math.floor(e.__subtreeIdx/4)%2:0]:[0,0,0]}(this,e)}static copy(e){const t={children:[]};return t.__level=e.__level,t.__implicitRoot=e.__implicitRoot,t.__subtreeIdx=e.__subtreeIdx,[t.__x,t.__y,t.__z]=[e.__x,e.__y,e.__z],t.boundingVolume=e.boundingVolume,t.geometricError=e.geometricError,t}}class c extends i{constructor(e){super(),this.tile=e,this.rootTile=e.__implicitRoot,this.workingPath=null}parseBuffer(e){const t=new DataView(e);let i=0;const s=r(t);console.assert("subt"===s,'SUBTREELoader: The magic bytes equal "subt".'),i+=4;const o=t.getUint32(i,!0);console.assert(1===o,'SUBTREELoader: The version listed in the header is "1".'),i+=4;const a=t.getUint32(i,!0);i+=8;const l=t.getUint32(i,!0);i+=8;const c=JSON.parse(n(new Uint8Array(e,i,a)));i+=a;return{version:o,subtreeJson:c,subtreeByte:e.slice(i,i+l)}}async parse(e){const t=this.parseBuffer(e),i=t.subtreeJson;i.contentAvailabilityHeaders=[].concat(i.contentAvailability);const r=this.preprocessBuffers(i.buffers),s=this.preprocessBufferViews(i.bufferViews,r);this.markActiveBufferViews(i,s);const n=await this.requestActiveBuffers(r,t.subtreeByte),o=this.parseActiveBufferViews(s,n);this.parseAvailability(t,i,o),this.expandSubtree(this.tile,t)}markActiveBufferViews(e,t){let i;const r=e.tileAvailability;isNaN(r.bitstream)?isNaN(r.bufferView)||(i=t[r.bufferView]):i=t[r.bitstream],i&&(i.isActive=!0,i.bufferHeader.isActive=!0);const s=e.contentAvailabilityHeaders;for(let e=0;e<s.length;e++)i=void 0,isNaN(s[e].bitstream)?isNaN(s[e].bufferView)||(i=t[s[e].bufferView]):i=t[s[e].bitstream],i&&(i.isActive=!0,i.bufferHeader.isActive=!0);i=void 0;const n=e.childSubtreeAvailability;isNaN(n.bitstream)?isNaN(n.bufferView)||(i=t[n.bufferView]):i=t[n.bitstream],i&&(i.isActive=!0,i.bufferHeader.isActive=!0)}async requestActiveBuffers(e,t){const i=[];for(let r=0;r<e.length;r++){const s=e[r];if(s.isActive)if(s.isExternal){const e=this.parseImplicitURIBuffer(this.tile,this.rootTile.implicitTiling.subtrees.uri,s.uri),t=fetch(e,this.fetchOptions).then(e=>{if(!e.ok)throw new Error(`SUBTREELoader: Failed to load external buffer from ${s.uri} with error code ${e.status}.`);return e.arrayBuffer()}).then(e=>new Uint8Array(e));i.push(t)}else i.push(Promise.resolve(new Uint8Array(t)));else i.push(Promise.resolve())}const r=await Promise.all(i),s={};for(let e=0;e<r.length;e++){const t=r[e];t&&(s[e]=t)}return s}parseActiveBufferViews(e,t){const i={};for(let r=0;r<e.length;r++){const s=e[r];if(!s.isActive)continue;const n=s.byteOffset,o=n+s.byteLength,a=t[s.buffer];i[r]=a.slice(n,o)}return i}preprocessBuffers(e=[]){for(let t=0;t<e.length;t++){const i=e[t];i.isActive=!1,i.isExternal=!!i.uri}return e}preprocessBufferViews(e=[],t){for(let i=0;i<e.length;i++){const r=e[i];r.bufferHeader=t[r.buffer],r.isActive=!1,r.isExternal=r.bufferHeader.isExternal}return e}parseAvailability(e,t,i){const r=a(this.rootTile),s=this.rootTile.implicitTiling.subtreeLevels,n=(Math.pow(r,s)-1)/(r-1),o=Math.pow(r,s);e._tileAvailability=this.parseAvailabilityBitstream(t.tileAvailability,i,n),e._contentAvailabilityBitstreams=[];for(let r=0;r<t.contentAvailabilityHeaders.length;r++){const s=this.parseAvailabilityBitstream(t.contentAvailabilityHeaders[r],i,n);e._contentAvailabilityBitstreams.push(s)}e._childSubtreeAvailability=this.parseAvailabilityBitstream(t.childSubtreeAvailability,i,o)}parseAvailabilityBitstream(e,t,i){if(!isNaN(e.constant))return{constant:Boolean(e.constant),lengthBits:i};let r;return isNaN(e.bitstream)?isNaN(e.bufferView)||(r=t[e.bufferView]):r=t[e.bitstream],{bitstream:r,lengthBits:i}}expandSubtree(e,t){const i=l.copy(e);for(let r=0;t&&r<t._contentAvailabilityBitstreams.length;r++)if(t&&this.getBit(t._contentAvailabilityBitstreams[r],0)){i.content={uri:this.parseImplicitURI(e,this.rootTile.content.uri)};break}e.children.push(i);const r=this.transcodeSubtreeTiles(i,t),s=this.listChildSubtrees(t,r);for(let e=0;e<s.length;e++){const t=s[e],i=t.tile,r=this.deriveChildTile(null,i,null,t.childMortonIndex);r.content={uri:this.parseImplicitURI(r,this.rootTile.implicitTiling.subtrees.uri)},i.children.push(r)}}transcodeSubtreeTiles(e,t){let i=[e],r=[];for(let e=1;e<this.rootTile.implicitTiling.subtreeLevels;e++){const s=a(this.rootTile),n=(Math.pow(s,e)-1)/(s-1),o=s*i.length;for(let e=0;e<o;e++){const o=n+e,a=i[e>>Math.log2(s)];if(!this.getBit(t._tileAvailability,o)){r.push(void 0);continue}const l=this.deriveChildTile(t,a,o,e);a.children.push(l),r.push(l)}i=r,r=[]}return i}deriveChildTile(e,t,i,r){const s=new l(t,r);s.boundingVolume=this.getTileBoundingVolume(s),s.geometricError=this.getGeometricError(s);for(let t=0;e&&t<e._contentAvailabilityBitstreams.length;t++)if(e&&this.getBit(e._contentAvailabilityBitstreams[t],i)){s.content={uri:this.parseImplicitURI(s,this.rootTile.content.uri)};break}return s}getBit(e,t){if(t<0||t>=e.lengthBits)throw new Error("Bit index out of bounds.");if(void 0!==e.constant)return e.constant;const i=t>>3,r=t%8;return 1==(new Uint8Array(e.bitstream)[i]>>r&1)}getTileBoundingVolume(e){const t={};if(this.rootTile.boundingVolume.region){const i=[...this.rootTile.boundingVolume.region],r=i[0],s=i[2],n=i[1],a=i[3],l=(s-r)/Math.pow(2,e.__level),c=(a-n)/Math.pow(2,e.__level);i[0]=r+l*e.__x,i[2]=r+l*(e.__x+1),i[1]=n+c*e.__y,i[3]=n+c*(e.__y+1);for(let e=0;e<4;e++){const t=i[e];t<-Math.PI?i[e]+=2*Math.PI:t>Math.PI&&(i[e]-=2*Math.PI)}if(o(e)){const t=i[4],r=(i[5]-t)/Math.pow(2,e.__level);i[4]=t+r*e.__z,i[5]=t+r*(e.__z+1)}t.region=i}if(this.rootTile.boundingVolume.box){const i=[...this.rootTile.boundingVolume.box],r=2**e.__level-1,s=Math.pow(2,-e.__level),n=o(e)?3:2;for(let t=0;t<n;t++){i[3+3*t+0]*=s,i[3+3*t+1]*=s,i[3+3*t+2]*=s;const n=i[3+3*t+0],o=i[3+3*t+1],a=i[3+3*t+2],l=0===t?e.__x:1===t?e.__y:e.__z;i[0]+=2*n*(-.5*r+l),i[1]+=2*o*(-.5*r+l),i[2]+=2*a*(-.5*r+l)}t.box=i}return t}getGeometricError(e){return this.rootTile.geometricError/Math.pow(2,e.__level)}listChildSubtrees(e,t){const i=[],r=a(this.rootTile);for(let s=0;s<t.length;s++){const n=t[s];if(void 0!==n)for(let t=0;t<r;t++){const o=s*r+t;this.getBit(e._childSubtreeAvailability,o)&&i.push({tile:n,childMortonIndex:o})}}return i}parseImplicitURI(e,t){return t=(t=(t=(t=t.replace("{level}",e.__level)).replace("{x}",e.__x)).replace("{y}",e.__y)).replace("{z}",e.__z)}parseImplicitURIBuffer(e,t,i){const r=this.parseImplicitURI(e,t),s=new URL(r,this.workingPath+"/");return s.pathname=s.pathname.substring(0,s.pathname.lastIndexOf("/")),new URL(s.pathname+"/"+i,this.workingPath+"/").toString()}}function h(e){if(!e)return null;const t=e.replace(/[a-z]+:\/\/[^/]+/i,"").replace(/\?.*$/i,"").replace(/.*\//g,""),i=t.lastIndexOf(".");return-1===i?null:t.substring(i+1)||null}class u{get unloadPriorityCallback(){return this._unloadPriorityCallback}set unloadPriorityCallback(e){1===e.length?(console.warn('LRUCache: "unloadPriorityCallback" function has been changed to take two arguments.'),this._unloadPriorityCallback=(t,i)=>{const r=e(t),s=e(i);return r<s?-1:r>s?1:0}):this._unloadPriorityCallback=e}constructor(){this.minSize=6e3,this.maxSize=8e3,this.minBytesSize=322122547.2,this.maxBytesSize=429496729.6,this.unloadPercent=.05,this.autoMarkUnused=!0,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.unloadingHandle=-1,this.cachedBytes=0,this.bytesMap=new Map,this.loadedSet=new Set,this._unloadPriorityCallback=null;const e=this.itemSet;this.defaultPriorityCallback=t=>e.get(t)}isFull(){return this.itemSet.size>=this.maxSize||this.cachedBytes>=this.maxBytesSize}getMemoryUsage(e){return this.bytesMap.get(e)||0}setMemoryUsage(e,t){const{bytesMap:i,itemSet:r}=this;r.has(e)&&(this.cachedBytes-=i.get(e)||0,i.set(e,t),this.cachedBytes+=t)}add(e,t){const i=this.itemSet;if(i.has(e))return!1;if(this.isFull())return!1;const r=this.usedSet,s=this.itemList,n=this.callbacks;return s.push(e),r.add(e),i.set(e,Date.now()),n.set(e,t),!0}has(e){return this.itemSet.has(e)}remove(e){const t=this.usedSet,i=this.itemSet,r=this.itemList,s=this.bytesMap,n=this.callbacks,o=this.loadedSet;if(i.has(e)){this.cachedBytes-=s.get(e)||0,s.delete(e),n.get(e)(e);const a=r.indexOf(e);return r.splice(a,1),t.delete(e),i.delete(e),n.delete(e),o.delete(e),!0}return!1}setLoaded(e,t){const{itemSet:i,loadedSet:r}=this;i.has(e)&&(!0===t?r.add(e):r.delete(e))}markUsed(e){const t=this.itemSet,i=this.usedSet;t.has(e)&&!i.has(e)&&(t.set(e,Date.now()),i.add(e))}markUnused(e){this.usedSet.delete(e)}markAllUnused(){this.usedSet.clear()}unloadUnusedContent(){const{unloadPercent:e,minSize:t,maxSize:i,itemList:r,itemSet:s,usedSet:n,loadedSet:o,callbacks:a,bytesMap:l,minBytesSize:c,maxBytesSize:h}=this,u=r.length-n.size,d=r.length-o.size,p=Math.max(Math.min(r.length-t,u),0),m=this.cachedBytes-c,f=this.unloadPriorityCallback||this.defaultPriorityCallback;let g=!1;const _=p>0&&u>0||d&&r.length>i;if(u&&this.cachedBytes>c||d&&this.cachedBytes>h||_){r.sort((e,t)=>{const i=n.has(e);if(i===n.has(t)){const i=o.has(e);return i===o.has(t)?-f(e,t):i?1:-1}return i?1:-1});const d=Math.max(t*e,p*e),_=Math.ceil(Math.min(d,u,p)),b=Math.max(e*m,e*c),y=Math.min(b,m);let x=0,v=0;for(;this.cachedBytes-v>h||r.length-x>i;){const e=r[x],t=l.get(e)||0;if(n.has(e)&&o.has(e)||this.cachedBytes-v-t<h&&r.length-x<=i)break;v+=t,x++}for(;v<y||x<_;){const e=r[x],t=l.get(e)||0;if(n.has(e)||this.cachedBytes-v-t<c&&x>=_)break;v+=t,x++}r.splice(0,x).forEach(e=>{this.cachedBytes-=l.get(e)||0,a.get(e)(e),l.delete(e),s.delete(e),a.delete(e),o.delete(e),n.delete(e)}),g=x<p||v<m&&x<u,g=g&&x>0}g&&(this.unloadingHandle=requestAnimationFrame(()=>this.scheduleUnload()))}scheduleUnload(){cancelAnimationFrame(this.unloadingHandle),this.scheduled||(this.scheduled=!0,queueMicrotask(()=>{this.scheduled=!1,this.unloadUnusedContent()}))}}class d{get running(){return 0!==this.items.length||0!==this.currJobs}constructor(){this.maxJobs=6,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.autoUpdate=!0,this.priorityCallback=null,this.schedulingCallback=e=>{requestAnimationFrame(e)},this._runjobs=()=>{this.scheduled=!1,this.tryRunJobs()}}sort(){const e=this.priorityCallback,t=this.items;null!==e&&t.sort(e)}has(e){return this.callbacks.has(e)}add(e,t){const i={callback:t,reject:null,resolve:null,promise:null};return i.promise=new Promise((t,r)=>{const s=this.items,n=this.callbacks;i.resolve=t,i.reject=r,s.unshift(e),n.set(e,i),this.autoUpdate&&this.scheduleJobRun()}),i.promise}remove(e){const t=this.items,i=this.callbacks,r=t.indexOf(e);if(-1!==r){const s=i.get(e);s.promise.catch(()=>{}),s.reject(new Error("PriorityQueue: Item removed.")),t.splice(r,1),i.delete(e)}}removeByFilter(e){const{items:t}=this;for(let i=0;i<t.length;i++){const r=t[i];e(r)&&this.remove(r)}}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,i=this.maxJobs;let r=0;const s=()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()};for(;i>this.currJobs&&e.length>0&&r<i;){this.currJobs++,r++;const i=e.pop(),{callback:n,resolve:o,reject:a}=t.get(i);let l;t.delete(i);try{l=n(i)}catch(e){a(e),s()}l instanceof Promise?l.then(o).catch(a).finally(s):(o(l),s())}}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs),this.scheduled=!0)}}const p=-1,m=6378137,f={inView:!1,error:1/0,distanceFromCamera:1/0};function g(e){return 3===e||e===p}function _(e,t){return e.__lastFrameVisited===t&&e.__used}function b(e){return e.__childrenProcessed===e.children.length}function y(e,t){e.__lastFrameVisited!==t.frameCount&&(e.__lastFrameVisited=t.frameCount,e.__used=!1,e.__inFrustum=!1,e.__isLeaf=!1,e.__visible=!1,e.__active=!1,e.__error=1/0,e.__distanceFromCamera=1/0,e.__allChildrenLoaded=!1,t.calculateTileViewError(e,f),e.__inFrustum=f.inView,e.__error=f.error,e.__distanceFromCamera=f.distanceFromCamera)}function x(e,t){if(t.ensureChildrenArePreprocessed(e),y(e,t),M(e,t),e.__hasUnrenderableContent&&b(e)){const i=e.children;for(let e=0,r=i.length;e<r;e++)x(i[e],t)}}function v(e,t){if(t.ensureChildrenArePreprocessed(e),_(e,t.frameCount)&&(e.__hasContent&&t.queueTileForDownload(e),b(e))){const i=e.children;for(let e=0,r=i.length;e<r;e++)v(i[e],t)}}function M(e,t){e.__used||(e.__used=!0,t.markTileUsed(e),t.stats.used++,!0===e.__inFrustum&&t.stats.inFrustum++)}function T(e,t=null,i=null){const r=[];for(r.push(e),r.push(null),r.push(0);r.length>0;){const e=r.pop(),s=r.pop(),n=r.pop();if(t&&t(n,s,e))return void(i&&i(n,s,e));const o=n.children;if(o)for(let t=o.length-1;t>=0;t--)r.push(o[t]),r.push(n),r.push(e+1);i&&i(n,s,e)}}function A(e,t){if(t.ensureChildrenArePreprocessed(e),y(e,t),!e.__inFrustum)return;if(!function(e,t){return!(e.__error<=t.errorTarget&&!e.__hasUnrenderableContent||t.maxDepth>0&&e.__depth+1>=t.maxDepth||!b(e))}(e,t))return void M(e,t);let i=!1,r=!1;const s=e.children;for(let e=0,n=s.length;e<n;e++){const n=s[e];A(n,t),i=i||_(n,t.frameCount),r=r||n.__inFrustum}if(M(e,t),i&&"REPLACE"===e.refine&&(e.__depth,1))for(let e=0,i=s.length;e<i;e++){x(s[e],t)}}function w(e,t){const i=t.frameCount;if(!_(e,i))return;const r=e.children;let s=!1;for(let e=0,t=r.length;e<t;e++){const t=r[e];s=s||_(t,i)}if(s){let s=!0;for(let e=0,n=r.length;e<n;e++){const n=r[e];if(w(n,t),_(n,i)){const e=n.__allChildrenLoaded||!n.__hasContent||n.__hasRenderableContent&&g(n.__loadingState)||n.__hasUnrenderableContent&&n.__loadingState===p;s=s&&e}}e.__allChildrenLoaded=s}else e.__isLeaf=!0}function P(e,t){const i=t.stats;if(!_(e,t.frameCount))return;if(e.__isLeaf)return void(3===e.__loadingState?(e.__inFrustum&&(e.__visible=!0,i.visible++),e.__active=!0,i.active++):e.__hasContent&&t.queueTileForDownload(e));const r=e.children,s=e.__hasContent,n=g(e.__loadingState)&&s,o=(t.errorTarget+1)*t.errorThreshold,a=e.__error<=o,l="ADD"===e.refine,c=e.__allChildrenLoaded||0===e.__depth&&!1;if(s&&(a||l)&&t.queueTileForDownload(e),(a&&n&&!c||n&&l)&&(e.__inFrustum&&(e.__visible=!0,i.visible++),e.__active=!0,i.active++),l||!a||c)for(let e=0,i=r.length;e<i;e++)P(r[e],t);else for(let e=0,i=r.length;e<i;e++){const i=r[e];_(i,t.frameCount)&&v(i,t)}}function S(e,t){const i=_(e,t.frameCount);if(i||e.__usedLastFrame){let r=!1,s=!1;i?(r=e.__active,s=t.displayActiveTiles&&e.__active||e.__visible):y(e,t),e.__hasRenderableContent&&3===e.__loadingState&&(e.__wasSetActive!==r&&t.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,r)),e.__wasSetVisible!==s&&t.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,s))),e.__wasSetActive=r,e.__wasSetVisible=s,e.__usedLastFrame=i;const n=e.children;for(let e=0,i=n.length;e<i;e++){S(n[e],t)}}}const C=Symbol("PLUGIN_REGISTERED"),E=(e,t)=>{const i=e.priority||0,r=t.priority||0;return i!==r?i>r?1:-1:e.__used!==t.__used?e.__used?1:-1:e.__error!==t.__error?e.__error>t.__error?1:-1:e.__distanceFromCamera!==t.__distanceFromCamera?e.__distanceFromCamera>t.__distanceFromCamera?-1:1:e.__depthFromRenderedParent!==t.__depthFromRenderedParent?e.__depthFromRenderedParent>t.__depthFromRenderedParent?-1:1:0},L=(e,t)=>{const i=e.priority||0,r=t.priority||0;return i!==r?i>r?1:-1:e.__lastFrameVisited!==t.__lastFrameVisited?e.__lastFrameVisited>t.__lastFrameVisited?-1:1:e.__depthFromRenderedParent!==t.__depthFromRenderedParent?e.__depthFromRenderedParent>t.__depthFromRenderedParent?1:-1:e.__loadingState!==t.__loadingState?e.__loadingState>t.__loadingState?-1:1:e.__hasUnrenderableContent!==t.__hasUnrenderableContent?e.__hasUnrenderableContent?-1:1:e.__error!==t.__error?e.__error>t.__error?-1:1:0};class R{get root(){const e=this.rootTileSet;return e?e.root:null}get loadProgress(){const{stats:e,isLoading:t}=this,i=e.downloading+e.parsing,r=e.inCacheSinceLoad+(t?1:0);return 0===r?1:1-i/r}get errorThreshold(){return this._errorThreshold}set errorThreshold(e){console.warn('TilesRenderer: The "errorThreshold" option has been deprecated.'),this._errorThreshold=e}constructor(e=null){this.rootLoadingState=0,this.rootTileSet=null,this.rootURL=e,this.fetchOptions={},this.plugins=[],this.queuedTiles=[],this.cachedSinceLoadComplete=new Set,this.isLoading=!1;const t=new u;t.unloadPriorityCallback=L;const i=new d;i.maxJobs=25,i.priorityCallback=E;const r=new d;r.maxJobs=5,r.priorityCallback=E;const s=new d;s.maxJobs=25,this.processedTiles=new WeakSet,this.visibleTiles=new Set,this.activeTiles=new Set,this.usedSet=new Set,this.lruCache=t,this.downloadQueue=i,this.parseQueue=r,this.processNodeQueue=s,this.stats={inCacheSinceLoad:0,inCache:0,parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this._dispatchNeedsUpdateEvent=function(e){let t=null;return()=>{null===t&&(t=requestAnimationFrame(()=>{t=null,e()}))}}(()=>{this.dispatchEvent({type:"needs-update"})}),this.errorTarget=16,this._errorThreshold=1/0,this.displayActiveTiles=!1,this.maxDepth=1/0}registerPlugin(e){if(!0===e[C])throw new Error("TilesRenderer: A plugin can only be registered to a single tile set");const t=this.plugins,i=e.priority||0;let r=t.length;for(let e=0;e<t.length;e++){if((t[e].priority||0)>i){r=e;break}}t.splice(r,0,e),e[C]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if("string"==typeof e&&(e=this.getPluginByName(name)),t.includes(e)){const i=t.indexOf(e);return t.splice(i,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find(t=>t.name===e)||null}traverse(e,t,i=!0){this.root&&T(this.root,(t,...r)=>(i&&this.ensureChildrenArePreprocessed(t,!0),!!e&&e(t,...r)),t)}queueTileForDownload(e){0!==e.__loadingState||this.lruCache.isFull()||this.queuedTiles.push(e)}markTileUsed(e){this.usedSet.add(e),this.lruCache.markUsed(e)}update(){const{lruCache:e,usedSet:t,stats:i,root:r,downloadQueue:s,parseQueue:n,processNodeQueue:o}=this;if(0===this.rootLoadingState&&(this.rootLoadingState=1,this.invokeOnePlugin(e=>e.loadRootTileSet&&e.loadRootTileSet()).then(e=>{let t=this.rootURL;null!==t&&this.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),this.rootLoadingState=3,this.rootTileSet=e,this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),this.dispatchEvent({type:"load-tile-set",tileSet:e,url:t})}).catch(e=>{this.rootLoadingState=p,console.error(e),this.rootTileSet=null,this.dispatchEvent({type:"load-error",tile:null,error:e,url:this.rootURL})})),!r)return;i.inFrustum=0,i.used=0,i.active=0,i.visible=0,this.frameCount++,t.forEach(t=>e.markUnused(t)),t.clear(),A(r,this),w(r,this),P(r,this),S(r,this);const a=this.queuedTiles;a.sort(e.unloadPriorityCallback);for(let t=0,i=a.length;t<i&&!e.isFull();t++)this.requestTileContents(a[t]);a.length=0,this.lruCache.scheduleUnload();!1===(s.running||n.running||o.running)&&!0===this.isLoading&&(this.cachedSinceLoadComplete.clear(),i.inCacheSinceLoad=0,this.dispatchEvent({type:"tiles-load-end"}),this.isLoading=!1)}resetFailedTiles(){this.rootLoadingState===p&&(this.rootLoadingState=0);const e=this.stats;0!==e.failed&&(this.traverse(e=>{e.__loadingState===p&&(e.__loadingState=0)},null,!1),e.failed=0)}dispose(){[...this.plugins].forEach(e=>{this.unregisterPlugin(e)});const e=this.lruCache,t=[];this.traverse(e=>(t.push(e),!1),null,!1);for(let i=0,r=t.length;i<r;i++)e.remove(t[i]);this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}calculateBytesUsed(e,t){return 0}dispatchEvent(e){}fetchData(e,t){return fetch(e,t)}parseTile(e,t,i){return null}disposeTile(e){e.__visible&&(this.invokeOnePlugin(t=>t.setTileVisible&&t.setTileVisible(e,!1)),e.__visible=!1),e.__active&&(this.invokeOnePlugin(t=>t.setTileActive&&t.setTileActive(e,!1)),e.__active=!1)}preprocessNode(e,t,i=null){if(this.processedTiles.add(e),e.content&&(!("uri"in e.content)&&"url"in e.content&&(e.content.uri=e.content.url,delete e.content.url),e.content.boundingVolume&&!("box"in e.content.boundingVolume||"sphere"in e.content.boundingVolume||"region"in e.content.boundingVolume)&&delete e.content.boundingVolume),e.parent=i,e.children=e.children||[],e.content?.uri){const t=h(e.content.uri);e.__hasContent=!0,e.__hasUnrenderableContent=Boolean(t&&/json$/.test(t)),e.__hasRenderableContent=!e.__hasUnrenderableContent}else e.__hasContent=!1,e.__hasUnrenderableContent=!1,e.__hasRenderableContent=!1;e.__childrenProcessed=0,i&&i.__childrenProcessed++,e.__distanceFromCamera=1/0,e.__error=1/0,e.__inFrustum=!1,e.__isLeaf=!1,e.__usedLastFrame=!1,e.__used=!1,e.__wasSetVisible=!1,e.__visible=!1,e.__allChildrenLoaded=!1,e.__wasSetActive=!1,e.__active=!1,e.__loadingState=0,null===i?(e.__depth=0,e.__depthFromRenderedParent=e.__hasRenderableContent?1:0,e.refine=e.refine||"REPLACE"):(e.__depth=i.__depth+1,e.__depthFromRenderedParent=i.__depthFromRenderedParent+(e.__hasRenderableContent?1:0),e.refine=e.refine||i.refine),e.__basePath=t,e.__lastFrameVisited=-1,this.invokeAllPlugins(r=>{r!==this&&r.preprocessNode&&r.preprocessNode(e,t,i)})}setTileActive(e,t){t?this.activeTiles.add(e):this.activeTiles.delete(e)}setTileVisible(e,t){t?this.visibleTiles.add(e):this.visibleTiles.delete(e)}calculateTileViewError(e,t){}ensureChildrenArePreprocessed(e,t=!1){const i=e.children;for(let r=0,s=i.length;r<s;r++){const s=i[r];if("__depth"in s)break;t?(this.processNodeQueue.remove(s),this.preprocessNode(s,e.__basePath,e)):this.processNodeQueue.has(s)||this.processNodeQueue.add(s,t=>{this.preprocessNode(t,e.__basePath,e),this._dispatchNeedsUpdateEvent()})}}getBytesUsed(e){let t=0;return this.invokeAllPlugins(i=>{i.calculateBytesUsed&&(t+=i.calculateBytesUsed(e,e.cached.scene)||0)}),t}recalculateBytesUsed(e=null){const{lruCache:t,processedTiles:i}=this;null===e?t.itemSet.forEach(e=>{i.has(e)&&t.setMemoryUsage(e,this.getBytesUsed(e))}):t.setMemoryUsage(e,this.getBytesUsed(e))}preprocessTileSet(e,t,i=null){const r=e.asset.version,[s,n]=r.split(".").map(e=>parseInt(e));console.assert(s<=1,"TilesRenderer: asset.version is expected to be a 1.x or a compatible version."),1===s&&n>0&&console.warn("TilesRenderer: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let o=t.replace(/\/[^/]*$/,"");o=new URL(o,window.location.href).toString(),this.preprocessNode(e.root,o,i)}loadRootTileSet(){let e=this.rootURL;this.invokeAllPlugins(t=>e=t.preprocessURL?t.preprocessURL(e,null):e);return this.invokeOnePlugin(t=>t.fetchData&&t.fetchData(e,this.fetchOptions)).then(t=>{if(t instanceof Response){if(t.ok)return t.json();throw new Error(`TilesRenderer: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`)}return t}).then(t=>(this.preprocessTileSet(t,e),t))}requestTileContents(e){if(0!==e.__loadingState)return;let t=!1,i=null,r=new URL(e.content.uri,e.__basePath+"/").toString();this.invokeAllPlugins(t=>r=t.preprocessURL?t.preprocessURL(r,e):r);const s=this.stats,n=this.lruCache,o=this.downloadQueue,a=this.parseQueue,l=h(r),c=new AbortController,u=c.signal,d=n.add(e,i=>{c.abort(),t?(i.children.length=0,i.__childrenProcessed=0):this.invokeAllPlugins(e=>{e.disposeTile&&e.disposeTile(i)}),s.inCache--,this.cachedSinceLoadComplete.has(e)&&(this.cachedSinceLoadComplete.delete(e),s.inCacheSinceLoad--),1===i.__loadingState?s.downloading--:2===i.__loadingState&&s.parsing--,i.__loadingState=0,o.remove(i),a.remove(i)});d&&(this.isLoading||(this.isLoading=!0,this.dispatchEvent({type:"tiles-load-start"})),n.setMemoryUsage(e,this.getBytesUsed(e)),this.cachedSinceLoadComplete.add(e),s.inCacheSinceLoad++,s.inCache++,s.downloading++,e.__loadingState=1,o.add(e,t=>{if(u.aborted)return Promise.resolve();const i=this.invokeOnePlugin(e=>e.fetchData&&e.fetchData(r,{...this.fetchOptions,signal:u}));return this.dispatchEvent({type:"tile-download-start",tile:e}),i}).then(e=>{if(!u.aborted){if(e instanceof Response){if(e.ok)return"json"===l||"gltf"===l?e.json():e.arrayBuffer();throw new Error(`Failed to load model with error code ${e.status}`)}return e}}).then(n=>{if(!u.aborted)return s.downloading--,s.parsing++,e.__loadingState=2,a.add(e,s=>u.aborted?Promise.resolve():"json"===l&&n.root?(this.preprocessTileSet(n,r,e),e.children.push(n.root),i=n,t=!0,Promise.resolve()):this.invokeOnePlugin(e=>e.parseTile&&e.parseTile(n,s,l,r,u)))}).then(()=>{if(u.aborted)return;s.parsing--,e.__loadingState=3,n.setLoaded(e,!0);const o=this.getBytesUsed(e);0===n.getMemoryUsage(e)&&o>0&&n.isFull()?n.remove(e):(n.setMemoryUsage(e,o),this.dispatchEvent({type:"needs-update"}),this.dispatchEvent({type:"load-content"}),t&&this.dispatchEvent({type:"load-tile-set",tileSet:i,url:r}),e.cached.scene&&this.dispatchEvent({type:"load-model",scene:e.cached.scene,tile:e}))}).catch(t=>{u.aborted||("AbortError"!==t.name?(o.remove(e),a.remove(e),2===e.__loadingState?s.parsing--:1===e.__loadingState&&s.downloading--,s.failed++,console.error(`TilesRenderer: Failed to load tile at url "${e.content.uri}".`),console.error(t),e.__loadingState=p,n.setLoaded(e,!0),this.dispatchEvent({type:"load-error",tile:e,error:t,url:r})):n.remove(e))}))}getAttributions(e=[]){return this.invokeAllPlugins(t=>t!==this&&t.getAttributions&&t.getAttributions(e)),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let i=0;i<t.length;i++){const r=e(t[i]);if(r)return r}return null}invokeAllPlugins(e){const t=[...this.plugins,this],i=[];for(let r=0;r<t.length;r++){const s=e(t[r]);s&&i.push(s)}return 0===i.length?null:Promise.all(i)}}class I extends t.Loader{constructor(e){super(e),"undefined"==typeof createImageBitmap&&console.warn("ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,i,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,n={};n.credentials="anonymous"===this.crossOrigin?"same-origin":"include",n.headers=this.requestHeader,fetch(e,n).then(function(e){return e.blob()}).then(function(e){return createImageBitmap(e,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(i){t&&t(i),s.manager.itemEnd(e)}).catch(function(t){r&&r(t),s.manager.itemError(e),s.manager.itemEnd(e)}),s.manager.itemStart(e)}}const U=new t.Vector4;class D{constructor(){}static extractUrlBase(e){const t=e.split("/");return t.pop(),(t.length<1?".":t.join("/"))+"/"}static resolveURL(e,t){return"string"!=typeof e||""===e?"":/^(https?:)?\/\//i.test(e)||/^data:/i.test(e)||/^blob:/i.test(e)?e:t+e}static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let i=0,r=e.length;i<r;i++)t+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static parseGLB(e){const t=1313821514,i=5130562,r=new DataView(e),s={magic:r.getUint32(0,!0),version:r.getUint32(4,!0),length:r.getUint32(8,!0)};if(1179937895!==s.magic)return console.error("Invalid glb magic number. Expected 0x46546C67, found 0x"+s.magic.toString(16)),null;s.version<2&&console.error("GLTFLoader: Legacy binary file detected.");let n=r.getUint32(12,!0),o=r.getUint32(16,!0);if(o!==t)return console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x"+o.toString(16)),null;const a=new Uint8Array(e,20,n),l=JSON.parse(D.decodeText(a)),c=[];let h=20+n;for(;h<s.length;){if(n=r.getUint32(h,!0),o=r.getUint32(h+4,!0),o!==i)return console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x"+o.toString(16)),null;const t=h+8,s=e.slice(t,t+n);c.push(s),h+=n+8}return{gltf:l,buffers:c}}static getNormalizedComponentScale(e){if(e===Int8Array)return 1/127;if(e===Uint8Array)return 1/255;if(e===Int16Array)return 1/32767;if(e===Uint16Array)return 1/65535;throw new Error("Unsupported normalized accessor component type.")}static normalizeSkinWeights(e){const t=e.offset,i=e.buffer,r=i.stride;for(let e=0,s=i.count;e<s;e++){U.fromArray(i.array,e*r+t);const s=1/U.getManhattanLength();s!==1/0?U.multiplyScalar(s):U.set(1,0,0,0),U.toArray(i.array,e*r+t)}}}class B{static parse(e,t){const{gltf:i,path:r}=e,{nodes:s=[],skins:n=[],meshes:o=[],buffers:a,images:l}=i;if(n.forEach(e=>{const{joints:t=[]}=e;t.forEach(e=>{s[e].isBone=!0})}),s.forEach(e=>{void 0!==e.mesh&&void 0!==e.skin&&(o[e.mesh].isSkinned=!0)}),t.detailLoadProgress){const i=new Set;a&&a.forEach(e=>{if(!e.uri)return;const t=D.resolveURL(e.uri,r);i.add(t)}),l&&l.forEach((e,t)=>{const{uri:s,bufferView:n}=e;let o=s;void 0!==n&&(o="blob<"+t+">"),o=D.resolveURL(o,r),i.add(o)}),i.forEach(e=>t.manager.itemStart(e)),e.loadItems=i}}}class O{static parse(e){const{gltf:{asset:{version:t}}}=e,i=Number(t);if(!(i>=2&&i<3))throw"Only support gltf 2.x."}}class V{static parse(e,t){const{gltf:i,loadItems:r}=e;return null!==e.buffers?null:Promise.all(i.buffers.map(i=>{const s=D.resolveURL(i.uri,e.path);t.detailLoadProgress&&r.delete(s);const n=t.loadFile(s,"arraybuffer").then(e=>(t.detailLoadProgress&&t.manager.itemEnd(s),e));return t.detailLoadProgress&&n.catch(()=>t.manager.itemEnd(s)),n})).then(t=>{e.buffers=t})}}class F{static parse(e,t){const{buffers:i,gltf:r}=e;if(!r.bufferViews)return;const s=t.extensions.get("EXT_meshopt_compression");return Promise.all(r.bufferViews.map(e=>{const{buffer:r,byteOffset:n=0,byteLength:o=0}=e;if(e.extensions){const{EXT_meshopt_compression:r}=e.extensions;if(r&&s)return s.loadBufferView(r,i,t.getMeshoptDecoder())}return i[r].slice(n,n+o)})).then(t=>{e.bufferViews=t})}}class k{static parse(e,t){const{gltf:i,bufferViews:r,path:s,loadItems:n}=e;if(!i.images)return;const o=t.extensions.get("KHR_texture_basisu");return Promise.all(i.images.map((e,i)=>{const{uri:a,bufferView:l,mimeType:c,name:h}=e;let u=!1,d=a||"";if(void 0!==l){const e=r[l],t=new Blob([e],{type:c});d=URL.createObjectURL(t),u=!0}const p=D.resolveURL(d,s);let m;if(t.detailLoadProgress&&n.delete(p),c&&c.includes("ktx2")&&o)m=o.loadTextureData(p,t.getKTX2Loader()).then(e=>(t.detailLoadProgress&&(u?t.manager.itemEnd(D.resolveURL("blob<"+i+">",s)):t.manager.itemEnd(p)),e));else{const e={loader:t,imageUrl:p,imageName:h,isObjectURL:u,sourceUrl:d,index:i,path:s};if(!c||!c.includes("avif")&&!c.includes("webp"))return N(e);m=function(e){const t=new Promise(t=>{const i=new Image;e.includes("avif")?i.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=":i.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",i.onload=()=>{t(1===i.height)}});return t}(c).then(t=>{if(t)return N(e);throw new Error("GLTFLoader: WebP or AVIF required by asset but unsupported.")})}return t.detailLoadProgress&&m.catch(()=>t.manager.itemEnd(p)),m})).then(t=>{e.images=t})}}function N(e){const{loader:t,imageUrl:i,imageName:r,isObjectURL:s,sourceUrl:n,index:o,path:a}=e;return t.loadImage(i).then(e=>(e.__name=r,!0===s&&URL.revokeObjectURL(n),t.detailLoadProgress&&(s?t.manager.itemEnd(D.resolveURL("blob<"+o+">",a)):t.manager.itemEnd(i)),e))}const z={POSITION:"a_Position",NORMAL:"a_Normal",TANGENT:"a_Tangent",TEXCOORD_0:"a_Uv",TEXCOORD_1:"a_Uv2",TEXCOORD_2:"a_Uv3",TEXCOORD_3:"a_Uv4",TEXCOORD_4:"a_Uv5",TEXCOORD_5:"a_Uv6",TEXCOORD_6:"a_Uv7",TEXCOORD_7:"a_Uv8",COLOR_0:"a_Color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex",TEXCOORD0:"a_Uv",TEXCOORD:"a_Uv",COLOR0:"a_Color",COLOR:"a_Color",WEIGHT:"skinWeight",JOINT:"skinIndex"},G="MASK",H="BLEND",j={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},X={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},K={9728:t.TEXTURE_FILTER.NEAREST,9729:t.TEXTURE_FILTER.LINEAR,9984:t.TEXTURE_FILTER.NEAREST_MIPMAP_NEAREST,9985:t.TEXTURE_FILTER.LINEAR_MIPMAP_NEAREST,9986:t.TEXTURE_FILTER.NEAREST_MIPMAP_LINEAR,9987:t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR},q={33071:t.TEXTURE_WRAP.CLAMP_TO_EDGE,33648:t.TEXTURE_WRAP.MIRRORED_REPEAT,10497:t.TEXTURE_WRAP.REPEAT},$=0,Y=1,W=2,Q=3,Z=5,J=6;class ee{static parse(e){const{gltf:i,images:r}=e;if(!i.textures)return;const s=new Map;return Promise.all(i.textures.map((e,n)=>{const{sampler:o,source:a=0,name:l}=e;let c=a,h=!1;if(e.extensions){const{KHR_texture_basisu:t}=e.extensions;t?(c=t.source,h=!0):Object.values(e.extensions).length&&Object.values(e.extensions)[0].hasOwnProperty("source")?c=Object.values(e.extensions)[0].source:console.warn("GLTFLoader: unknown texture extension")}const u=c+":"+o;if(s.has(u))return s.get(u);const d=new t.Texture2D;if(h){const{image:e,mipmaps:t,type:i,format:s,minFilter:n,magFilter:o,generateMipmaps:a,encoding:l,premultiplyAlpha:h}=r[c];d.image=e,d.mipmaps=t,d.type=i,d.format=s,d.minFilter=n,d.magFilter=o,d.generateMipmaps=a,d.encoding=l,d.premultiplyAlpha=h}else d.image=r[c];d.version++,d.name=l||d.image.__name||`texture_${n}`,d.flipY=!1;const{mimeType:p,uri:m}=i.images[c];d.userData.mimeType=p||function(e){return e.startsWith("data:image/")?e.startsWith("data:image/jpeg")?"image/jpeg":e.startsWith("data:image/webp")?"image/webp":"image/png":e.search(/\.jpe?g($|\?)/i)>0?"image/jpeg":e.search(/\.webp($|\?)/i)>0?"image/webp":"image/png"}(m);return function(e,i={}){const{magFilter:r,minFilter:s,wrapS:n,wrapT:o}=i;e.magFilter=K[r]||t.TEXTURE_FILTER.LINEAR,e.minFilter=K[s]||t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR,e.wrapS=q[n]||t.TEXTURE_WRAP.REPEAT,e.wrapT=q[o]||t.TEXTURE_WRAP.REPEAT}(d,(i.samplers||{})[o]),s.set(u,d),d})).then(t=>{e.textures=t,s.clear()})}}let te=class{static parse(e,i){const{gltf:r,textures:s}=e;if(!r.materials)return;const n=i.extensions.get("KHR_texture_transform"),o=[];for(let e=0;e<r.materials.length;e++){const{extensions:a={},pbrMetallicRoughness:l,normalTexture:c,occlusionTexture:h,emissiveTexture:u,emissiveFactor:d,alphaMode:p,alphaCutoff:m,doubleSided:f,name:g=""}=r.materials[e];let _=null;const b=i.autoParseConfig.materials;for(let e=0;e<b.length;e++){const t=b[e],r=a[t],s=i.extensions.get(t);if(r&&s&&s.getMaterial){_=s.getMaterial();break}}_=_||new t.PBRMaterial,_.name=g;for(let e=0;e<b.length;e++){const t=b[e],r=a[t],o=i.extensions.get(t);r&&o&&o.parseParams&&o.parseParams(_,r,s,n)}const{KHR_materials_unlit:y,KHR_materials_pbrSpecularGlossiness:x}=a;if(l){const{baseColorFactor:e,baseColorTexture:i,metallicFactor:r,roughnessFactor:o,metallicRoughnessTexture:a}=l;Array.isArray(e)&&(_.diffuse.fromArray(e),_.opacity=void 0!==e[3]?e[3]:1),i&&(_.diffuseMap=s[i.index],_.diffuseMapCoord=i.texCoord||0,_.diffuseMap&&(_.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(_,"diffuseMap",i))),y||x||(_.metalness=void 0!==r?r:1,_.roughness=void 0!==o?o:1,a&&(_.metalnessMap=s[a.index],_.roughnessMap=s[a.index]))}d&&_.emissive.fromArray(d),u&&(_.emissiveMap=s[u.index],_.emissiveMapCoord=u.texCoord||0,_.emissiveMap&&(_.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(_,"emissiveMap",u))),h&&(_.aoMap=s[h.index],_.aoMapCoord=h.texCoord||0,void 0!==h.strength&&(_.aoMapIntensity=h.strength),_.aoMap&&n&&n.handleMaterialMap(_,"aoMap",h)),y||c&&(_.normalMap=s[c.index],_.normalScale.set(1,-1),void 0!==c.scale&&_.normalScale.set(c.scale,-c.scale)),_.side=!0===f?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,p===H?_.transparent=!0:(_.transparent=!1,p===G&&(_.alphaTest=void 0!==m?m:.5)),o[e]=_}e.materials=o}};class ie{static parse(e){const{bufferViews:i,gltf:r}=e;if(!r.accessors)return;const s=new Map,n=r.accessors.map(e=>{const{bufferView:n,type:o,componentType:a,count:l,byteOffset:c=0,normalized:h=!1,sparse:u}=e;if(void 0===n&&void 0===u)return null;const d=void 0!==n?i[n]:null,p=void 0!==n?r.bufferViews[n].byteStride:void 0,m=j[o],f=X[a],g=f.BYTES_PER_ELEMENT;let _,b;if(p&&p!==g*m){const e=Math.floor(c/p),i="Buffer:"+n+":"+a+":"+e+":"+l;let r=s.get(i);r||(_=new f(d,e*p,l*p/g),r=new t.Buffer(_,p/g),s.set(i,r)),b=new t.Attribute(r,m,c%p/g,h)}else _=null===d?new f(l*m):new f(d,c,l*m),b=new t.Attribute(new t.Buffer(_,m),m,0,h);if(u){const e=j.SCALAR,r=X[u.indices.componentType],s=u.indices.byteOffset||0,n=u.values.byteOffset||0,o=new r(i[u.indices.bufferView],s,u.count*e),a=new f(i[u.values.bufferView],n,u.count*m);null!==d&&(b=new t.Attribute(b.buffer.clone(),b.size,b.offset,b.normalized));const l=b.buffer;for(let e=0,t=o.length;e<t;e++){const t=o[e];if(l.array[t*b.size]=a[e*m],m>=2&&(l.array[t*b.size+1]=a[e*m+1]),m>=3&&(l.array[t*b.size+2]=a[e*m+2]),m>=4&&(l.array[t*b.size+3]=a[e*m+3]),m>=5)throw new Error("Unsupported itemSize in sparse Attribute.")}}return b});s.clear(),e.accessors=n}}let re=class{static parse(e,i){const{gltf:r,accessors:s,materials:n,bufferViews:o}=e;if(!r.meshes)return;const a=i.extensions.get("KHR_draco_mesh_compression"),l=new Map,c=new Map,h=[];for(let e=0;e<r.meshes.length;e++){const u=r.meshes[e],d=[];for(let e=0;e<u.primitives.length;e++){const h=u.primitives[e],{extensions:p={},mode:m,material:f}=h,{KHR_draco_mesh_compression:g}=p;let _;const b=oe(h);c.has(b)?_=c.get(b):(_=g&&a?a.getGeometry(g,o,h.attributes,r.accessors,i.getDRACOLoader()):Promise.resolve(new t.Geometry),_=_.then(e=>(se(e,h,r,s),e)),c.set(b,_));const y=_.then(e=>{const i={mode:m,geometry:e,material:void 0===f?new t.PBRMaterial:n[f],weights:Object.keys(e.morphAttributes).length>0&&u.weights?u.weights.slice(0):void 0,skinned:u.isSkinned};return ne(i,l),i});d.push(y)}h.push(Promise.all(d))}return l.clear(),c.clear(),Promise.all(h).then(t=>{e.primitives=t})}};function se(e,t,i,r){const{attributes:s,indices:n,targets:o}=t;for(const t in s){const i=s[t],n=void 0===z[t]?t:z[t];n in e.attributes||e.addAttribute(n,r[i])}void 0===n||e.index||e.setIndex(r[n]);const{boundingBox:a,boundingSphere:l}=e;if(void 0!==s.POSITION){const t=s.POSITION,r=i.accessors[t];if(r.min&&r.max){if(a.min.fromArray(r.min),a.max.fromArray(r.max),r.normalized){const e=D.getNormalizedComponentScale(X[r.componentType]);a.min.multiplyScalar(e),a.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(a.getCenter(l.center),l.radius=a.min.distanceTo(a.max)/2,o){let t=!1,i=!1;for(let e=0,r=o.length;e<r;e++){const r=o[e];if(void 0!==r.POSITION&&(t=!0),void 0!==r.NORMAL&&(i=!0),t&&i)break}if(t||i){const s=[],n=[];for(let a=0,l=o.length;a<l;a++){const l=o[a];t&&s.push(void 0!==l.POSITION?r[l.POSITION]:e.attributes[z.POSITION]),i&&n.push(void 0!==l.NORMAL?r[l.NORMAL]:e.attributes[z.NORMAL])}t&&(e.morphAttributes.position=s),i&&(e.morphAttributes.normal=n)}}return e}function ne(e,i){let{geometry:r,material:s,skinned:n,mode:o}=e;const a=void 0!==r.attributes[z.TANGENT],l=void 0!==r.attributes[z.COLOR_0],c=void 0===r.attributes[z.NORMAL],h=n;if(o===$){const e="PointsMaterial:"+s.id;let r=i.get(e);r||(r=new t.PointsMaterial,t.Material.prototype.copy.call(r,s),r.diffuse.copy(s.diffuse),r.diffuseMap=s.map,r.drawMode=o,r.acceptLight=!1,i.set(e,r)),s=r}else if(o===Y||o===Q||o===W){const e="BasicMaterial:"+s.id;let r=i.get(e);r||(r=new t.BasicMaterial,r.envMap=void 0,r.diffuse.copy(s.diffuse),r.diffuseMap=s.diffuseMap,r.drawMode=o,i.set(e,r)),s=r}else o===Z?(console.warn("TRIANGLE_STRIP will be removed later."),s.drawMode=Z):o===J&&(console.warn("TRIANGLE_FAN will be removed later."),s.drawMode=J);if(a||l||c||h){let e="ClonedMaterial:"+s.id+":";a&&(e+="vertex-tangents:"),l&&(3===r.attributes[z.COLOR_0].size?e+="vertex-colors-rgb:":4===r.attributes[z.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let n=i.get(e);n||(n=s.clone(),a&&(n.vertexTangents=!0,n.normalMap&&(n.normalScale.y*=-1)),l&&(3===r.attributes[z.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGB:4===r.attributes[z.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+r.attributes[z.COLOR_0].size)),c&&(n.shading=t.SHADING_TYPE.FLAT_SHADING)),s=n}e.material=s}function oe(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let i;if(i=t?"draco:"+t.bufferView+":"+t.indices+":"+ae(t.attributes):e.indices+":"+ae(e.attributes)+":"+e.mode,e.targets)for(let t=0,r=e.targets.length;t<r;t++)i+=":"+ae(e.targets[t]);return i}function ae(e){let t="";const i=Object.keys(e).sort();for(let r=0,s=i.length;r<s;r++)t+=i[r]+":"+e[i[r]]+";";return t}class le{static parse(e,i){const{gltf:{nodes:r,cameras:s,extensions:n}}=e;if(!r)return;const o=i.extensions.get("KHR_lights_punctual"),a=i.extensions.get("EXT_mesh_gpu_instancing"),l=[],c=[],h=r.map(i=>{const{matrix:r,translation:h,rotation:u,scale:d,camera:p,mesh:m,extensions:f={}}=i,{KHR_lights_punctual:g,EXT_mesh_gpu_instancing:_}=f;let b=null;if(i.isBone)b=new t.Bone;else if(void 0!==m)b=_&&a?a.getInstancedMesh(e,i):function(e,i){const{primitives:r}=e,{mesh:s,skin:n}=i,o=r[s].map(e=>{const{geometry:i,material:r,weights:s}=e;let o;return void 0!==n?(o=new t.SkinnedMesh(i,r),i.attributes.skinWeight&&!i.attributes.skinWeight.normalized&&D.normalizeSkinWeights(i.attributes.skinWeight)):(o=new t.Mesh(i,r),s&&(o.morphTargetInfluences=s.slice())),o});if(o.length>1){const e=new t.Object3D;return o.forEach(t=>e.add(t)),e}return o[0]}(e,i);else if(void 0!==p)b=function(e){const{orthographic:i,perspective:r,type:s}=e,n=new t.Camera;if("perspective"==s){const{aspectRatio:e,yfov:t,zfar:i,znear:s}=r;n.setPerspective(t,e||1,s||1,i||2e6)}else if("orthographic"==s){const{xmag:e,ymag:t,zfar:r,znear:s}=i;n.setOrtho(-e,e,-t,t,s||1,r||2e6)}return n}(s[p]),l.push(b);else if(g&&o){const e=g.light,t=n.KHR_lights_punctual.lights;b=o.getLight(t[e]),c.push(b)}else b=new t.Object3D;if(b.name=i.name||"",b.name&&b.children.length>0)for(let e=0;e<b.children.length;e++)b.children[e].name=b.name+"_"+e;return void 0!==r?(b.matrix.fromArray(r),b.matrix.decompose(b.position,b.quaternion,b.scale)):(void 0!==h&&b.position.fromArray(h),void 0!==u&&b.quaternion.fromArray(u),void 0!==d&&b.scale.fromArray(d)),b});e.nodes=h,e.cameras=l,e.lights=c}}class ce{static parse(e){const{gltf:i,accessors:r,nodes:s}=e,n=i.skins;if(!n)return;const o=n.map(e=>{const{inverseBindMatrices:i,joints:n}=e,o=r[i],a=[],l=[];return n.forEach((e,i)=>{const r=s[e];if(r){a.push(r);const e=new t.Matrix4;o&&e.fromArray(o.buffer.array,16*i),l.push(e)}else console.warn("Joint "+e+" could not be found.")}),new t.Skeleton(a,l)});e.skins=o,s.forEach((e,t)=>{const{skin:r}=i.nodes[t];void 0!==r&&e.traverse(function(e){e.isSkinnedMesh&&e.bind(o[r],e.worldMatrix)})})}}class he{static parse(e){const{gltf:i,nodes:r}=e,s=i.scenes.map(e=>{const{name:s="",nodes:n=[]}=e,o=new t.Object3D;o.name=s;for(let e=0;e<n.length;e++)ue(n[e],o,i.nodes,r);return o});e.roots=s,e.root=s[i.scene||0]}}function ue(e,t,i,r){const s=r[e],n=i[e];if(t.add(s),n.children){const e=n.children;for(let t=0,n=e.length;t<n;t++){ue(e[t],s,i,r)}}}class de{static parse(e,i){const{gltf:r,nodes:s,accessors:n}=e,{animations:o}=r;if(!o)return;const a=i.extensions.get("KHR_animation_pointer"),l=o.map((i,r)=>{const{channels:o,samplers:l,name:c=`animation_${r}`}=i,h=[];let u=0;for(let i=0;i<o.length;i++){const r=o[i],c=l[r.sampler];if(!c)continue;const d=r.target,p=n[c.input],m=new p.buffer.array.constructor(p.buffer.array),f=n[c.output],g=new Float32Array(f.buffer.array);if(f.normalized){const e=D.getNormalizedComponentScale(f.buffer.array.constructor);for(let t=0,i=g.length;t<i;t++)g[t]*=e}if(u=Math.max(u,m[m.length-1]),a&&d.extensions&&d.extensions.KHR_animation_pointer)a.getTrackInfos(e,d.extensions.KHR_animation_pointer,m,g,c.interpolation,h);else{const e=s[void 0!==d.node?d.node:d.id];if(!e)continue;let i,r;if("rotation"===d.path)i=t.QuaternionKeyframeTrack,r="quaternion";else if("weights"===d.path)i=t.NumberKeyframeTrack,r="morphTargetInfluences";else if("translation"===d.path)i=t.VectorKeyframeTrack,r="position";else{if("scale"!==d.path)continue;i=t.VectorKeyframeTrack,r="scale"}h.push({TypedKeyframeTrack:i,target:e,propertyPath:r,times:m,values:g,interpolation:c.interpolation})}}const d=[];return h.forEach(e=>{const{TypedKeyframeTrack:i,target:r,propertyPath:s,times:n,values:o,interpolation:a}=e,l=function(e,i){switch(e){case"STEP":return t.StepInterpolant;case"CUBICSPLINE":return i?t.QuaternionCubicSplineInterpolant:t.CubicSplineInterpolant;default:return i?t.QuaternionLinearInterpolant:t.LinearInterpolant}}(a,i===t.QuaternionKeyframeTrack);if("morphTargetInfluences"===s)r.traverse(e=>{if(e.isMesh&&e.morphTargetInfluences){const t=new i(e,s,n,o,l);d.push(t)}});else{const e=new i(r,s,n,o,l);d.push(e)}}),new t.KeyframeClip(c,d,u)});e.animations=l}}let pe=0;class me{constructor(){this.id=++pe,this.url="",this.path="",this.options=null,this.gltf=null,this.loadItems=null,this.buffers=null,this.bufferViews=null,this.images=null,this.textures=null,this.materials=null,this.accessors=null,this.primitives=null,this.nodes=null,this.cameras=null,this.lights=null,this.skins=null,this.root=null,this.roots=null,this.animations=null}}class fe{static getMaterial(){return new t.PBRMaterial}static parseParams(e,i,r){if(e.constructor!==t.PBRMaterial)return;const{clearcoatFactor:s,clearcoatTexture:n,clearcoatRoughnessFactor:o,clearcoatRoughnessTexture:a,clearcoatNormalTexture:l}=i;if(s&&(e.clearcoat=s),n&&(e.clearcoatMap=r[n.index]),o&&(e.clearcoatRoughness=o),a&&(e.clearcoatRoughnessMap=r[a.index]),l&&(e.clearcoatNormalMap=r[l.index],l.scale)){const i=l.scale;e.clearcoatNormalScale=new t.Vector2(i,i)}}}class ge{static getMaterial(){return new t.PBR2Material}static parseParams(e,i,r,s){if(e.constructor!==t.PBR2Material)return;const{diffuseFactor:n,diffuseTexture:o,specularFactor:a,glossinessFactor:l,specularGlossinessTexture:c}=i;Array.isArray(n)&&(e.diffuse.fromArray(n),e.opacity=n[3]||1),o&&(e.diffuseMap=r[o.index],e.diffuseMapCoord=o.texCoord||0,e.diffuseMap&&(e.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,s&&s.handleMaterialMap(e,"diffuseMap",o))),e.glossiness=void 0!==l?l:1,Array.isArray(a)&&e.specular.fromArray(a),c&&(e.glossinessMap=r[c.index],e.specularMap=r[c.index])}}const _e=[class{static parse(e,t){const{url:i}=e;return t.loadFile(i,"arraybuffer").then(t=>{if("glTF"===D.decodeText(new Uint8Array(t,0,4))){const i=D.parseGLB(t);e.gltf=i.gltf,e.buffers=i.buffers}else{const i=D.decodeText(new Uint8Array(t));e.gltf=JSON.parse(i)}})}},B,O,V,F,k,ee,te,ie,re,le,ce,he,de],be=new Map([["EXT_meshopt_compression",class{static loadBufferView(e,t,i){const r=t[e.buffer];if(!i||!i.supported)throw new Error("GLTFLoader: setMeshoptDecoder must be called before loading compressed files.");const s=e.byteOffset||0,n=e.byteLength||0,o=e.count,a=e.byteStride,l=new Uint8Array(r,s,n);return i.decodeGltfBufferAsync?i.decodeGltfBufferAsync(o,a,l,e.mode,e.filter).then(e=>e.buffer):i.ready.then(()=>{const t=new ArrayBuffer(o*a);return i.decodeGltfBuffer(new Uint8Array(t),o,a,l,e.mode,e.filter),t})}}],["KHR_draco_mesh_compression",class{static getGeometry(e,t,i,r,s){const{bufferView:n,attributes:o}=e;if(!s)throw new Error("GLTFLoader: No DRACOLoader instance provided.");const a={};for(const e in o){a[void 0===z[e]?e:z[e]]=o[e]}const l={},c={};for(const e in i){const t=z[e]||e.toLowerCase();if(void 0!==o[e]){const s=r[i[e]],n=X[s.componentType];c[t]=n.name,l[t]=!0===s.normalized}}const h=t[n];return new Promise(function(e){s.decodeDracoFile(h,function(t){for(const e in t.attributes){const i=t.attributes[e],r=l[e];void 0!==r&&(i.normalized=r)}e(t)},a,c)})}}],["KHR_lights_punctual",class{static getLight(e){const{color:i,intensity:r=1,type:s,range:n,spot:o}=e;let a;if("directional"===s)a=new t.DirectionalLight;else if("point"===s)a=new t.PointLight,void 0!==n&&(a.distance=n);else{if("spot"!==s)throw new Error("Unexpected light type: "+s);if(a=new t.SpotLight,void 0!==n&&(a.distance=n),o){const{innerConeAngle:e=0,outerConeAngle:t=Math.PI/4}=o;a.angle=t,a.penumbra=1-e/t}}return i&&a.color.fromArray(i),a.intensity=r,a}}],["KHR_materials_clearcoat",fe],["KHR_materials_pbrSpecularGlossiness",ge],["KHR_materials_unlit",class{static getMaterial(){return new t.BasicMaterial}}],["KHR_mesh_quantization",{}],["KHR_texture_basisu",class{static loadTextureData(e,t){return new Promise((i,r)=>{t.load(e,i,void 0,r)})}}],["KHR_texture_transform",class{static handleMaterialMap(e,t,i){if(!i.extensions)return;const r=i.extensions.KHR_texture_transform;if(!r)return;void 0!==r.texCoord&&(e[t+"Coord"]=r.texCoord);const s=e[t+"Transform"];s&&(void 0!==r.offset&&s.offset.fromArray(r.offset),void 0!==r.rotation&&(s.rotation=r.rotation),void 0!==r.scale&&s.scale.fromArray(r.scale),s.updateMatrix())}}],["KHR_animation_pointer",class{static getTrackInfos(e,i,r,s,n,o){const{pointer:a}=i,l=a.replace(/^\//,"").split("/"),c=l[0],h=parseInt(l[1]),u=l[l.length-1],d=e[c];if(!d)return;const p=d[h];if(!p)return;let m,f,g,_;if("rotation"===u)m=t.QuaternionKeyframeTrack,f="quaternion";else if("weights"===u)m=t.NumberKeyframeTrack,f="morphTargetInfluences";else if("translation"===u)m=t.VectorKeyframeTrack,f="position";else if("scale"===u)m=t.VectorKeyframeTrack,f="scale";else if("baseColorFactor"===u)m=t.ColorKeyframeTrack,f="diffuse",g=t.NumberKeyframeTrack,_="opacity";else if("metallicFactor"===u)m=t.NumberKeyframeTrack,f="metalness";else if("roughnessFactor"===u)m=t.NumberKeyframeTrack,f="roughness";else if("emissiveFactor"===u)m=t.VectorKeyframeTrack,f="emissive";else{if("KHR_texture_transform"!==l[l.length-2])return;{m=t.VectorKeyframeTrack;const e=l[l.length-4];if("baseColorTexture"===e)f="diffuseMapTransform."+u;else{if("emissiveTexture"!==e)return;f="emissiveMapTransform."+u}}}if("baseColorFactor"===u){const e=new Float32Array(s.length/4*3),t=new Float32Array(s.length/4);for(let i=0;i<s.length/4;i++)e[3*i]=s[4*i],e[3*i+1]=s[4*i+1],e[3*i+2]=s[4*i+2],t[i]=s[4*i+3];o.push({TypedKeyframeTrack:m,target:p,propertyPath:f,times:r,values:e,interpolation:n}),o.push({TypedKeyframeTrack:g,target:p,propertyPath:_,times:r,values:t,interpolation:n})}else o.push({TypedKeyframeTrack:m,target:p,propertyPath:f,times:r,values:s,interpolation:n})}}]]);class ye{constructor(e=t.DefaultLoadingManager,i=_e,r=be){this.manager=e,this.detailLoadProgress=!0,this.autoLogError=!0,this.extensions=new Map(r),this.autoParseConfig={materials:["KHR_materials_clearcoat","KHR_materials_pbrSpecularGlossiness","KHR_materials_unlit","KHR_materials_transmission","KHR_materials_ior","KHR_materials_volume","KHR_materials_dispersion"]},this._parsers=i.slice(0),this._dracoLoader=null,this._meshoptDecoder=null,this._ktx2Loader=null,this._fileLoader=new t.FileLoader;const s=navigator.userAgent,n=!0===/^((?!chrome|android).)*safari/i.test(s),o=s.match(/Version\/(\d+)/),a=n&&o?parseInt(o[1],10):-1,l=s.indexOf("Firefox")>-1,c=l?s.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||n&&a<17||l&&c<98?this._imageLoader=new t.ImageLoader:this._imageLoader=new I}load(e,t={}){return this.manager.itemStart(e),new Promise((i,r)=>{const s=new me;s.url=e,s.path=D.extractUrlBase(e),s.options=t,this._parse(s).then(i).then(()=>this.manager.itemEnd(e)).catch(t=>{this.autoLogError&&console.error(t),this.detailLoadProgress&&s.loadItems&&s.loadItems.forEach(e=>{this.manager.itemEnd(e)}),this.manager.itemError(e),this.manager.itemEnd(e),r(`Error loading glTF model from ${e} .`)})})}_parse(e){let t;return new Promise((i,r)=>{this._parsers.forEach(i=>{t=t?t.then(()=>i.parse(e,this)):i.parse(e,this)}),t?t.then(()=>i(e)).catch(r):i(e)})}setDRACOLoader(e){return this._dracoLoader=e,this}getDRACOLoader(){return this._dracoLoader}setMeshoptDecoder(e){return this._meshoptDecoder=e,this}getMeshoptDecoder(){return this._meshoptDecoder}setKTX2Loader(e){return this._ktx2Loader=e,this}getKTX2Loader(){return this._ktx2Loader}loadFile(e,t="json"){return this._fileLoader.setResponseType(t),new Promise((t,i)=>{e=this.manager.resolveURL(e),this._fileLoader.load(e,t,void 0,i)})}loadImage(e){return new Promise((t,i)=>{e=this.manager.resolveURL(e),this._imageLoader.load(e,t,void 0,i)})}insertParser(e,t){this._parsers.splice(t,0,e)}replaceParser(e,t){this._parsers.splice(t,1,e)}}class xe{static parse(e,t){const i=e.options.buffer,r=new DataView(i),s=String.fromCharCode(r.getUint8(0))+String.fromCharCode(r.getUint8(1))+String.fromCharCode(r.getUint8(2))+String.fromCharCode(r.getUint8(3)),n=h(e.url);if(s!==n)throw`Not a ${n} type resource, with url ${e.url}!`;const o=r.getUint32(4,!0);if(1!==o)throw`${n} version must be 1, with url ${e.url}!`;const a=r.getUint32(8,!0);if(a!==i.byteLength)throw`${n} data byte length check failed, with url ${e.url}!`;if("cmpt"===n){const t=r.getUint32(12,!0);return void(e.header={magic:s,version:o,byteLength:a,tilesLength:t})}const l=r.getUint32(12,!0),c=r.getUint32(16,!0),u=r.getUint32(20,!0),d=r.getUint32(24,!0);let p=null;"i3dm"===n&&(p=r.getUint32(28,!0)),e.header={magic:s,version:o,byteLength:a,featureTableJSONByteLength:l,featureTableBinaryByteLength:c,batchTableJSONByteLength:u,batchTableBinaryByteLength:d,gltfFormat:p}}}function ve(e,t,i,r,s,n){let o,a;switch(r){case"SCALAR":o=1;break;case"VEC2":o=2;break;case"VEC3":o=3;break;case"VEC4":o=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${n}".`)}const l=i*o;switch(s){case"BYTE":a=new Int8Array(e,t,l);break;case"UNSIGNED_BYTE":a=new Uint8Array(e,t,l);break;case"SHORT":a=new Int16Array(e,t,l);break;case"UNSIGNED_SHORT":a=new Uint16Array(e,t,l);break;case"INT":a=new Int32Array(e,t,l);break;case"UNSIGNED_INT":a=new Uint32Array(e,t,l);break;case"FLOAT":a=new Float32Array(e,t,l);break;case"DOUBLE":a=new Float64Array(e,t,l);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${n}".`)}return a}class Me{constructor(e,t,i,r){this.buffer=e,this.binOffset=t+i,this.binLength=r;let s=null;if(0!==i){const r=new Uint8Array(e,t,i);s=JSON.parse(n(r))}else s={};this.header=s}getKeys(){return Object.keys(this.header)}getData(e,t,i=null,r=null){const s=this.header;if(!(e in s))return null;const n=s[e];if(n instanceof Object){if(Array.isArray(n))return n;{const{buffer:s,binOffset:o,binLength:a}=this,l=n.byteOffset||0,c=n.type||r,h=n.componentType||i;if("type"in n&&r&&n.type!==r)throw new Error("FeatureTable: Specified type does not match expected type.");const u=o+l,d=ve(s,u,t,c,h,e);if(u+d.byteLength>o+a)throw new Error("FeatureTable: Feature data read outside binary body length.");return d}}return n}getBuffer(e,t){const{buffer:i,binOffset:r}=this;return i.slice(r+e,r+e+t)}}class Te{constructor(e){this.batchTable=e;const t=e.header.extensions["3DTILES_batch_table_hierarchy"];this.classes=t.classes;for(const e of this.classes){const t=e.instances;for(const i in t)e.instances[i]=this._parseProperty(t[i],e.length,i)}if(this.instancesLength=t.instancesLength,this.classIds=this._parseProperty(t.classIds,this.instancesLength,"classIds"),t.parentCounts?this.parentCounts=this._parseProperty(t.parentCounts,this.instancesLength,"parentCounts"):this.parentCounts=new Array(this.instancesLength).fill(1),t.parentIds){const e=this.parentCounts.reduce((e,t)=>e+t,0);this.parentIds=this._parseProperty(t.parentIds,e,"parentIds")}else this.parentIds=null;this.instancesIds=[];const i={};for(const e of this.classIds)i[e]=i[e]??0,this.instancesIds.push(i[e]),i[e]++}_parseProperty(e,t,i){if(Array.isArray(e))return e;{const{buffer:r,binOffset:s}=this.batchTable;return ve(r,s+e.byteOffset,t,"SCALAR",e.componentType||"UNSIGNED_SHORT",i)}}getDataFromId(e,t={}){const i=this.parentCounts[e];if(this.parentIds&&i>0){let r=0;for(let t=0;t<e;t++)r+=this.parentCounts[t];for(let s=0;s<i;s++){const i=this.parentIds[r+s];i!==e&&this.getDataFromId(i,t)}}const r=this.classIds[e],s=this.classes[r].instances,n=this.classes[r].name,o=this.instancesIds[e];for(const e in s)t[n]=t[n]||{},t[n][e]=s[e][o];return t}}class Ae extends Me{get batchSize(){return console.warn("BatchTable.batchSize has been deprecated and replaced with BatchTable.count."),this.count}constructor(e,t,i,r,s){super(e,i,r,s),this.count=t,this.extensions={};const n=this.header.extensions;n&&n["3DTILES_batch_table_hierarchy"]&&(this.extensions["3DTILES_batch_table_hierarchy"]=new Te(this))}getData(e,t=null,i=null){return console.warn("BatchTable: BatchTable.getData is deprecated. Use BatchTable.getDataFromId to get allproperties for an id or BatchTable.getPropertyArray for getting an array of value for a property."),super.getData(e,this.count,t,i)}getDataFromId(e,t={}){if(e<0||e>=this.count)throw new Error(`BatchTable: id value "${e}" out of bounds for "${this.count}" features number.`);for(const i of this.getKeys())"extensions"!==i&&(t[i]=super.getData(i,this.count)[e]);for(const i in this.extensions){const r=this.extensions[i];r.getDataFromId instanceof Function&&(t[i]=t[i]||{},r.getDataFromId(e,t[i]))}return t}getPropertyArray(e){return super.getData(e,this.count)}}class we{static parse(e,t){const{header:i,options:r}=e,s=r.buffer,n="i3dm"===i.magic?32:28,o=n+i.featureTableJSONByteLength+i.featureTableBinaryByteLength,a=o,l=a+i.batchTableJSONByteLength+i.batchTableBinaryByteLength,c=s.slice(n,o),h=new Me(c,0,i.featureTableJSONByteLength,i.featureTableBinaryByteLength);let u;if("b3dm"===i.magic)u=h.getData("BATCH_LENGTH");else if("i3dm"===i.magic)u=h.getData("INSTANCES_LENGTH");else{if("pnts"!==i.magic)throw`Unrecognized magic: ${i.magic}!`;u=h.getData("BATCH_LENGTH")||h.getData("POINTS_LENGTH")}const d=s.slice(a,l),p=new Ae(d,u,0,i.batchTableJSONByteLength,i.batchTableBinaryByteLength);e.featureTable=h,e.batchTable=p,e.batchTableEnd=l}}class Pe{static parse(e,t){const i=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd),r=D.parseGLB(i.slice().buffer);e.gltf=r.gltf,e.buffers=r.buffers}}class Se{static parse(e,t){const{root:i,featureTable:r,options:s}=e,n=r.getData("RTC_CENTER");n&&(i.position.x+=n[0],i.position.y+=n[1],i.position.z+=n[2]),s.adjustmentTransform&&(i.matrix.transform(i.position,i.scale,i.quaternion),i.matrix.multiply(s.adjustmentTransform),i.matrix.decompose(i.position,i.quaternion,i.scale))}}class Ce{static getMaterial(){return new t.PBRMaterial}static parseParams(e,t,i){const{values:r}=t,{u_diffuse:s}=r;s&&(e.diffuseMap=i[s.index],e.diffuseMapCoord=s.texCoord||0)}}class Ee extends ye{constructor(e){super(e,[xe,we,Pe,B,O,V,F,k,ee,te,ie,re,le,ce,he,de,Se]),this.extensions.set("KHR_techniques_webgl",Ce),this.autoParseConfig.materials.push("KHR_techniques_webgl")}}class Le{static parse(e,t){const i=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd);let r=null;if(1===e.header.gltfFormat)r=Promise.resolve(i);else{const s=D.resolveURL(D.decodeText(i),e.path);r=t.loadFile(s,"arraybuffer").then(e=>new Uint8Array(e))}return r.then(t=>{const i=D.parseGLB(t.slice().buffer);e.gltf=i.gltf,e.buffers=i.buffers})}}const Re="\n#ifdef USE_INSTANCING\n\tattribute mat4 instanceMatrix;\n\tuniform mat4 instanceOffset;\n#endif\n",Ie="\n#ifdef USE_INSTANCING\n\tmat4 instancingMatrix = inverseMat4(instanceOffset) * instanceMatrix * instanceOffset;\n\ttransformed = (instancingMatrix * vec4(transformed, 1.0)).xyz;\n#endif\n";let Ue=t.ShaderLib.pbr_vert;Ue=Ue.replace("#include <logdepthbuf_pars_vert>",`\n#include <logdepthbuf_pars_vert>\n${Re}\n`),Ue=Ue.replace("#include <pvm_vert>",`\n${Ie}\n#include <pvm_vert>\n`),Ue=Ue.replace("#include <normal_vert>","\n\n#ifdef USE_INSTANCING\n\tmat4 instancingNormalMatrix = transposeMat4(inverseMat4(instancingMatrix));\n\n\tobjectNormal = (instancingNormalMatrix * vec4(objectNormal, 0.0)).xyz;\n\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = (instancingNormalMatrix * vec4(objectTangent, 0.0)).xyz;\n\t#endif\n#endif\n\n#include <normal_vert>\n");class De extends t.PBRMaterial{constructor(e){super(),this.type=t.MATERIAL_TYPE.SHADER,e&&this.copy(e),this.shaderName="InstancedPBR",this.vertexShader=Ue,this.fragmentShader=t.ShaderLib.pbr_frag,this.defines.USE_INSTANCING=!0,this.uniforms.instanceOffset=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}}let Be=t.ShaderLib.basic_vert;Be=Be.replace("#include <logdepthbuf_pars_vert>",`\n\t#include <logdepthbuf_pars_vert>\n\t${Re}\n`),Be=Be.replace("#include <pvm_vert>",`\n\t${Ie}\n\t#include <pvm_vert>\n`);class Oe extends t.BasicMaterial{constructor(e){super(),this.type=t.MATERIAL_TYPE.SHADER,e&&this.copy(e),this.shaderName="InstancedBasic",this.vertexShader=Be,this.fragmentShader=t.ShaderLib.basic_frag,this.defines.USE_INSTANCING=!0,this.uniforms.instanceOffset=new Float32Array([1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}}let Ve=t.ShaderLib.depth_vert;Ve=Ve.replace("#include <logdepthbuf_pars_vert>",`\n\t#include <logdepthbuf_pars_vert>\n\t${Re}\n`),Ve=Ve.replace("#include <pvm_vert>",`\n\t${Ie}\n\t#include <pvm_vert>\n`);class Fe{static parse(e,i){const{gltf:r,textures:s}=e;if(!r.materials)return;const n=i.extensions.get("KHR_texture_transform"),o=[];for(let e=0;e<r.materials.length;e++){const{extensions:a={},pbrMetallicRoughness:l,normalTexture:c,occlusionTexture:h,emissiveTexture:u,emissiveFactor:d,alphaMode:p,alphaCutoff:m,doubleSided:f,name:g=""}=r.materials[e];let _=null;const b=i.autoParseConfig.materials;for(let e=0;e<b.length;e++){const t=b[e],r=a[t],s=i.extensions.get(t);if(r&&s&&s.getMaterial){_=s.getMaterial();break}}_=_||new De,_.name=g;for(let e=0;e<b.length;e++){const t=b[e],r=a[t],o=i.extensions.get(t);r&&o&&o.parseParams&&o.parseParams(_,r,s,n)}const{KHR_materials_unlit:y,KHR_materials_pbrSpecularGlossiness:x}=a;if(l){const{baseColorFactor:e,baseColorTexture:i,metallicFactor:r,roughnessFactor:o,metallicRoughnessTexture:a}=l;Array.isArray(e)&&(_.diffuse.fromArray(e),_.opacity=void 0!==e[3]?e[3]:1),i&&(_.diffuseMap=s[i.index],_.diffuseMapCoord=i.texCoord||0,_.diffuseMap&&(_.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(_,"diffuseMap",i))),y||x||(_.metalness=void 0!==r?r:1,_.roughness=void 0!==o?o:1,a&&(_.metalnessMap=s[a.index],_.roughnessMap=s[a.index]))}d&&_.emissive.fromArray(d),u&&(_.emissiveMap=s[u.index],_.emissiveMapCoord=u.texCoord||0,_.emissiveMap&&(_.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(_,"emissiveMap",u))),h&&(_.aoMap=s[h.index],_.aoMapCoord=h.texCoord||0,void 0!==h.strength&&(_.aoMapIntensity=h.strength),_.aoMap&&n&&n.handleMaterialMap(_,"aoMap",h)),y||c&&(_.normalMap=s[c.index],_.normalScale.set(1,-1),void 0!==c.scale&&_.normalScale.set(c.scale,-c.scale)),_.side=!0===f?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,p===H?_.transparent=!0:(_.transparent=!1,p===G&&(_.alphaTest=void 0!==m?m:.5)),o[e]=_}e.materials=o}}class ke{static parse(e,i){const{gltf:r,accessors:s,materials:n,bufferViews:o}=e;if(!r.meshes)return;const a=i.extensions.get("KHR_draco_mesh_compression"),l=new Map,c=new Map,h=[];for(let e=0;e<r.meshes.length;e++){const u=r.meshes[e],d=[];for(let e=0;e<u.primitives.length;e++){const h=u.primitives[e],{extensions:p={},mode:m,material:f}=h,{KHR_draco_mesh_compression:g}=p;let _;const b=Ge(h);c.has(b)?_=c.get(b):(_=g&&a?a.getGeometry(g,o,h.attributes,r.accessors,i.getDRACOLoader()):Promise.resolve(new t.Geometry),_=_.then(e=>(Ne(e,h,r,s),e)),c.set(b,_));const y=_.then(e=>{const t={mode:m,geometry:e,material:void 0===f?new De:n[f],weights:Object.keys(e.morphAttributes).length>0&&u.weights?u.weights.slice(0):void 0,skinned:u.isSkinned};return ze(t,l),t});d.push(y)}h.push(Promise.all(d))}return l.clear(),c.clear(),Promise.all(h).then(t=>{e.primitives=t})}}function Ne(e,t,i,r){const{attributes:s,indices:n,targets:o}=t;for(const t in s){const i=s[t],n=void 0===z[t]?t:z[t];n in e.attributes||e.addAttribute(n,r[i])}void 0===n||e.index||e.setIndex(r[n]);const{boundingBox:a,boundingSphere:l}=e;if(void 0!==s.POSITION){const t=s.POSITION,r=i.accessors[t];if(r.min&&r.max){if(a.min.fromArray(r.min),a.max.fromArray(r.max),r.normalized){const e=D.getNormalizedComponentScale(X[r.componentType]);a.min.multiplyScalar(e),a.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(a.getCenter(l.center),l.radius=a.min.distanceTo(a.max)/2,o){let t=!1,i=!1;for(let e=0,r=o.length;e<r;e++){const r=o[e];if(void 0!==r.POSITION&&(t=!0),void 0!==r.NORMAL&&(i=!0),t&&i)break}if(t||i){const s=[],n=[];for(let a=0,l=o.length;a<l;a++){const l=o[a];t&&s.push(void 0!==l.POSITION?r[l.POSITION]:e.attributes[z.POSITION]),i&&n.push(void 0!==l.NORMAL?r[l.NORMAL]:e.attributes[z.NORMAL])}t&&(e.morphAttributes.position=s),i&&(e.morphAttributes.normal=n)}}return e}function ze(e,i){let{geometry:r,material:s,skinned:n,mode:o}=e;const a=void 0!==r.attributes[z.TANGENT],l=void 0!==r.attributes[z.COLOR_0],c=void 0===r.attributes[z.NORMAL],h=n;if(o===$){const e="PointsMaterial:"+s.id;let r=i.get(e);r||(r=new t.PointsMaterial,t.Material.prototype.copy.call(r,s),r.diffuse.copy(s.diffuse),r.diffuseMap=s.map,r.drawMode=o,r.acceptLight=!1,i.set(e,r)),s=r}else if(o===Y||o===Q||o===W){const e="BasicMaterial:"+s.id;let r=i.get(e);r||(r=new t.BasicMaterial,r.envMap=void 0,r.diffuse.copy(s.diffuse),r.diffuseMap=s.diffuseMap,r.drawMode=o,i.set(e,r)),s=r}else o===Z?(console.warn("TRIANGLE_STRIP will be removed later."),s.drawMode=Z):o===J&&(console.warn("TRIANGLE_FAN will be removed later."),s.drawMode=J);if(a||l||c||h){let e="ClonedMaterial:"+s.id+":";a&&(e+="vertex-tangents:"),l&&(3===r.attributes[z.COLOR_0].size?e+="vertex-colors-rgb:":4===r.attributes[z.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let n=i.get(e);n||(n=s.clone(),a&&(n.vertexTangents=!0,n.normalMap&&(n.normalScale.y*=-1)),l&&(3===r.attributes[z.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGB:4===r.attributes[z.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+r.attributes[z.COLOR_0].size)),c&&(n.shading=t.SHADING_TYPE.FLAT_SHADING)),s=n}e.material=s}function Ge(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let i;if(i=t?"draco:"+t.bufferView+":"+t.indices+":"+He(t.attributes):e.indices+":"+He(e.attributes)+":"+e.mode,e.targets)for(let t=0,r=e.targets.length;t<r;t++)i+=":"+He(e.targets[t]);return i}function He(e){let t="";const i=Object.keys(e).sort();for(let r=0,s=i.length;r<s;r++)t+=i[r]+":"+e[i[r]]+";";return t}class je{static parse(e,i){const{featureTable:r,root:s,options:n}=e,o=r.getData("INSTANCES_LENGTH"),a=r.getData("POSITION",o,"FLOAT","VEC3"),l=r.getData("NORMAL_UP",o,"FLOAT","VEC3"),c=r.getData("NORMAL_RIGHT",o,"FLOAT","VEC3"),h=r.getData("SCALE",o,"FLOAT","SCALAR"),u=r.getData("SCALE_NON_UNIFORM",o,"FLOAT","VEC3");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach(e=>{e in r.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`)});const d=new t.Vector3;for(let e=0;e<o;e++)d.x+=a[3*e+0]/o,d.y+=a[3*e+1]/o,d.z+=a[3*e+2]/o;const p=[];s.traverse(e=>{if(e.isMesh){const{geometry:i}=e;i.instanceCount=o;const r=new t.Attribute(new t.Buffer(new Float32Array(16*o),16),16);r.divisor=1,i.addAttribute("instanceMatrix",r),e.updateMatrix(!0),e.position.copy(d).applyMatrix4(e.worldMatrix),p.push(e)}});for(let e=0;e<o;e++){$e.fromArray(a,3*e).sub(d),l?(Ke.fromArray(l,3*e),qe.fromArray(c,3*e),Xe.crossVectors(qe,Ke).normalize(),Qe.set(qe.x,Ke.x,Xe.x,0,qe.y,Ke.y,Xe.y,0,qe.z,Ke.z,Xe.z,0,0,0,0,1),Ye.setFromRotationMatrix(Qe)):Ye.set(0,0,0,1),h?We.set(h[e],h[e],h[e]):u?We.fromArray(u,3*e):We.set(1,1,1),Qe.transform($e,We,Ye).multiply(n.adjustmentTransform);for(let t=0,i=p.length;t<i;t++){const{geometry:i}=p[t],r=i.getAttribute("instanceMatrix").buffer.array;Qe.toArray(r,16*e),i.version++}}const m=r.getData("RTC_CENTER");m&&(s.position.x+=m[0],s.position.y+=m[1],s.position.z+=m[2])}}const Xe=new t.Vector3,Ke=new t.Vector3,qe=new t.Vector3,$e=new t.Vector3,Ye=new t.Quaternion,We=new t.Vector3,Qe=new t.Matrix4;class Ze extends Ce{static getMaterial(){return new De}}class Je{static getMaterial(){return new Oe}}class et extends ge{static getMaterial(){const e=new De;return e.specular=new t.Color3(1118481),e}}class tt extends fe{static getMaterial(){return new De}}class it extends ye{constructor(e){super(e,[xe,we,Le,B,O,V,F,k,ee,Fe,ie,ke,le,ce,he,de,je]),this.extensions.set("KHR_techniques_webgl",Ze),this.extensions.set("KHR_materials_unlit",Je),this.extensions.set("KHR_materials_pbrSpecularGlossiness",et),this.extensions.set("KHR_materials_clearcoat",tt),this.autoParseConfig.materials.push("KHR_techniques_webgl")}}class rt{static parse(e,i){const{featureTable:r}=e,s=r.getData("POINTS_LENGTH"),n=r.getData("POSITION",s,"FLOAT","VEC3"),o=r.getData("RGB",s,"UNSIGNED_BYTE","VEC3"),a=r.getData("RGBA",s,"UNSIGNED_BYTE","VEC4");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGB565","NORMAL","NORMAL_OCT16P","BATCH_ID"].forEach(e=>{e in r.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`)});const l=new t.Geometry;l.addAttribute("a_Position",new t.Attribute(new t.Buffer(n,3),3,0,!0)),l.computeBoundingBox(),l.computeBoundingSphere();const c=new t.PointsMaterial;c.size=2,c.sizeAttenuation=!1,null!==o?(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(o,3),3,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGB):null!==a&&(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(a,4),4,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGBA);const h=new t.Mesh(l,c);e.root=h;const u=r.getData("RTC_CENTER");u&&(h.position.x+=u[0],h.position.y+=u[1],h.position.z+=u[2])}}class st extends ye{constructor(e){super(e,[xe,we,rt])}}class nt{static parse(e,t){const i=e.options.buffer,r=e.header.tilesLength,s=[];let n=16;for(let e=0;e<r;e++){const e=new DataView(i,n,12),t=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3)),r=e.getUint32(4,!0),o=e.getUint32(8,!0),a=new Uint8Array(i,n,o);s.push({type:t,buffer:a,version:r}),n+=o}e.tiles=s}}class ot{static parse(e,i){const{tiles:r,options:s,path:n}=e,o=s.adjustmentTransform,a=[];for(const e in r){const{type:t,buffer:l}=r[e],c={fetchOptions:s.fetchOptions,path:n,buffer:l.slice().buffer};"b3dm"!==t&&"i3dm"!==t||(c.adjustmentTransform=o);const h=i._loaders.get(t);h&&a.push(h.load(`${n}/temp.${t}`,c))}return Promise.all(a).then(e=>{const i=new t.Object3D;return e.forEach(e=>{i.add(e.root)}),{tiles:e,root:i}})}}class at extends ye{constructor(e){super(e,[xe,nt,ot]);const t=new Ee(e),i=new it(e),r=new st(e);this._loaders=new Map([["b3dm",t],["i3dm",i],["pnts",r]])}setDRACOLoader(e){for(const t of this._loaders.values())t.setDRACOLoader(e);return super.setDRACOLoader(e)}setKTX2Loader(e){for(const t of this._loaders.values())t.setKTX2Loader(e);return super.setKTX2Loader(e)}}const lt=new t.Matrix4;class ct extends t.Object3D{constructor(e){super(),this.isTilesGroup=!0,this.name="TilesRenderer.TilesGroup",this.tilesRenderer=e,this.worldMatrixInverse=new t.Matrix4}raycast(e,t){return!this.tilesRenderer.optimizeRaycast||(this.tilesRenderer.raycast(e,t),!1)}updateMatrix(e){if((this.matrixAutoUpdate||this.matrixNeedsUpdate)&&(this.matrix.transform(this.position,this.scale,this.quaternion),this.matrixNeedsUpdate=!1,this.worldMatrixNeedsUpdate=!0),(this.worldMatrixNeedsUpdate||e)&&(null===this.parent?lt.copy(this.matrix):lt.multiplyMatrices(this.parent.worldMatrix,this.matrix),this.worldMatrixNeedsUpdate=!1,!ht(lt,this.worldMatrix))){this.worldMatrix.copy(lt),this.worldMatrixInverse.copy(lt).invert();const e=this.children;for(let t=0,i=e.length;t<i;t++)e[t].updateMatrix()}}}const ht=(e,t,i=Number.EPSILON)=>{const r=e.elements,s=t.elements;for(let e=0;e<16;e++)if(Math.abs(r[e]-s[e])>i)return!1;return!0},ut=new t.Ray,dt=new t.Vector3,pt=[];function mt(e,t){return e.distance-t.distance}function ft(e,t,i,r){const{scene:s}=e.cached,n=r.length;if(!i.invokeOnePlugin(i=>i.raycastTile&&i.raycastTile(e,s,t,r))){s.traverse(e=>{Object.getPrototypeOf(e).raycast.call(e,t,r)});const i=r.length;if(i>n)for(let t=n;t<i;t++)r[t].tile=e}}function gt(e){return"__used"in e}function _t(e,t,i,r=null){const{group:s,activeTiles:n}=e;null===r&&(r=ut).copy(i).applyMatrix4(s.worldMatrixInverse);const o=[],a=t.children;for(let e=0,t=a.length;e<t;e++){const t=a[e];if(!gt(t)||!t.__used)continue;null!==t.cached.boundingVolume.intersectRay(r,dt)&&(dt.applyMatrix4(s.worldMatrix),o.push({distance:dt.distanceToSquared(i.origin),tile:t}))}o.sort(mt);let l=null,c=1/0;if(n.has(t)){const r=function(e,t,i){ft(e,t,i,pt),pt.sort(mt);const r=pt[0]||null;return pt.length=0,r}(t,i,e);r&&(l=r,c=r.distance*r.distance)}for(let t=0,s=o.length;t<s;t++){const s=o[t],n=s.distance,a=s.tile;if(n>c)break;const h=_t(e,a,i,r);if(h){const e=h.distance*h.distance;e<c&&(l=h,c=e)}}return l}function bt(e,t,i,r,s=null){if(!gt(t))return;const{group:n,activeTiles:o}=e,{boundingVolume:a}=t.cached;if(null===s&&(s=ut).copy(i).applyMatrix4(n.worldMatrixInverse),!t.__used||!a.intersectsRay(s))return;o.has(t)&&ft(t,i,e,r);const l=t.children;for(let t=0,n=l.length;t<n;t++)bt(e,l[t],i,r,s)}class yt{constructor(e=new t.Box3,i=new t.Matrix3){this.box=e,this.rotation=i}setFromCenterAndAxes(e,t,i,r){vt.copy(t),Mt.copy(i),Tt.copy(r);const s=vt.getLength(),n=Mt.getLength(),o=Tt.getLength();vt.normalize(),Mt.normalize(),Tt.normalize(),0===s&&vt.crossVectors(Mt,Tt),0===n&&Mt.crossVectors(vt,Tt),0===o&&Tt.crossVectors(vt,Mt),this.rotation.set(vt.x,Mt.x,Tt.x,vt.y,Mt.y,Tt.y,vt.z,Mt.z,Tt.z);const a=vt.set(s,n,o);return this.box.min.copy(e).sub(a),this.box.max.copy(e).add(a),this}applyMatrix4(e){const t=e.elements;let i=vt.set(t[0],t[1],t[2]).getLength();const r=vt.set(t[4],t[5],t[6]).getLength(),s=vt.set(t[8],t[9],t[10]).getLength();e.determinant()<0&&(i=-i),At.setFromMatrix4(e);const n=1/i,o=1/r,a=1/s;At.elements[0]*=n,At.elements[1]*=n,At.elements[2]*=n,At.elements[3]*=o,At.elements[4]*=o,At.elements[5]*=o,At.elements[6]*=a,At.elements[7]*=a,At.elements[8]*=a,this.rotation.multiply(At);const l=this.box.getCenter(vt),c=this.box.getSize(Mt).multiplyScalar(.5);return c.x*=i,c.y*=r,c.z*=s,l.applyMatrix4(e),this.box.min.copy(l).sub(c),this.box.max.copy(l).add(c),this}getPoints(e){const t=this.box.getCenter(vt),i=Mt.subVectors(this.box.min,t),r=Tt.subVectors(this.box.max,t);let s=0;for(let n=-1;n<=1;n+=2)for(let o=-1;o<=1;o+=2)for(let a=-1;a<=1;a+=2)e[s].set(n<0?i.x:r.x,o<0?i.y:r.y,a<0?i.z:r.z).applyMatrix3(this.rotation).add(t),s++;return e}getPlanes(e){const t=this.box.getCenter(vt),i=Mt.subVectors(this.box.min,t).applyMatrix3(this.rotation).add(t),r=Tt.subVectors(this.box.max,t).applyMatrix3(this.rotation).add(t);return vt.set(0,0,1).applyMatrix3(this.rotation).normalize(),e[0].setFromNormalAndCoplanarPoint(vt,i),e[1].setFromNormalAndCoplanarPoint(vt,r),e[1].normal.negate(),e[1].constant*=-1,vt.set(0,1,0).applyMatrix3(this.rotation).normalize(),e[2].setFromNormalAndCoplanarPoint(vt,i),e[3].setFromNormalAndCoplanarPoint(vt,r),e[3].normal.negate(),e[3].constant*=-1,vt.set(1,0,0).applyMatrix3(this.rotation).normalize(),e[4].setFromNormalAndCoplanarPoint(vt,i),e[5].setFromNormalAndCoplanarPoint(vt,r),e[5].normal.negate(),e[5].constant*=-1,e}containsPoint(e){const t=Rt(this,Et),i=vt.subVectors(e,t.c);return Math.abs(i.dot(t.u[0]))<=t.e[0]&&Math.abs(i.dot(t.u[1]))<=t.e[1]&&Math.abs(i.dot(t.u[2]))<=t.e[2]}clampPoint(e,t){const i=Rt(this,Et),r=vt.subVectors(e,i.c);t.copy(i.c);const s=Math.max(Math.min(r.dot(i.u[0]),i.e[0]),-i.e[0]);t.add(i.u[0].multiplyScalar(s));const n=Math.max(Math.min(r.dot(i.u[1]),i.e[1]),-i.e[1]);t.add(i.u[1].multiplyScalar(n));const o=Math.max(Math.min(r.dot(i.u[2]),i.e[2]),-i.e[2]);return t.add(i.u[2].multiplyScalar(o)),t}intersectsSphere(e){return this.clampPoint(e.center,xt),xt.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){Rt(this,Et),Rt(e,Lt);for(let e=0;e<3;e++)for(let t=0;t<3;t++)wt[e][t]=Et.u[e].dot(Lt.u[t]);const i=vt.subVectors(Lt.c,Et.c);St[0]=i.dot(Et.u[0]),St[1]=i.dot(Et.u[1]),St[2]=i.dot(Et.u[2]);for(let e=0;e<3;e++)for(let i=0;i<3;i++)Pt[e][i]=Math.abs(wt[e][i])+t;let r,s;for(let e=0;e<3;e++)if(r=Et.e[e],s=Lt.e[0]*Pt[e][0]+Lt.e[1]*Pt[e][1]+Lt.e[2]*Pt[e][2],Math.abs(St[e])>r+s)return!1;for(let e=0;e<3;e++)if(r=Et.e[0]*Pt[0][e]+Et.e[1]*Pt[1][e]+Et.e[2]*Pt[2][e],s=Lt.e[e],Math.abs(St[0]*wt[0][e]+St[1]*wt[1][e]+St[2]*wt[2][e])>r+s)return!1;return r=Et.e[1]*Pt[2][0]+Et.e[2]*Pt[1][0],s=Lt.e[1]*Pt[0][2]+Lt.e[2]*Pt[0][1],!(Math.abs(St[2]*wt[1][0]-St[1]*wt[2][0])>r+s)&&(r=Et.e[1]*Pt[2][1]+Et.e[2]*Pt[1][1],s=Lt.e[0]*Pt[0][2]+Lt.e[2]*Pt[0][0],!(Math.abs(St[2]*wt[1][1]-St[1]*wt[2][1])>r+s)&&(r=Et.e[1]*Pt[2][2]+Et.e[2]*Pt[1][2],s=Lt.e[0]*Pt[0][1]+Lt.e[1]*Pt[0][0],!(Math.abs(St[2]*wt[1][2]-St[1]*wt[2][2])>r+s)&&(r=Et.e[0]*Pt[2][0]+Et.e[2]*Pt[0][0],s=Lt.e[1]*Pt[1][2]+Lt.e[2]*Pt[1][1],!(Math.abs(St[0]*wt[2][0]-St[2]*wt[0][0])>r+s)&&(r=Et.e[0]*Pt[2][1]+Et.e[2]*Pt[0][1],s=Lt.e[0]*Pt[1][2]+Lt.e[2]*Pt[1][0],!(Math.abs(St[0]*wt[2][1]-St[2]*wt[0][1])>r+s)&&(r=Et.e[0]*Pt[2][2]+Et.e[2]*Pt[0][2],s=Lt.e[0]*Pt[1][1]+Lt.e[1]*Pt[1][0],!(Math.abs(St[0]*wt[2][2]-St[2]*wt[0][2])>r+s)&&(r=Et.e[0]*Pt[1][0]+Et.e[1]*Pt[0][0],s=Lt.e[1]*Pt[2][2]+Lt.e[2]*Pt[2][1],!(Math.abs(St[1]*wt[0][0]-St[0]*wt[1][0])>r+s)&&(r=Et.e[0]*Pt[1][1]+Et.e[1]*Pt[0][1],s=Lt.e[0]*Pt[2][2]+Lt.e[2]*Pt[2][0],!(Math.abs(St[1]*wt[0][1]-St[0]*wt[1][1])>r+s)&&(r=Et.e[0]*Pt[1][2]+Et.e[1]*Pt[0][2],s=Lt.e[0]*Pt[2][1]+Lt.e[1]*Pt[2][0],!(Math.abs(St[1]*wt[0][2]-St[0]*wt[1][2])>r+s)))))))))}toBoundingBoxWithTransform(e,t){const i=this.box.getCenter(vt);e.min.copy(this.box.min).sub(i),e.max.copy(this.box.max).sub(i);const r=this.rotation.elements;t.set(r[0],r[3],r[6],i.x,r[1],r[4],r[7],i.y,r[2],r[5],r[8],i.z,0,0,0,1)}}const xt=new t.Vector3,vt=new t.Vector3,Mt=new t.Vector3,Tt=new t.Vector3,At=new t.Matrix3,wt=[[],[],[]],Pt=[[],[],[]],St=[],Ct=new t.Vector3,Et={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]},Lt={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]};function Rt(e,t){e.box.getCenter(t.c);const i=e.rotation.elements;return t.u[0].fromArray(i,0),t.u[1].fromArray(i,3),t.u[2].fromArray(i,6),e.box.getSize(Ct).multiplyScalar(.5).toArray(t.e),t}class It extends yt{constructor(){super(),this._points=new Array(8).fill().map(()=>new t.Vector3),this._planes=new Array(6).fill().map(()=>new t.Plane),this._originBox=new t.Box3,this._originBoxTransform=new t.Matrix4,this._originBoxTransformInverse=new t.Matrix4}updateCache(){this.getPoints(this._points),this.getPlanes(this._planes),this.toBoundingBoxWithTransform(this._originBox,this._originBoxTransform),this._originBoxTransformInverse.copy(this._originBoxTransform).invert()}containsPoint(e){return Dt.copy(e).applyMatrix4(this._originBoxTransformInverse),this.box.containsPoint(Dt)}intersectsRay(e){return Ut.copy(e).applyMatrix4(this._originBoxTransformInverse),Ut.intersectsBox(this._originBox)}intersectRay(e,t){return Ut.copy(e).applyMatrix4(this._originBoxTransformInverse),Ut.intersectBox(this._originBox,t)?t.applyMatrix4(this._originBoxTransform):null}intersectsFrustum(e){for(let t=0;t<6;t++){const i=e.planes[t];let r=-1/0;for(let e=0;e<8;e++){const t=this._points[e],s=i.distanceToPoint(t);r=r<s?s:r}if(r<0)return!1}for(let t=0;t<6;t++){const i=this._planes[t];let r=-1/0;for(let t=0;t<8;t++){const s=e.points[t],n=i.distanceToPoint(s);r=r<n?n:r}if(r<0)return!1}return!0}distanceToPoint(e){return Dt.copy(e).applyMatrix4(this._originBoxTransformInverse),this._originBox.distanceToPoint(Dt)}getBoundingSphere(e){return this.box.getBoundingSphere(e)}getBoundingBox(e){return e.setFromPoints(this._points)}}const Ut=new t.Ray,Dt=new t.Vector3;class Bt{constructor(e=new t.Vector3(1,1,1)){this.name="",this.radius=e}intersectRay(e,t){return Nt.makeScale(...this.radius.toArray([])).invert(),Gt.center.set(0,0,0),Gt.radius=1,$t.copy(e).applyMatrix4(Nt),$t.intersectSphere(Gt,t)?(Nt.makeScale(...this.radius.toArray([])),t.applyMatrix4(Nt),t):null}getEastNorthUpFrame(e,t,i){return this.getEastNorthUpAxes(e,t,jt,Xt,Kt,qt),i.makeBasis(jt,Xt,Kt).setPosition(qt)}getEastNorthUpAxes(e,t,i,r,s,n=qt){this.getCartographicToPosition(e,t,0,n),this.getCartographicToNormal(e,t,s),i.set(-n.y,n.x,0).normalize(),r.crossVectors(s,i).normalize()}getRotationMatrixFromAzElRoll(e,t,i,r,s,n,o=Qt){return this.getEastNorthUpFrame(e,t,Nt),Ht.set(r,s,-i,"ZXY"),n.makeRotationFromEuler(Ht).premultiply(Nt).setPosition(0,0,0),o===Zt?(Ht.set(Math.PI/2,0,0,"XYZ"),zt.makeRotationFromEuler(Ht),n.multiply(zt)):o===Jt&&(Ht.set(-Math.PI/2,0,Math.PI,"XYZ"),zt.makeRotationFromEuler(Ht),n.multiply(zt)),n}getCartographicToPosition(e,t,i,r){this.getCartographicToNormal(e,t,Vt);const s=this.radius;Ft.copy(Vt),Ft.x*=s.x**2,Ft.y*=s.y**2,Ft.z*=s.z**2;const n=Math.sqrt(Vt.dot(Ft));return Ft.multiplyScalar(1/n),r.copy(Ft).addScaledVector(Vt,i)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,Ft),this.getPositionToNormal(e,Vt);const i=kt.subVectors(e,Ft);return t.lon=Math.atan2(Vt.y,Vt.x),t.lat=Math.asin(Vt.z),t.height=Math.sign(i.dot(e))*i.getLength(),t}getCartographicToNormal(e,t,i){return Ot.set(1,-e+Math.PI/2,t),i.setFromSpherical(Ot).normalize(),function(e){const{x:t,y:i,z:r}=e;e.x=r,e.y=t,e.z=i}(i),i}getPositionToNormal(e,t){const i=this.radius;return t.copy(e),t.x/=i.x**2,t.y/=i.y**2,t.z/=i.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const i=this.radius,r=1/i.x**2,s=1/i.y**2,n=1/i.z**2,o=e.x*e.x*r,a=e.y*e.y*s,l=e.z*e.z*n,c=o+a+l,h=Math.sqrt(1/c),u=Ft.copy(e).multiplyScalar(h);if(c<Wt)return isFinite(h)?t.copy(u):null;const d=kt.set(u.x*r*2,u.y*s*2,u.z*n*2);let p,m,f,g,_,b,y,x,v,M,T,A=(1-h)*e.getLength()/(.5*d.getLength()),w=0;do{A-=w,f=1/(1+A*r),g=1/(1+A*s),_=1/(1+A*n),b=f*f,y=g*g,x=_*_,v=b*f,M=y*g,T=x*_,p=o*b+a*y+l*x-1,m=o*v*r+a*M*s+l*T*n;w=p/(-2*m)}while(Math.abs(p)>Yt);return t.set(e.x*f,e.y*g,e.z*_)}calculateHorizonDistance(e,t){const i=this.calculateEffectiveRadius(e);return Math.sqrt(2*i*t+t**2)}calculateEffectiveRadius(e){const i=this.radius.x,r=1-this.radius.z**2/i**2,s=e*t.MathUtils.DEG2RAD,n=Math.sin(s)**2;return i/Math.sqrt(1-r*n)}getPositionElevation(e){this.getPositionToSurfacePoint(e,Ft);const t=kt.subVectors(e,Ft);return Math.sign(t.dot(e))*t.getLength()}copy(e){return this.radius.copy(e.radius),this}clone(){return(new this.constructor).copy(this)}}const Ot=new t.Spherical,Vt=new t.Vector3,Ft=new t.Vector3,kt=new t.Vector3,Nt=new t.Matrix4,zt=new t.Matrix4,Gt=new t.Sphere,Ht=new t.Euler,jt=new t.Vector3,Xt=new t.Vector3,Kt=new t.Vector3,qt=new t.Vector3,$t=new t.Ray,Yt=1e-12,Wt=.1,Qt=0,Zt=1,Jt=2;class ei extends Bt{constructor(e=new t.Vector3(1,1,1),i=new t.Vector2(-ai,ai),r=new t.Vector2(0,2*oi),s=new t.Vector2(0,1)){super(e),this.latRange=i,this.lonRange=r,this.heightRange=s}getOrientedBoundingBox(e){ui();const{latRange:i,lonRange:r}=this;if(i.y-i.x<oi/2){const e=t.MathUtils.mapLinear(.5,0,1,i.x,i.y),s=t.MathUtils.mapLinear(.5,0,1,r.x,r.y);this.getCartographicToNormal(e,s,ri),ii.set(0,0,1),ti.crossVectors(ii,ri),ii.crossVectors(ti,ri)}else ti.set(1,0,0),ii.set(0,1,0),ri.set(0,0,1);e.rotation.set(ti.x,ii.x,ri.x,ti.y,ii.y,ri.y,ti.z,ii.z,ri.z),ni.setFromMatrix3(e.rotation).invert();const s=this._getPoints(!0);e.box.makeEmpty();for(let t=0,i=s.length;t<i;t++)si.copy(s[t]).applyMatrix4(ni),e.box.expandByPoint(si);e.box.getCenter(si),si.applyMatrix3(e.rotation);for(let e=0,t=s.length;e<t;e++)s[e].sub(si).applyMatrix4(ni).add(si);e.box.makeEmpty(),e.box.setFromPoints(s)}getBoundingSphere(e){ui();const t=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(t)}_getPoints(e=!1){const{latRange:i,lonRange:r,heightRange:s}=this,n=t.MathUtils.mapLinear(.5,0,1,i.x,i.y),o=t.MathUtils.mapLinear(.5,0,1,r.x,r.y),a=Math.floor(r.x/ai)*ai,l=[[-oi/2,0],[oi/2,0],[0,a],[0,a+oi/2],[0,a+oi],[0,a+3*oi/2],[i.x,r.y],[i.y,r.y],[i.x,r.x],[i.y,r.x],[0,r.x],[0,r.y],[n,o],[i.x,o],[i.y,o],[n,r.x],[n,r.y]],c=[],h=l.length;for(let n=0;n<=1;n++){const o=t.MathUtils.mapLinear(n,0,1,s.x,s.y);for(let t=0,s=h;t<s;t++){const[s,n]=l[t];if(s>=i.x&&s<=i.y&&n>=r.x&&n<=r.y){const t=hi(e);c.push(t),this.getCartographicToPosition(s,n,o,t)}}}return c}}const ti=new t.Vector3,ii=new t.Vector3,ri=new t.Vector3,si=new t.Vector3,ni=new t.Matrix4,oi=Math.PI,ai=oi/2;let li=0;const ci=[];function hi(e=!1){return e?(ci[li]||(ci[li]=new t.Vector3),li++,ci[li-1]):new t.Vector3}function ui(){li=0}class di{constructor(){this.sphere=null,this.obb=null,this.region=null}setOBBData(e,t){const i=new It;i.setFromCenterAndAxes(gi.set(e[0],e[1],e[2]),pi.set(e[3],e[4],e[5]),mi.set(e[6],e[7],e[8]),fi.set(e[9],e[10],e[11])).applyMatrix4(t),i.updateCache(),this.obb=i}setSphereData(e,i){const r=new t.Sphere;r.center.set(e[0],e[1],e[2]),r.radius=e[3],r.applyMatrix4(i),this.sphere=r}setRegionData(e,i,r,s,n,o,a){const l=new ei(e.radius.clone(),new t.Vector2(r,n),new t.Vector2(i,s),new t.Vector2(o,a));this.region=l;const c=new It;l.getOrientedBoundingBox(c),c.updateCache(),this.obb=c}intersectsRay(e){const t=this.sphere,i=this.obb;return!(t&&!e.intersectsSphere(t))&&!(i&&!i.intersectsRay(e))}intersectRay(e,t){const i=this.sphere,r=this.obb;let s=-1/0,n=-1/0;i&&e.intersectSphere(i,pi)&&(s=i.containsPoint(e.origin)?0:e.origin.distanceToSquared(pi)),r&&r.intersectRay(e,pi)&&(n=r.containsPoint(e.origin)?0:e.origin.distanceToSquared(pi));const o=Math.max(s,n);return o===-1/0?null:e.at(Math.sqrt(o),t)}distanceToPoint(e){const t=this.sphere,i=this.obb;let r=-1/0,s=-1/0;return t&&(r=Math.max(t.distanceToPoint(e),0)),i&&(s=i.distanceToPoint(e)),r>s?r:s}intersectsFrustum(e){const t=this.sphere;if(t&&!e.intersectsSphere(t))return!1;const i=this.obb;return!(i&&!i.intersectsFrustum(e))&&Boolean(t||i)}getOrientedBoundingBox(e,t){this.obb?(e.copy(this.obb._originBox),t.copy(this.obb._originBoxTransform)):(this.getBoundingBox(e),t.identity())}getBoundingBox(e){return this.sphere?this.sphere.getBoundingBox(e):this.obb.getBoundingBox(e)}getBoundingSphere(e){return this.sphere?e.copy(this.sphere):this.obb.getBoundingSphere(e)}}const pi=new t.Vector3,mi=new t.Vector3,fi=new t.Vector3,gi=new t.Vector3;class _i extends t.Frustum{constructor(){super(),this.points=new Array(8).fill().map(()=>new t.Vector3)}updateCache(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach((e,i)=>{!function(e,t,i,r){const s=bi.set(e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z,i.normal.x,i.normal.y,i.normal.z);r.set(-e.constant,-t.constant,-i.constant),r.applyMatrix3(s.invert())}(e[0],e[1],e[2],t[i])})}}const bi=new t.Matrix3;const yi=new t.Matrix4,xi=new t.Vector3;class vi{constructor(){this._cameras=[],this._resolution=new t.Vector2,this._infos=[]}add(e){const t=this._cameras;return-1===t.indexOf(e)&&(t.push(e),!0)}remove(e){const t=this._cameras,i=t.indexOf(e);return-1!==i&&(t.splice(i,1),!0)}setResolution(e,t){this._resolution.set(e,t)}updateInfos(e){const i=this._cameras,r=this._infos,s=this._resolution;for(;r.length>i.length;)r.pop();for(;r.length<i.length;)r.push({frustum:new _i,isOrthographic:!1,sseDenominator:-1,position:new t.Vector3,invScale:-1,pixelSize:0});xi.setFromMatrixScale(e.worldMatrixInverse),Math.abs(Math.max(xi.x-xi.y,xi.x-xi.z))>1e-6&&console.warn("TilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error.");for(let t=0,n=r.length;t<n;t++){const n=i[t],o=r[t],a=o.frustum,l=o.position,c=s.x*(n.rect.z-n.rect.x),h=s.y*(n.rect.w-n.rect.y);0!==c&&0!==h||console.warn("CameraList.updateInfos(): Resolution for camera error calculation is not set.");const u=n.projectionMatrix.elements;if(o.isOrthographic=1===u[15],o.isOrthographic){const e=2/u[0],t=2/u[5];o.pixelSize=Math.max(t/h,e/c)}else o.sseDenominator=2/u[5]/h;yi.copy(e.worldMatrix).premultiply(n.projectionViewMatrix),a.setFromMatrix(yi),a.updateCache(),l.setFromMatrixPosition(n.worldMatrix).applyMatrix4(e.worldMatrixInverse)}}getInfos(){return this._infos}}const Mi=new Bt(new t.Vector3(m,m,6356752.314245179));Mi.name="WGS84 Earth";class Ti{static parse(e,t){const{url:i,options:r}=e,s=r.buffer;if(Ai(i)){const t=D.parseGLB(s);e.gltf=t.gltf,e.buffers=t.buffers}else e.gltf=s}}const Ai=e=>"glb"===h(e);class wi extends ye{constructor(e){super(e),this.replaceParser(Ti,0)}}const Pi=Symbol("INITIAL_FRUSTUM_CULLED"),Si={inView:!1,error:1/0},Ci=new t.Vector3(1,0,0),Ei=new t.Vector3(0,1,0);function Li(e,t){e.traverse(e=>{e.frustumCulled=e[Pi]&&t})}const Ri={type:"update-before"},Ii={type:"update-after"};class Ui extends t.Mesh{constructor(){super(new t.PlaneGeometry(0,0),new Di),this.renderOrder=1/0}}class Di extends t.ShaderMaterial{constructor(){super(Bi),this.depthWrite=!1,this.depthTest=!1,this.transparent=!0}}const Bi={name:"PivotPoint",uniforms:{size:15,thickness:2,opacity:1},vertexShader:"\n\t\tattribute vec3 a_Position; \n\t\tattribute vec2 a_Uv;\n\n\t\tuniform mat4 u_ProjectionView;\n\t\tuniform mat4 u_Model;\n\n\t\tuniform float pixelRatio;\n\t\tuniform float size;\n\t\tuniform float thickness;\n\t\tuniform vec2 u_RenderTargetSize;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tvoid main() {\n\t\t\tv_Uv = a_Uv;\n\n\t\t\tfloat aspect = u_RenderTargetSize.x / u_RenderTargetSize.y;\n\t\t\tvec2 offset = a_Uv * 2.0 - vec2(1.0);\n\t\t\toffset.y *= aspect;\n\n\t\t\tvec4 screenPoint = u_ProjectionView * u_Model * vec4(a_Position, 1.0);\n\t\t\tscreenPoint.xy += offset * (size + thickness) * screenPoint.w / u_RenderTargetSize.x;\n\n\t\t\tgl_Position = screenPoint;\n\t\t}\n\t",fragmentShader:"\n\t\tuniform float size;\n\t\tuniform float thickness;\n\t\tuniform float opacity;\n\n\t\tvarying vec2 v_Uv;\n\n\t\tvoid main() {\n\t\t\tfloat ht = 0.5 * thickness;\n\t\t\tfloat planeDim = size + thickness;\n\t\t\tfloat offset = (planeDim - ht - 2.0) / planeDim;\n\t\t\tfloat texelThickness = ht / planeDim;\n\n\t\t\tvec2 vec = v_Uv * 2.0 - vec2(1.0);\n\t\t\tfloat dist = abs(length(vec) - offset);\n\t\t\tfloat fw = fwidth(dist) * 0.5;\n\t\t\tfloat a = smoothstep(texelThickness - fw, texelThickness + fw, dist);\n\n\t\t\tgl_FragColor = vec4(1, 1, 1, opacity * (1.0 - a));\n\t\t}\n\t"},Oi=new t.Vector2,Vi=new t.Vector2;class Fi{constructor(){this.domElement=null,this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new t.Vector2,this.hoverSet=!1}reset(){this.buttons=0,this.pointerType=null,this.pointerOrder=[],this.previousPositions={},this.pointerPositions={},this.startPositions={},this.pointerSetThisFrame={},this.hoverPosition=new t.Vector2,this.hoverSet=!1}updateFrame(){const{previousPositions:e,pointerPositions:t}=this;for(const i in t)e[i].copy(t[i])}setHoverEvent(e){"mouse"!==e.pointerType&&"wheel"!==e.type||(this.getAdjustedPointer(e,this.hoverPosition),this.hoverSet=!0)}getLatestPoint(e){return null!==this.pointerType?(this.getCenterPoint(e),e):this.hoverSet?(e.copy(this.hoverPosition),e):null}getAdjustedPointer(e,t){const i=(this.domElement?this.domElement:e.target).getBoundingClientRect(),r=e.clientX-i.left,s=e.clientY-i.top;t.set(r,s)}addPointer(e){const i=e.pointerId,r=new t.Vector2;this.getAdjustedPointer(e,r),this.pointerOrder.push(i),this.pointerPositions[i]=r,this.previousPositions[i]=r.clone(),this.startPositions[i]=r.clone(),1===this.getPointerCount()&&(this.pointerType=e.pointerType,this.buttons=e.buttons)}updatePointer(e){const t=e.pointerId;return t in this.pointerPositions&&(this.getAdjustedPointer(e,this.pointerPositions[t]),!0)}deletePointer(e){const t=e.pointerId,i=this.pointerOrder;i.splice(i.indexOf(t),1),delete this.pointerPositions[t],delete this.previousPositions[t],delete this.startPositions[t],0===this.getPointerCount()&&(this.buttons=0,this.pointerType=null)}getPointerCount(){return this.pointerOrder.length}getCenterPoint(e,t=this.pointerPositions){const i=this.pointerOrder;if(1===this.getPointerCount()||"mouse"===this.getPointerType()){const r=i[0];return e.copy(t[r]),e}if(2===this.getPointerCount()){const i=this.pointerOrder[0],r=this.pointerOrder[1],s=t[i],n=t[r];return e.addVectors(s,n).multiplyScalar(.5),e}return null}getPreviousCenterPoint(e){return this.getCenterPoint(e,this.previousPositions)}getStartCenterPoint(e){return this.getCenterPoint(e,this.startPositions)}getMoveDistance(){return this.getCenterPoint(Oi),this.getPreviousCenterPoint(Vi),Oi.sub(Vi).getLength()}getTouchPointerDistance(e=this.pointerPositions){if(this.getPointerCount()<=1||"mouse"===this.getPointerType())return 0;const{pointerOrder:t}=this,i=t[0],r=t[1],s=e[i],n=e[r];return s.distanceTo(n)}getPreviousTouchPointerDistance(){return this.getTouchPointerDistance(this.previousPositions)}getStartTouchPointerDistance(){return this.getTouchPointerDistance(this.startPositions)}getPointerType(){return this.pointerType}isPointerTouch(){return"touch"===this.getPointerType()}getPointerButtons(){return this.buttons}isLeftClicked(){return Boolean(1&this.buttons)}isRightClicked(){return Boolean(2&this.buttons)}}const ki=new t.Matrix4,Ni=new t.Ray,zi=new t.Vector3;function Gi(e,t,i){return i.makeTranslation(-e.x,-e.y,-e.z),ki.makeRotationFromQuaternion(t),i.premultiply(ki),ki.makeTranslation(e.x,e.y,e.z),i.premultiply(ki),i}function Hi(e,t,i,r){r.x=(e-i.offsetLeft)/i.clientWidth*2-1,r.y=-(t-i.offsetTop)/i.clientHeight*2+1,r.isVector3&&(r.z=0)}function ji(e,t,i){return t.intersectRay(e,i)?i:(ki.makeScale(...t.radius).invert(),Ni.copy(e).applyMatrix4(ki),zi.set(0,0,0),Ni.closestPointToPoint(zi,i).normalize(),ki.makeScale(...t.radius),i.applyMatrix4(ki))}function Xi(e,i,r){const s=e instanceof t.Ray?e:e.ray,{origin:n,direction:o}=s;n.set(i.x,i.y,-1).unproject(r),o.set(i.x,i.y,1).unproject(r).sub(n),o.normalize()}const Ki=.05,qi=.025,$i=new t.Matrix4,Yi=new t.Matrix4,Wi=new t.Vector3,Qi=new t.Vector3,Zi=new t.Vector3,Ji=new t.Vector3,er=new t.Vector3,tr=new t.Vector3,ir=new t.Vector3,rr=new t.Vector3,sr=new t.Quaternion,nr=new t.Plane,or=new t.Vector3,ar=new t.Vector3,lr=new t.Vector3,cr=new t.Quaternion,hr=new t.Ray,ur=new t.Vector2,dr=new t.Vector2,pr=new t.Vector2,mr=new t.Vector2,fr=new t.Vector2,gr=new t.Vector2,_r={type:"change"},br={type:"start"},yr={type:"end"};class xr extends t.EventDispatcher{get enabled(){return this._enabled}set enabled(e){e!==this.enabled&&(this._enabled=e,this.resetState(),this.pointerTracker.reset(),this.enabled||(this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0)))}constructor(e=null,i=null,r=null,s=null){super(),this.isEnvironmentControls=!0,this.domElement=null,this.camera=null,this.scene=null,this.tilesRenderer=null,this._enabled=!0,this.cameraRadius=5,this.rotationSpeed=1,this.minAltitude=0,this.maxAltitude=.45*Math.PI,this.minDistance=10,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.zoomSpeed=1,this.adjustHeight=!0,this.enableDamping=!1,this.dampingFactor=.15,this.fallbackPlane=new t.Plane(new t.Vector3(0,1,0),0),this.useFallbackPlane=!0,this.scaleZoomOrientationAtEdges=!1,this.autoAdjustCameraRotation=!0,this.state=0,this.pointerTracker=new Fi,this.needsUpdate=!1,this.actionHeightOffset=0,this.pivotPoint=new t.Vector3,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.zoomDirection=new t.Vector3,this.zoomPoint=new t.Vector3,this.zoomDelta=0,this.rotationInertiaPivot=new t.Vector3,this.rotationInertia=new t.Vector2,this.dragInertia=new t.Vector3,this.inertiaTargetDistance=1/0,this.inertiaStableFrames=0,this.pivotMesh=new Ui,this.pivotMesh.raycast=()=>{},this.pivotMesh.scale.setScalar(.25),this.raycaster=new t.Raycaster,this.up=new t.Vector3(0,1,0),this._detachCallback=null,this._upInitialized=!1,this._lastUsedState=0,this._zoomPointWasSet=!1,this._tilesOnChangeCallback=()=>this.zoomPointSet=!1,r&&this.attach(r),i&&this.setCamera(i),e&&this.setScene(e),s&&this.setTilesRenderer(s)}setScene(e){this.scene=e}setCamera(e){this.camera=e,this._upInitialized=!1,this.zoomDirectionSet=!1,this.zoomPointSet=!1,this.needsUpdate=!0,this.raycaster.camera=e,this.resetState()}setTilesRenderer(e){console.warn('EnvironmentControls: "setTilesRenderer" has been deprecated. Use "setScene" and "setEllipsoid", instead.'),this.tilesRenderer=e,null!==this.tilesRenderer&&this.setScene(this.tilesRenderer.group)}attach(e){if(this.domElement)throw new Error("EnvironmentControls: Controls already attached to element");this.domElement=e,this.pointerTracker.domElement=e,e.style.touchAction="none";const t=e=>{this.enabled&&e.preventDefault()},i=e=>{if(!this.enabled)return;e.preventDefault();const{camera:t,raycaster:i,domElement:r,up:s,pivotMesh:n,pointerTracker:o,scene:a,pivotPoint:l,enabled:c}=this;if(o.addPointer(e),this.needsUpdate=!0,o.isPointerTouch())if(n.visible=!1,0===o.getPointerCount())r.setPointerCapture(e.pointerId);else if(o.getPointerCount()>2)return void this.resetState();o.getCenterPoint(dr),Hi(dr.x,dr.y,r,dr),Xi(i,dr,t);const h=Math.abs(i.ray.direction.dot(s));if(h<Ki||h<qi)return;const u=this._raycast(i);u&&(2===o.getPointerCount()||o.isRightClicked()||o.isLeftClicked()&&e.shiftKey?(this.setState(o.isPointerTouch()?4:2),l.copy(u.point),n.position.copy(u.point),n.visible=!o.isPointerTouch()&&c,n.updateMatrix(),a.add(n)):o.isLeftClicked()&&(this.setState(1),l.copy(u.point),n.position.copy(u.point),n.updateMatrix(),a.add(n)))};let r=!1;const s=e=>{const{pointerTracker:t}=this;if(!this.enabled||0===t.getPointerCount())return;e.preventDefault();const{pivotMesh:i,enabled:s}=this;this.zoomDirectionSet=!1,this.zoomPointSet=!1,0!==this.state&&(this.needsUpdate=!0),t.setHoverEvent(e),t.updatePointer(e)&&(t.isPointerTouch()&&2===t.getPointerCount()&&(r||(r=!0,queueMicrotask(()=>{r=!1,t.getCenterPoint(fr);const e=t.getStartTouchPointerDistance(),n=t.getTouchPointerDistance(),o=n-e;if(0===this.state||4===this.state){t.getCenterPoint(fr),t.getStartCenterPoint(gr);const e=2*window.devicePixelRatio,i=fr.distanceTo(gr);(Math.abs(o)>e||i>e)&&(Math.abs(o)>i?(this.setState(3),this.zoomDirectionSet=!1):this.setState(2))}if(3===this.state){const e=t.getPreviousTouchPointerDistance();this.zoomDelta+=n-e,i.visible=!1}else 2===this.state&&(i.visible=s)}))),this.dispatchEvent(_r))},n=t=>{const{pointerTracker:i}=this;this.enabled&&0!==i.getPointerCount()&&(i.deletePointer(t),"touch"===i.getPointerType()&&0===i.getPointerCount()&&e.releasePointerCapture(t.pointerId),this.resetState(),this.needsUpdate=!0)},o=e=>{if(!this.enabled)return;e.preventDefault();const{pointerTracker:t}=this;let i;switch(t.setHoverEvent(e),t.updatePointer(e),this.dispatchEvent(br),e.deltaMode){case 2:i=800*e.deltaY;break;case 1:i=40*e.deltaY;break;case 0:i=e.deltaY}const r=Math.sign(i),s=Math.abs(i);this.zoomDelta-=.25*r*s,this.needsUpdate=!0,this._lastUsedState=3,this.dispatchEvent(yr)},a=e=>{const{pointerTracker:t}=this;this.enabled&&0!==t.getPointerCount()&&this.resetState()};e.addEventListener("contextmenu",t),e.addEventListener("pointerdown",i),e.addEventListener("wheel",o,{passive:!1});const l=e.getRootNode();l.addEventListener("pointermove",s),l.addEventListener("pointerup",n),l.addEventListener("pointerleave",a),this._detachCallback=()=>{e.removeEventListener("contextmenu",t),e.removeEventListener("pointerdown",i),e.removeEventListener("wheel",o),l.removeEventListener("pointermove",s),l.removeEventListener("pointerup",n),l.removeEventListener("pointerleave",a)}}detach(){this.domElement=null,this._detachCallback&&(this._detachCallback(),this._detachCallback=null,this.pointerTracker.reset())}getUpDirection(e,t){t.copy(this.up)}getCameraUpDirection(e){this.getUpDirection(this.camera.position,e)}getPivotPoint(e){let t=null;3===this._lastUsedState?this._zoomPointWasSet&&(t=e.copy(this.zoomPoint)):2!==this._lastUsedState&&1!==this._lastUsedState||(t=e.copy(this.pivotPoint));const{camera:i,raycaster:r}=this;null!==t&&(Qi.copy(t).project(i),(Qi.x<-1||Qi.x>1||Qi.y<-1||Qi.y>1)&&(t=null)),Xi(r,{x:0,y:0},i);const s=this._raycast(r);return s&&(null===t||s.distance<t.distanceTo(r.ray.origin))&&(t=e.copy(s.point)),t}resetState(){0!==this.state&&this.dispatchEvent(yr),this.state=0,this.pivotMesh.removeFromParent(),this.pivotMesh.visible=this.enabled,this.actionHeightOffset=0,this.pointerTracker.reset()}setState(e=this.state,t=!0){this.state!==e&&(0===this.state&&t&&this.dispatchEvent(br),this.pivotMesh.visible=this.enabled,this.dragInertia.set(0,0,0),this.rotationInertia.set(0,0),this.inertiaStableFrames=0,this.state=e,0!==e&&4!==e&&(this._lastUsedState=e))}update(e=.064){if(!this.enabled||!this.camera||0===e)return;const{camera:t,cameraRadius:i,pivotPoint:r,up:s,state:n,adjustHeight:o,autoAdjustCameraRotation:a}=this;t.updateMatrix(),this.getCameraUpDirection(or),this._upInitialized||(this._upInitialized=!0,this.up.copy(or)),this.zoomPointSet=!1;const l=this._inertiaNeedsUpdate(),c=this.needsUpdate||l;if(this.needsUpdate||l){const i=this.zoomDelta;this._updateZoom(),this._updatePosition(e),this._updateRotation(e),1===n||2===n?(er.set(0,0,-1).transformDirection(t.worldMatrix),this.inertiaTargetDistance=Qi.copy(this.pivotPoint).sub(t.position).dot(er)):0===n&&this._updateInertia(e),(0!==n||0!==i||l)&&this.dispatchEvent(_r),this.needsUpdate=!1}const h=t.isOrthographicCamera?null:o&&this._getPointBelowCamera()||null;if(this.getCameraUpDirection(or),this._setFrame(or),(1===this.state||2===this.state)&&0!==this.actionHeightOffset){const{actionHeightOffset:e}=this;t.position.addScaledVector(s,-e),r.addScaledVector(s,-e),h&&(h.distance-=e)}if(this.actionHeightOffset=0,h){const e=h.distance;if(e<i){const n=i-e;t.position.addScaledVector(s,n),r.addScaledVector(s,n),this.actionHeightOffset=n}}this.pointerTracker.updateFrame(),c&&a&&(this.getCameraUpDirection(or),this._alignCameraUp(or,1),this.getCameraUpDirection(or),this._clampRotation(or))}adjustCamera(e){const{adjustHeight:t,cameraRadius:i}=this;if(e.isPerspectiveCamera){this.getUpDirection(e.position,or);const r=t&&this._getPointBelowCamera(e.position,or)||null;if(r){const t=r.distance;t<i&&e.position.addScaledVector(or,i-t)}}}dispose(){this.detach()}_updateInertia(e){const{rotationInertia:t,pivotPoint:i,dragInertia:r,enableDamping:s,dampingFactor:n,camera:o,cameraRadius:a,minDistance:l,inertiaTargetDistance:c}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return r.set(0,0,0),void t.set(0,0,0);const h=Math.pow(2,-e/n),u=Math.max(o.near,a,l,c),d=25e-5;if(t.getLengthSquared()>0){Xi(hr,Qi.set(0,0,-1),o),hr.applyMatrix4(o.viewMatrix),hr.direction.normalize(),hr.recast(-hr.direction.dot(hr.origin)).at(u/hr.direction.z,Qi),Qi.applyMatrix4(o.worldMatrix),Xi(hr,Wi.set(d,d,-1),o),hr.applyMatrix4(o.viewMatrix),hr.direction.normalize(),hr.recast(-hr.direction.dot(hr.origin)).at(u/hr.direction.z,Wi),Wi.applyMatrix4(o.worldMatrix),Qi.sub(i).normalize(),Wi.sub(i).normalize();const r=Qi.angleTo(Wi)/e;t.multiplyScalar(h),(t.getLengthSquared()<r**2||!s)&&t.set(0,0)}if(r.getLengthSquared()>0){Xi(hr,Qi.set(0,0,-1),o),hr.applyMatrix4(o.viewMatrix),hr.direction.normalize(),hr.recast(-hr.direction.dot(hr.origin)).at(u/hr.direction.z,Qi),Qi.applyMatrix4(o.worldMatrix),Xi(hr,Wi.set(d,d,-1),o),hr.applyMatrix4(o.viewMatrix),hr.direction.normalize(),hr.recast(-hr.direction.dot(hr.origin)).at(u/hr.direction.z,Wi),Wi.applyMatrix4(o.worldMatrix);const t=Qi.distanceTo(Wi)/e;r.multiplyScalar(h),(r.getLengthSquared()<t**2||!s)&&r.set(0,0,0)}t.getLengthSquared()>0&&this._applyRotation(t.x*e,t.y*e,i),r.getLengthSquared()>0&&(o.position.addScaledVector(r,e),o.updateMatrix())}_inertiaNeedsUpdate(){const{rotationInertia:e,dragInertia:t}=this;return 0!==e.getLengthSquared()||0!==t.getLengthSquared()}_updateZoom(){const{zoomPoint:e,zoomDirection:t,camera:i,minDistance:r,maxDistance:s,pointerTracker:n,domElement:o,minZoom:a,maxZoom:l,zoomSpeed:c,state:h}=this;let u=this.zoomDelta;if(this.zoomDelta=0,n.getLatestPoint(dr)&&(0!==u||3===h))if(this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),i.isOrthographicCamera){this._updateZoomDirection();const e=this.zoomPointSet||this._updateZoomPoint();ar.unproject(i);const t=Math.pow(.95,Math.abs(.05*u));let r=u>0?1/Math.abs(t):t;r*=c,r>1?l<i.zoom*r&&(r=1):a>i.zoom*r&&(r=1),i.zoom*=r,i.updateProjectionMatrix(),e&&(Hi(dr.x,dr.y,o,lr),lr.unproject(i),i.position.sub(lr).add(ar),i.updateMatrix())}else{this._updateZoomDirection();const n=Qi.copy(t);if(this.zoomPointSet||this._updateZoomPoint()){const n=e.distanceTo(i.position);if(u<0){const e=Math.min(0,n-s);u=u*n*c*.0025,u=Math.max(u,e)}else{const e=Math.max(0,n-r);u=u*Math.max(n-r,0)*c*.0025,u=Math.min(u,e)}i.position.addScaledVector(t,u),i.updateMatrix()}else{const e=this._getPointBelowCamera();if(e){const t=e.distance;n.set(0,0,-1).transformDirection(i.worldMatrix),i.position.addScaledVector(n,u*t*.01),i.updateMatrix()}}}}_updateZoomDirection(){if(this.zoomDirectionSet)return;const{domElement:e,raycaster:t,camera:i,zoomDirection:r,pointerTracker:s}=this;s.getLatestPoint(dr),Hi(dr.x,dr.y,e,ar),Xi(t,ar,i),r.copy(t.ray.direction).normalize(),this.zoomDirectionSet=!0}_updateZoomPoint(){const{camera:e,zoomDirectionSet:t,zoomDirection:i,raycaster:r,zoomPoint:s,pointerTracker:n,domElement:o}=this;if(this._zoomPointWasSet=!1,!t)return!1;e.isOrthographicCamera&&n.getLatestPoint(ur)?(Hi(ur.x,ur.y,o,ur),Xi(r,ur,e)):(r.ray.origin.copy(e.position),r.ray.direction.copy(i),r.near=0,r.far=1/0);const a=this._raycast(r);return!!a&&(s.copy(a.point),this.zoomPointSet=!0,this._zoomPointWasSet=!0,!0)}_getPointBelowCamera(e=this.camera.position,t=this.up){const{raycaster:i}=this;i.ray.direction.copy(t).multiplyScalar(-1),i.ray.origin.copy(e).addScaledVector(t,1e5),i.near=0,i.far=1/0;const r=this._raycast(i);return r&&(r.distance-=1e5),r}_updatePosition(e){const{raycaster:t,camera:i,pivotPoint:r,up:s,pointerTracker:n,domElement:o,state:a,dragInertia:l}=this;if(1===a){if(n.getCenterPoint(dr),Hi(dr.x,dr.y,o,dr),nr.setFromNormalAndCoplanarPoint(s,r),Xi(t,dr,i),Math.abs(t.ray.direction.dot(s))<Ki){const e=Math.acos(Ki);rr.crossVectors(t.ray.direction,s).normalize(),t.ray.direction.copy(s).applyAxisAngle(rr,e).multiplyScalar(-1)}if(this.getUpDirection(r,or),Math.abs(t.ray.direction.dot(or))<qi){const e=Math.acos(qi);rr.crossVectors(t.ray.direction,or).normalize(),t.ray.direction.copy(or).applyAxisAngle(rr,e).multiplyScalar(-1)}t.ray.intersectPlane(nr,Qi)&&(Wi.subVectors(r,Qi),i.position.add(Wi),i.updateMatrix(),Wi.multiplyScalar(1/e),n.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(l.copy(Wi),this.inertiaStableFrames=0))}}_updateRotation(e){const{pivotPoint:t,pointerTracker:i,domElement:r,state:s,rotationInertia:n}=this;2===s&&(i.getCenterPoint(dr),i.getPreviousCenterPoint(pr),mr.subVectors(dr,pr).multiplyScalar(2*Math.PI/r.clientHeight),this._applyRotation(mr.x,mr.y,t),mr.multiplyScalar(1/e),i.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(n.copy(mr),this.inertiaStableFrames=0))}_applyRotation(e,t,i){if(0===e&&0===t)return;const{camera:r,minAltitude:s,maxAltitude:n,rotationSpeed:o}=this,a=-e*o;let l,c=t*o;if(er.set(0,0,1).transformDirection(r.worldMatrix),tr.set(1,0,0).transformDirection(r.worldMatrix),this.getUpDirection(i,or),or.dot(er)>1-1e-10)l=0;else{Qi.crossVectors(or,er).normalize();l=Math.sign(Qi.dot(tr))*or.angleTo(er)}c>0?(c=Math.min(l-s,c),c=Math.max(0,c)):(c=Math.max(l-n,c),c=Math.min(0,c)),sr.setFromAxisAngle(or,a),Gi(i,sr,$i),r.worldMatrix.premultiply($i),tr.set(1,0,0).transformDirection(r.worldMatrix),sr.setFromAxisAngle(tr,-c),Gi(i,sr,$i),r.worldMatrix.premultiply($i),r.worldMatrix.decompose(r.position,r.quaternion,Qi)}_setFrame(e){const{up:i,camera:r,zoomPoint:s,zoomDirectionSet:n,zoomPointSet:o,scaleZoomOrientationAtEdges:a}=this;if(n&&(o||this._updateZoomPoint())){if(sr.setFromUnitVectors(i,e),a){this.getUpDirection(s,Qi);let e=Math.max(Qi.dot(i)-.6,0)/.4;e=t.MathUtils.mapLinear(e,0,.5,0,1),e=Math.min(e,1),r.isOrthographicCamera&&(e*=.1),sr.slerpQuaternions(sr,cr,1-e)}Gi(s,sr,$i),r.updateMatrix(),r.worldMatrix.premultiply($i),r.worldMatrix.decompose(r.position,r.quaternion,Qi),this.zoomDirectionSet=!1,this._updateZoomDirection()}i.copy(e),r.updateMatrix()}_raycast(e){const{scene:t,useFallbackPlane:i,fallbackPlane:r}=this,s=e.intersectObject(t,!0)[0]||null;if(s)return s;if(i){const t=r;if(e.ray.intersectPlane(t,Qi)){return{point:Qi.clone(),distance:e.ray.origin.distanceTo(Qi)}}}return null}_alignCameraUp(e,i=1){const{camera:r,state:s,pivotPoint:n,zoomPoint:o,zoomPointSet:a}=this;r.updateMatrix(),er.set(0,0,-1).transformDirection(r.worldMatrix),tr.set(-1,0,0).transformDirection(r.worldMatrix);let l=t.MathUtils.mapLinear(1-Math.abs(er.dot(e)),0,.2,0,1);l=t.MathUtils.clamp(l,0,1),i*=l,ir.crossVectors(e,er),ir.lerp(tr,1-i).normalize(),sr.setFromUnitVectors(tr,ir),r.quaternion.premultiply(sr);let c=null;1===s||2===s?c=Zi.copy(n):a&&(c=Zi.copy(o)),c&&(Yi.copy(r.worldMatrix).invert(),Qi.copy(c).applyMatrix4(Yi),r.updateMatrix(),Qi.applyMatrix4(r.worldMatrix),Ji.subVectors(c,Qi),r.position.add(Ji)),r.updateMatrix()}_clampRotation(e){const{camera:t,minAltitude:i,maxAltitude:r,state:s,pivotPoint:n,zoomPoint:o,zoomPointSet:a}=this;let l,c;if(t.updateMatrix(),er.set(0,0,1).transformDirection(t.worldMatrix),tr.set(1,0,0).transformDirection(t.worldMatrix),e.dot(er)>1-1e-10)l=0;else{Qi.crossVectors(e,er);l=Math.sign(Qi.dot(tr))*e.angleTo(er)}if(l>r)c=r;else{if(!(l<i))return;c=i}er.copy(e),sr.setFromAxisAngle(tr,c),er.applyQuaternion(sr).normalize(),Qi.crossVectors(er,tr).normalize(),$i.makeBasis(tr,Qi,er),t.quaternion.setFromRotationMatrix($i);let h=null;1===s||2===s?h=Zi.copy(n):a&&(h=Zi.copy(o)),h&&(Yi.copy(t.worldMatrix).invert(),Qi.copy(h).applyMatrix4(Yi),t.updateMatrix(),Qi.applyMatrix4(t.worldMatrix),Ji.subVectors(h,Qi),t.position.add(Ji)),t.updateMatrix()}}const vr=new t.Matrix4,Mr=new t.Matrix4,Tr=new t.Vector3,Ar=new t.Vector3,wr=new t.Vector3,Pr=new t.Vector3,Sr=new t.Vector3,Cr=new t.Vector3,Er=new t.Quaternion,Lr=new t.Vector3,Rr=new t.Vector3,Ir=new t.Ray,Ur=new Bt,Dr=new t.Vector2,Br={};class Or{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(e){e&&this.completeFade(e)}guaranteeState(e){const t=this._fadeState;if(t.has(e))return!1;return t.set(e,{fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0}),!0}completeFade(e){const t=this._fadeState;if(!t.has(e))return;const i=0===t.get(e).fadeOutTarget;t.delete(e),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(e,i),0===this.fadeCount&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach((e,t)=>{this.completeFade(t)})}forEachObject(e){this._fadeState.forEach((t,i)=>{e(i,t)})}fadeIn(e){const t=this.guaranteeState(e),i=this._fadeState.get(e);i.fadeInTarget=1,i.fadeOutTarget=0,i.fadeOut=0,t&&(this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}fadeOut(e){const t=this.guaranteeState(e),i=this._fadeState.get(e);i.fadeOutTarget=1,t&&(i.fadeInTarget=1,i.fadeIn=1,this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}isFading(e){return this._fadeState.has(e)}isFadingOut(e){const t=this._fadeState.get(e);return t&&1===t.fadeOutTarget}update(){const e=window.performance.now();-1===this._lastTick&&(this._lastTick=e);const i=t.MathUtils.clamp((e-this._lastTick)/this.duration,0,1);this._lastTick=e;this._fadeState.forEach((e,r)=>{const{fadeOutTarget:s,fadeInTarget:n}=e;let{fadeOut:o,fadeIn:a}=e;const l=Math.sign(n-a);a=t.MathUtils.clamp(a+l*i,0,1);const c=Math.sign(s-o);o=t.MathUtils.clamp(o+c*i,0,1),e.fadeIn=a,e.fadeOut=o;((1===o||0===o)&&(1===a||0===a)||o>=a)&&this.completeFade(r)})}}class Vr{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(e,t,i){if(!e)return;const r=this._fadeParams;e.traverse(e=>{const s=e.material;if(s){const e=r.get(s);e.fadeIn=t,e.fadeOut=i;const n=Number(!(0===t||1===t)||!(0===i||1===i));s.defines.FEATURE_FADE!==n&&(this.fading+=1===n?1:-1,s.defines.FEATURE_FADE=n,s.needsUpdate=!0)}})}prepareScene(e){e.traverse(e=>{e.material&&this.prepareMaterial(e.material)})}deleteScene(e){if(!e)return;const t=this._fadeParams;e.traverse(e=>{const i=e.material;i&&(t.delete(i),i.defines.FEATURE_FADE=!1,i.needsUpdate=!0)})}prepareMaterial(e){const i=this._fadeParams;i.has(e)||i.set(e,function(e){e.shaderName=`${e.shaderName||e.type}_fade`,e.defines.FEATURE_FADE=0,e.uniforms.fadeIn=0,e.uniforms.fadeOut=0;const i=e.fragmentShader||(e.type===t.MATERIAL_TYPE.BASIC?t.ShaderLib.basic_frag:t.ShaderLib.pbr_frag);return e.type=t.MATERIAL_TYPE.SHADER,e.vertexShader=e.type===t.MATERIAL_TYPE.BASIC?t.ShaderLib.basic_vert:t.ShaderLib.pbr_vert,e.fragmentShader=i.replace(/void main\(/,e=>`\n\t\t\t#if FEATURE_FADE\n\n\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\tfloat bayerDither2x2(vec2 v) {\n\t\t\t\treturn mod(3.0 * v.y + 2.0 * v.x, 4.0);\n\t\t\t}\n\n\t\t\tfloat bayerDither4x4(vec2 v) {\n\t\t\t\tvec2 P1 = mod(v, 2.0);\n\t\t\t\tvec2 P2 = floor(0.5 * mod(v, 4.0));\n\t\t\t\treturn 4.0 * bayerDither2x2(P1) + bayerDither2x2(P2);\n\t\t\t}\n\n\t\t\tuniform float fadeIn;\n\t\t\tuniform float fadeOut;\n\n\t\t\t#endif\n\n\t\t\t${e}\n\t\t`).replace(/#include <end_frag>/,e=>`\n\t\t\t${e}\n\n\t\t\t#if FEATURE_FADE\n\n\t\t\tfloat bayerValue = bayerDither4x4(floor(mod(gl_FragCoord.xy, 4.0)));\n\t\t\tfloat bayerBins = 16.0;\n\t\t\tfloat dither = (0.5 + bayerValue) / bayerBins;\n\t\t\tif (dither >= fadeIn) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tif (dither < fadeOut) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\t#endif\n\t\t`),e.uniforms}(e))}}const Fr=Symbol("HAS_POPPED_IN"),kr=new t.Vector3,Nr=new t.Vector3,zr=new t.Quaternion,Gr=new t.Quaternion,Hr=new t.Vector3;function jr(){const e=this._fadeManager,t=this.tiles;this._fadingBefore=e.fadeCount,this._displayActiveTiles=t.displayActiveTiles,t.displayActiveTiles=!0}function Xr(){const e=this._fadeManager,t=this._fadeMaterialManager,i=this._displayActiveTiles,r=this._fadingBefore,s=this._prevCameraTransforms,{tiles:n,maximumFadeOutTiles:o}=this,a=n.$cameras._cameras;n.displayActiveTiles=i,e.update();const l=e.fadeCount;if(0!==r&&0!==l&&(n.dispatchEvent({type:"fade-change"}),n.dispatchEvent({type:"needs-render"})),i||n.visibleTiles.forEach(e=>{const t=e.cached.scene;t&&(t.visible=e.__inFrustum)}),o<this._fadingOutCount){let t=!0;a.forEach(e=>{if(!s.has(e))return;const i=e.worldMatrix,r=s.get(e);i.decompose(Nr,Gr,Hr),r.decompose(kr,zr,Hr);const n=Gr.angleTo(zr),o=Nr.distanceTo(kr);t=t&&(n>.25||o>.1)}),t&&e.completeAllFades()}a.forEach(e=>{s.get(e).copy(e.worldMatrix)}),e.forEachObject((i,{fadeIn:r,fadeOut:s})=>{const o=i.cached.scene,a=e.isFadingOut(i);n.markTileUsed(i),o&&(t.setFade(o,r,s),a&&(o.visible=!0))})}class Kr{constructor(e={}){const{apiToken:t,autoRefreshToken:i=!1}=e;this.apiToken=t,this.autoRefreshToken=i,this.authURL=null,this._tokenRefreshPromise=null,this._bearerToken=null}async fetch(e,t){await this._tokenRefreshPromise;const i={...t};i.headers=i.headers||{},i.headers={...i.headers,Authorization:this._bearerToken};const r=await fetch(e,i);return r.status>=400&&r.status<=499&&this.autoRefreshToken?(await this.refreshToken(t),i.headers.Authorization=this._bearerToken,fetch(e,i)):r}refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.authURL);t.searchParams.set("access_token",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then(e=>{if(!e.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${e.status}`);return e.json()}).then(e=>(this._bearerToken=`Bearer ${e.accessToken}`,this._tokenRefreshPromise=null,e))}return this._tokenRefreshPromise}}const qr="https://tile.googleapis.com/v1/createSession";class $r{get isMapTilesSession(){return this.authURL===qr}constructor(e={}){const{apiToken:t,sessionOptions:i=null,autoRefreshToken:r=!1}=e;this.apiToken=t,this.autoRefreshToken=r,this.authURL=qr,this.sessionToken=null,this.sessionOptions=i,this._tokenRefreshPromise=null}async fetch(e,t){null===this.sessionToken&&this.isMapTilesSession&&this.refreshToken(t),await this._tokenRefreshPromise;const i=new URL(e);i.searchParams.set("key",this.apiToken),this.sessionToken&&i.searchParams.set("session",this.sessionToken);let r=await fetch(i,t);return r.status>=400&&r.status<=499&&this.autoRefreshToken&&(await this.refreshToken(t),this.sessionToken&&i.searchParams.set("session",this.sessionToken),r=await fetch(i,t)),null!==this.sessionToken||this.isMapTilesSession?r:r.json().then(e=>(this.sessionToken=Yr(e),e))}refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.authURL);t.searchParams.set("key",this.apiToken);const i={...e};this.isMapTilesSession&&(i.method="POST",i.body=JSON.stringify(this.sessionOptions),i.headers=i.headers||{},i.headers={...i.headers,"Content-Type":"application/json"}),this._tokenRefreshPromise=fetch(t,i).then(e=>{if(!e.ok)throw new Error(`GoogleCloudAuth: Failed to load data with error code ${e.status}`);return e.json()}).then(e=>(this.sessionToken=Yr(e),this._tokenRefreshPromise=null,e))}return this._tokenRefreshPromise}}function Yr(e){if("session"in e)return e.session;{let t=null;return T(e.root,e=>{if(e.content&&e.content.uri){const[,i]=e.content.uri.split("?");return t=new URLSearchParams(i).get("session"),!0}return!1}),t}}class Wr{constructor(){this.creditsCount={}}_adjustAttributions(e,t){const i=this.creditsCount,r=e.split(/;/g);for(let e=0,s=r.length;e<s;e++){const s=r[e];s in i||(i[s]=0),i[s]+=t?1:-1,i[s]<=0&&delete i[s]}}addAttributions(e){this._adjustAttributions(e,!0)}removeAttributions(e){this._adjustAttributions(e,!1)}toString(){const e=Object.entries(this.creditsCount).sort((e,t)=>{const i=e[1];return t[1]-i});return e.map(e=>e[0]).join("; ")}}class Qr{constructor({apiToken:e,sessionOptions:t=null,autoRefreshToken:i=!1,logoUrl:r=null,useRecommendedSettings:s=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.apiToken=e,this.useRecommendedSettings=s,this.logoUrl=r,this.auth=new $r({apiToken:e,autoRefreshToken:i,sessionOptions:t}),this.tiles=null,this._visibilityChangeCallback=null,this._attributionsManager=new Wr,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(e){const{useRecommendedSettings:t,auth:i}=this;e.resetFailedTiles(),null==e.rootURL&&(e.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),i.sessionOptions||(i.authURL=e.rootURL),t&&!i.isMapTilesSession&&(e.errorTarget=20),this.tiles=e,this._visibilityChangeCallback=({tile:e,visible:t})=>{},e.addEventListener("tile-visibility-change",this._visibilityChangeCallback)}getAttributions(e){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,e.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),e.push(this._attribution))}dispose(){this.tiles.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(e,t){return this.auth.fetch(e,t)}}class Zr{static computeNormals(e){const i=e.index,r=e.attributes,s=r.a_Position;if(void 0===s)return;let n=r.a_Normal;if(void 0===n)n=new t.Attribute(new t.Buffer(new Float32Array(3*s.buffer.count),3)),e.addAttribute("a_Normal",n);else{for(let e=0;e<n.buffer.array.length;e++)n.buffer.array[e]=0;n.buffer.version++}const o=new t.Vector3,a=new t.Vector3,l=new t.Vector3,c=new t.Vector3,h=new t.Vector3,u=new t.Vector3,d=new t.Vector3,p=new t.Vector3;if(i)for(let e=0,t=i.buffer.count;e<t;e+=3){const t=i.buffer.array[e+0],r=i.buffer.array[e+1],m=i.buffer.array[e+2];o.fromArray(s.buffer.array,3*t),a.fromArray(s.buffer.array,3*r),l.fromArray(s.buffer.array,3*m),d.subVectors(l,a),p.subVectors(o,a),d.cross(p),c.fromArray(n.buffer.array,3*t),h.fromArray(n.buffer.array,3*r),u.fromArray(n.buffer.array,3*m),c.add(d),h.add(d),u.add(d),c.toArray(n.buffer.array,3*t),h.toArray(n.buffer.array,3*r),u.toArray(n.buffer.array,3*m)}else for(let e=0,t=3*s.buffer.count;e<t;e+=9)o.fromArray(s.buffer.array,e+0),a.fromArray(s.buffer.array,e+3),l.fromArray(s.buffer.array,e+6),d.subVectors(l,a),p.subVectors(o,a),d.cross(p),d.toArray(n.buffer.array,e+0),d.toArray(n.buffer.array,e+3),d.toArray(n.buffer.array,e+6);this.normalizeNormals(e)}static normalizeNormals(e){const t=e.attributes.a_Normal.buffer;for(let e=0;e<t.array.length;e+=3)Jr.fromArray(t.array,e),Jr.normalize(),Jr.toArray(t.array,e)}static computeTangents(e){const i=e.index,r=e.attributes;if(null===i||void 0===r.a_Position||void 0===r.a_Normal||void 0===r.a_Uv)return void console.warn("GeometryUtils: .computeTangents() failed. Missing required attributes (index, a_Position, a_Normal or a_Uv)");const s=i.buffer.array,n=r.a_Position.buffer.array,o=r.a_Normal.buffer.array,a=r.a_Uv.buffer.array,l=n.length/3;r.a_Tangent||e.addAttribute("a_Tangent",new t.Attribute(new t.Buffer(new Float32Array(4*l),4)));const c=r.a_Tangent.buffer.array,h=[],u=[];for(let e=0;e<l;e++)h[e]=new t.Vector3,u[e]=new t.Vector3;const d=new t.Vector3,p=new t.Vector3,m=new t.Vector3,f=new t.Vector2,g=new t.Vector2,_=new t.Vector2,b=new t.Vector3,y=new t.Vector3;function x(e,t,i){d.fromArray(n,3*e),p.fromArray(n,3*t),m.fromArray(n,3*i),f.fromArray(a,2*e),g.fromArray(a,2*t),_.fromArray(a,2*i),p.sub(d),m.sub(d),g.sub(f),_.sub(f);const r=1/(g.x*_.y-_.x*g.y);isFinite(r)&&(b.copy(p).multiplyScalar(_.y).addScaledVector(m,-g.y).multiplyScalar(r),y.copy(m).multiplyScalar(g.x).addScaledVector(p,-_.x).multiplyScalar(r),h[e].add(b),h[t].add(b),h[i].add(b),u[e].add(y),u[t].add(y),u[i].add(y))}let v=e.groups;0===v.length&&(v=[{start:0,count:s.length}]);for(let e=0,t=v.length;e<t;e++){const t=v[e],i=t.start;for(let e=i,r=i+t.count;e<r;e+=3)x(s[e+0],s[e+1],s[e+2])}const M=new t.Vector3,T=new t.Vector3,A=new t.Vector3,w=new t.Vector3;function P(e){A.fromArray(o,3*e),w.copy(A);const t=h[e];M.copy(t),M.sub(A.multiplyScalar(A.dot(t))).normalize(),T.crossVectors(w,t);const i=T.dot(u[e])<0?-1:1;c[4*e]=M.x,c[4*e+1]=M.y,c[4*e+2]=M.z,c[4*e+3]=-i}for(let e=0,t=v.length;e<t;e++){const t=v[e],i=t.start;for(let e=i,r=i+t.count;e<r;e+=3)P(s[e+0]),P(s[e+1]),P(s[e+2])}}static mergeGeometries(e,i=!1){const r=null!==e[0].index,s=new Set(Object.keys(e[0].attributes)),n=new Set(Object.keys(e[0].morphAttributes)),o={},a={},l=new t.Geometry;let c=0;for(let t=0;t<e.length;t++){const h=e[t];if(r!==(null!==h.index))return console.error("GeometryUtils: .mergeGeometries() failed with geometry at index "+t+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const e in h.attributes){if(!s.has(e))return console.error("GeometryUtils: .mergeGeometries() failed with geometry at index "+t+'. All geometries must have compatible attributes; make sure "'+e+'" attribute exists among all geometries, or in none of them.'),null;void 0===o[e]&&(o[e]=[]),o[e].push(h.attributes[e])}for(const e in h.morphAttributes){if(!n.has(e))return console.error("GeometryUtils: .mergeGeometries() failed with geometry at index "+t+". .morphAttributes must be consistent throughout all geometries."),null;void 0===a[e]&&(a[e]=[]),a[e].push(h.morphAttributes[e])}if(i){let e;if(r)e=h.index.buffer.count;else{if(void 0===h.attributes.a_Position)return console.error("GeometryUtils: .mergeGeometries() failed with geometry at index "+t+". The geometry must have either an index or an a_Position attribute"),null;e=h.attributes.a_Position.buffer.count}l.addGroup(c,e,t),c+=e}}if(r){let t=0;const i=[];for(let r=0;r<e.length;r++){const s=e[r].index;for(let e=0;e<s.buffer.count;e++)i.push(s.buffer.array[e]+t);t+=e[r].attributes.a_Position.buffer.count}l.setIndex(i)}for(const e in o){const t=this.mergeAttributes(o[e]);if(!t)return console.error("GeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;l.addAttribute(e,t)}for(const e in a){const t=a[e][0].length;if(0===t)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[e]=[];for(let i=0;i<t;i++){const t=[];for(let r=0;r<a[e].length;r++)t.push(a[e][r][i]);const r=this.mergeAttributes(t);if(!r)return console.error("GeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;l.morphAttributes[e].push(r)}}return l}static mergeAttributes(e){let i,r,s,n=0;for(let t=0;t<e.length;t++){const o=e[t];if(o.buffer.stride!==o.size)return console.error("GeometryUtils: .mergeAttributes() failed. Interleaved buffer attributes are not supported."),null;if(void 0===i&&(i=o.buffer.array.constructor),i!==o.buffer.array.constructor)return console.error("GeometryUtils: .mergeAttributes() failed. Buffer.array must be of consistent array types across matching attributes."),null;if(void 0===r&&(r=o.size),r!==o.size)return console.error("GeometryUtils: .mergeAttributes() failed. Attribute.size must be consistent across matching attributes."),null;if(void 0===s&&(s=o.normalized),s!==o.normalized)return console.error("GeometryUtils: .mergeAttributes() failed. Attribute.normalized must be consistent across matching attributes."),null;n+=o.buffer.array.length}const o=new i(n);let a=0;for(let t=0;t<e.length;t++)o.set(e[t].buffer.array,a),a+=e[t].buffer.array.length;return new t.Attribute(new t.Buffer(o,r),r,0,s)}static applyMatrix4(e,t,i){let r,s,n;const o=e.attributes.a_Position;if(void 0!==o){r=o.buffer.array,s=o.buffer.count,n=o.offset;for(let e=0;e<s;e++)Jr.fromArray(r,3*e+n),Jr.applyMatrix4(t),Jr.toArray(r,3*e+n);o.buffer.version++}const a=e.attributes.a_Normal;if(void 0!==a){r=a.buffer.array,s=a.buffer.count,n=a.offset;const e=es.setFromMatrix4(t).invert().transpose();for(let t=0;t<s;t++)Jr.fromArray(r,3*t+n),Jr.applyMatrix3(e).normalize(),Jr.toArray(r,3*t+n);a.buffer.version++}const l=e.attributes.a_Tangent;if(void 0!==l){r=l.buffer.array,s=l.buffer.count,n=l.offset;for(let e=0;e<s;e++)Jr.fromArray(r,3*e+n),Jr.transformDirection(t),Jr.toArray(r,3*e+n);l.buffer.version++}return null!==e.boundingBox&&i&&e.computeBoundingBox(),null!==e.boundingSphere&&i&&e.computeBoundingSphere(),e}static getWireframeAttribute(e){const i=[],r=e.index,s=e.attributes.a_Position;if(!s)return console.error("GeometryUtils: .getWireframeAttribute() failed. The geometry must have an a_Position attribute"),null;if(null!==r){const e=r.buffer.array;for(let t=0,r=e.length;t<r;t+=3){const r=e[t+0],s=e[t+1],n=e[t+2];i.push(r,s,s,n,n,r)}}else{for(let e=0,t=s.buffer.array.length/3-1;e<t;e+=3){const t=e+0,r=e+1,s=e+2;i.push(t,r,r,s,s,t)}}return new t.Attribute(new t.Buffer(s.buffer.array.length/3>65536?new Uint32Array(i):new Uint16Array(i),1))}static mergeBufferAttributes(e){return console.warn("GeometryUtils: mergeBufferAttributes() has been renamed to mergeAttributes()."),this.mergeAttributes(e)}}const Jr=new t.Vector3,es=new t.Matrix3,ts=Symbol("TILE_X"),is=Symbol("TILE_Y"),rs=Symbol("TILE_LEVEL");class ss{get tiling(){return this.imageSource.tiling}constructor(e={}){const{pixelSize:t=.01,center:i=!1,useRecommendedSettings:r=!0,imageSource:s=null}=e;this.priority=-10,this.tiles=null,this.imageSource=s,this.pixelSize=t,this.center=i,this.useRecommendedSettings=r}init(e){this.useRecommendedSettings&&(e.errorTarget=1),this.tiles=e,this.imageSource.fetchOptions=e.fetchOptions,this.imageSource.fetchData=(t,i)=>(e.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),e.invokeOnePlugin(e=>e!==this&&e.fetchData&&e.fetchData(t,i)))}async loadRootTileSet(){const{tiles:e,imageSource:t}=this;let i=e.rootURL;return e.invokeAllPlugins(e=>i=e.preprocessURL?e.preprocessURL(i,null):i),await t.init(i),this.getTileset(i)}async parseToMesh(e,i,r,s,n){const o=i[ts],a=i[is],l=i[rs],c=await this.imageSource.processBufferToTexture(e);this.imageSource.setData(o,a,l,c);let h=1,u=1,d=0,p=0,m=0;const f=i.boundingVolume.box;f&&([d,p,m]=f,h=f[3],u=f[7]);const g=new t.Mesh(new t.PlaneGeometry(2*h,2*u),new t.BasicMaterial),_=new t.Euler(Math.PI/2,0,0,"XYZ");return Zr.applyMatrix4(g.geometry,(new t.Matrix4).makeRotationFromEuler(_),!0),g.material.diffuseMap=c,g.material.transparent=!0,g.position.set(d,p,m),g}preprocessNode(e){const{tiling:t}=this,i=t.maxLevel;e[rs]<i&&null!==e.parent&&this.expandChildren(e)}disposeTile(e){const t=e[ts],i=e[is],r=e[rs];this.imageSource.release(t,i,r)}getTileset(e){const{tiling:t,tiles:i}=this,r=t.minLevel,{tileCountX:s,tileCountY:n}=t.getLevel(r),o=[];for(let e=0;e<s;e++)for(let t=0;t<n;t++){const i=this.createChild(e,t,r);null!==i&&o.push(i)}const a={asset:{version:"1.1"},geometricError:1e5,root:{refine:"REPLACE",geometricError:1e5,boundingVolume:this.createBoundingVolume(0,0,-1),children:o,[rs]:-1,[ts]:0,[is]:0}};return i.preprocessTileSet(a,e),a}getUrl(e,t,i){return this.imageSource.getUrl(e,t,i)}createBoundingVolume(e,t,i){const{center:r,pixelSize:s,tiling:n}=this,{pixelWidth:o,pixelHeight:a}=n.getLevel(n.maxLevel),[l,c,h,u]=-1===i?n.getFullBounds(!0):n.getTileBounds(e,t,i,!0);let d=(h-l)/2,p=(u-c)/2,m=l+d,f=c+p;return r&&(m-=.5,f-=.5),m*=o*s,d*=o*s,f*=a*s,p*=a*s,{box:[m,f,0,d,0,0,0,p,0,0,0,0]}}createChild(e,t,i){const{pixelSize:r,tiling:s}=this;if(!s.getTileExists(e,t,i))return null;const{pixelWidth:n,pixelHeight:o}=s.getLevel(s.maxLevel),{pixelWidth:a,pixelHeight:l}=s.getLevel(i);return{refine:"REPLACE",geometricError:r*(Math.max(n/a,o/l)-1),boundingVolume:this.createBoundingVolume(e,t,i),content:{uri:this.getUrl(e,t,i)},children:[],[ts]:e,[is]:t,[rs]:i}}expandChildren(e){const t=e[rs],i=e[ts],r=e[is];for(let s=0;s<2;s++)for(let n=0;n<2;n++){const o=this.createChild(2*i+s,2*r+n,t+1);o&&e.children.push(o)}}}const ns=new t.Vector3,os=new t.Vector3;const as=new t.Vector3,ls=new t.Vector3,cs=new t.Vector2,hs=new t.Sphere;class us extends ss{get projection(){return this.tiling.projection}constructor(e={}){const{shape:t="planar",endCaps:i=!0,...r}=e;super(r),this.shape=t,this.endCaps=i}async parseToMesh(e,i,...r){const s=await super.parseToMesh(e,i,...r),{shape:n,projection:o,tiles:a,tiling:l}=this;if("ellipsoid"===n){const e=a.ellipsoid,r=i[rs],n=i[ts],c=i[is],[h,u,d,p]=l.getTileBounds(n,c,r,!0),[m,f,g,_]=i.boundingVolume.region,b=Math.ceil((_-f)*t.MathUtils.RAD2DEG*.25),y=Math.ceil((g-m)*t.MathUtils.RAD2DEG*.25),x=Math.max(15,b),v=Math.max(30,y),M=new t.PlaneGeometry(1,1,v,x),{a_Position:T,a_Normal:A,a_Uv:w}=M.attributes,P=T.buffer.count;i.cached.boundingVolume.getBoundingSphere(hs);for(let i=0;i<P;i++){as.fromArray(T.buffer.array,3*i),ls.fromArray(A.buffer.array,3*i),cs.fromArray(w.buffer.array,2*i);const r=t.MathUtils.mapLinear(cs.x,0,1,m,g);let s=t.MathUtils.mapLinear(cs.y,0,1,f,_);if(o.isMercator&&0!==cs.y&&1!==cs.y){const e=o.convertProjectionToLatitude(1),i=1/x,r=t.MathUtils.mapLinear(cs.y-i,0,1,f,_),n=t.MathUtils.mapLinear(cs.y+i,0,1,f,_);s>e&&r<e&&(s=e),s<-e&&n>-e&&(s=-e)}e.getCartographicToPosition(s,r,0,as).sub(hs.center),e.getCartographicToNormal(s,r,ls);const n=t.MathUtils.mapLinear(o.convertLongitudeToProjection(r),h,d,0,1),a=t.MathUtils.mapLinear(o.convertLatitudeToProjection(s),u,p,0,1);w.buffer.array[2*i]=n,w.buffer.array[2*i+1]=a,as.toArray(T.buffer.array,3*i),ls.toArray(A.buffer.array,3*i)}s.geometry=M,s.position.copy(hs.center)}return s}createBoundingVolume(e,t,i){if("ellipsoid"===this.shape){const{tiling:r,endCaps:s}=this,n=-1===i,o=n?r.getFullBounds(!0):r.getTileBounds(e,t,i,!0),a=n?r.getFullBounds():r.getTileBounds(e,t,i);return s&&(1===o[3]&&(a[3]=Math.PI/2),0===o[1]&&(a[1]=-Math.PI/2)),{region:[...a,-1,1]}}return super.createBoundingVolume(e,t,i)}preprocessNode(e,...t){super.preprocessNode(e,t);const{shape:i,projection:r,tiling:s}=this;if("ellipsoid"===i){const t=e[rs],i=e[ts],n=e[is];if(-1===t)return e.geometricError=1e50,parent;const[o,a,l,c]=s.getTileBounds(i,n,t,!0),{tilePixelWidth:h,tilePixelHeight:u}=s.getLevel(t),{pixelWidth:d,pixelHeight:p}=s.getLevel(s.maxLevel),m=(l-o)/h,f=(c-a)/u,g=1/d,_=1/p,[,b,y,x]=s.getTileBounds(i,n,t),v=b>0!=x>0?0:Math.min(Math.abs(b),Math.abs(x)),M=r.convertLatitudeToProjection(v),T=r.getLongitudeDerivativeAtValue(o),A=r.getLatitudeDerivativeAtValue(M),[w,P]=function(e,t,i){const r=1e-5,s=i+r;let n=t+r;Math.abs(n)>Math.PI/2&&(n-=r),e.getCartographicToPosition(t,i,0,ns),e.getCartographicToPosition(n,i,0,os);const o=ns.distanceTo(os)/r;return e.getCartographicToPosition(t,s,0,os),[ns.distanceTo(os)/r,o]}(this.tiles.ellipsoid,v,y),S=Math.max(m*T*w,f*A*P),C=Math.max(g*T*w,_*A*P);e.geometricError=S-C,null===e.parent&&(e.geometricError=1e50)}return e}}class ds{get isMercator(){return"EPSG:3857"===this.scheme}constructor(e="EPSG:4326"){this.scheme=e,this.tileCountX=1,this.tileCountY=1,this.setScheme(e)}setScheme(e){switch(this.scheme=e,e){case"EPSG:4326":this.tileCountX=2,this.tileCountY=1;break;case"EPSG:3857":this.tileCountX=1,this.tileCountY=1;break;default:throw new Error}}convertProjectionToLatitude(e){if(this.isMercator){const i=t.MathUtils.mapLinear(e,0,1,-1,1);return 2*Math.atan(Math.exp(i*Math.PI))-Math.PI/2}return t.MathUtils.mapLinear(e,0,1,-Math.PI/2,Math.PI/2)}convertProjectionToLongitude(e){return t.MathUtils.mapLinear(e,0,1,-Math.PI,Math.PI)}convertLatitudeToProjection(e){if(this.isMercator){return.5+1*Math.log(Math.tan(Math.PI/4+e/2))/(2*Math.PI)}return t.MathUtils.mapLinear(e,-Math.PI/2,Math.PI/2,0,1)}convertLongitudeToProjection(e){return(e+Math.PI)/(2*Math.PI)}getLongitudeDerivativeAtValue(e){return 2*Math.PI}getLatitudeDerivativeAtValue(e){const t=1e-5;let i=e-t;return i<0&&(i=e+t),this.isMercator?Math.abs(this.convertProjectionToLatitude(e)-this.convertProjectionToLatitude(i))/t:Math.PI}getBounds(){return[this.convertProjectionToLongitude(0),this.convertProjectionToLatitude(0),this.convertProjectionToLongitude(1),this.convertProjectionToLatitude(1)]}}function ps(...e){return e.join("_")}class ms{constructor(){this.cache={},this.count=0,this.cachedBytes=0}fetchItem(){}disposeItem(){}getMemoryUsage(e){return 0}setData(...e){const{cache:t}=this,i=e.pop(),r=ps(...e);if(r in t)throw new Error(`DataCache: "${r}" is already present.`);return this.cache[r]={abortController:new AbortController,result:i,count:1,bytes:this.getMemoryUsage(i)},this.count++,this.cachedBytes+=this.cache[r].bytes,i}lock(...e){const{cache:t}=this,i=ps(...e);if(i in t)t[i].count++;else{const t=new AbortController,r={abortController:t,result:null,count:1,bytes:0};r.result=this.fetchItem(...e,t.signal).then(e=>(r.result=e,r.bytes=this.getMemoryUsage(e),this.cachedBytes+=r.bytes,e)),this.cache[i]=r,this.count++}return t[i].result}release(...e){const t=ps(...e);this.releaseViaFullKey(t)}get(...e){const{cache:t}=this,i=ps(...e);return i in t?t[i].result:null}dispose(){const{cache:e}=this;for(const t in e){const{abortController:i}=e[t];i.abort(),this.releaseViaFullKey(t,!0)}this.cache={}}releaseViaFullKey(e,t=!1){const{cache:i}=this;if(e in i){const r=i[e];if(r.count--,0===r.count||t){const s=()=>{if(i[e]!==r)return;const{result:t,abortController:s}=r;s.abort(),t instanceof Promise?t.then(e=>this.disposeItem(e)).catch(()=>{}):this.disposeItem(t),delete i[e],this.count--,this.cachedBytes-=r.bytes};t?s():queueMicrotask(()=>{0===r.count&&s()})}return!0}throw new Error("DataCache: Attempting to release key that does not exist")}}function fs(e,t,i){return Math.min(Math.max(e,t),i)}class gs{get levelCount(){return this._levels.length}get maxLevel(){return this.levelCount-1}get minLevel(){const e=this._levels;for(let t=0;t<e.length;t++)if(null!==e[t])return t;return-1}get rootBounds(){return this._rootBounds??this.projection?.getBounds()??[0,0,1,1]}get rootOrigin(){const e=this.rootBounds;return this._rootOrigin??[e[0],e[1]]}constructor(){this.flipY=!1,this.pixelOverlap=0,this._rootBounds=null,this._rootOrigin=null,this.projection=null,this._levels=[]}setLevel(e,t={}){const i=this._levels;for(;i.length<e;)i.push(null);const{tilePixelWidth:r=256,tilePixelHeight:s=256,tileCountX:n=2**e,tileCountY:o=2**e}=t,{pixelWidth:a=r*n,pixelHeight:l=s*o}=t;i[e]={tilePixelWidth:r,tilePixelHeight:s,pixelWidth:a,pixelHeight:l,tileCountX:n,tileCountY:o}}generateLevels(e,t,i,r={}){const{minLevel:s=0,tilePixelWidth:n=256,tilePixelHeight:o=256}=r,a=e-1,{pixelWidth:l=n*t*2**a,pixelHeight:c=o*i*2**a}=r;for(let t=s;t<e;t++){const i=e-t-1,r=Math.ceil(l*2**-i),s=Math.ceil(c*2**-i),a=Math.ceil(r/n),h=Math.ceil(s/o);this.setLevel(t,{tilePixelWidth:n,tilePixelHeight:o,pixelWidth:r,pixelHeight:s,tileCountX:a,tileCountY:h})}}getLevel(e){return this._levels[e]}setOrigin(e,t){this._rootOrigin=[e,t]}setBounds(e,t,i,r){this._rootBounds=[e,t,i,r]}setProjection(e){this.projection=e}getTileAtPoint(e,t,i,r=!1,s=!0){const{projection:n,flipY:o}=this,{tileCountX:a,tileCountY:l}=this.getLevel(i),c=1/a,h=1/l;n&&!r&&(e=n.convertLongitudeToProjection(e),t=n.convertLatitudeToProjection(t)),s&&(e=fs(e,0,1),t=fs(t,0,1));let u=Math.floor(e/c),d=Math.floor(t/h);return o&&(d=l-1-d),s&&(u=fs(u,0,a-1),d=fs(d,0,l-1)),[u,d]}getTilesInRange(e,t,i,r,s,n=!1,o=!0){const a=this.getTileAtPoint(e,t,s,n,o),l=this.getTileAtPoint(i,r,s,n,o);return this.flipY&&([a[1],l[1]]=[l[1],a[1]]),[...a,...l]}getTileExists(e,t,i,r){const[s,n,o,a]=this.rootBounds,[l,c,h,u]=this.getTileBounds(e,t,i,r);return!(l>=h||c>=u)&&l<=o&&c<=a&&h>=s&&u>=n}getFullBounds(e=!1){const{projection:t}=this,i=[...this.rootBounds];return t&&e&&(i[0]=t.convertLongitudeToProjection(i[0]),i[1]=t.convertLatitudeToProjection(i[1]),i[2]=t.convertLongitudeToProjection(i[2]),i[3]=t.convertLatitudeToProjection(i[3])),i}getTileBounds(e,t,i,r=!1){const{flipY:s,pixelOverlap:n,projection:o}=this,{tilePixelWidth:a,tilePixelHeight:l,pixelWidth:c,pixelHeight:h}=this.getLevel(i);let u=a*e-n,d=l*t-n,p=u+a+2*n,m=d+l+2*n;if(u=Math.max(u,0),d=Math.max(d,0),p=Math.min(p,c),m=Math.min(m,h),u/=c,p/=c,d/=h,m/=h,s){const e=(m-d)/2,t=1-(d+m)/2;d=t-e,m=t+e}const f=[u,d,p,m];return o&&!r&&(f[0]=o.convertProjectionToLongitude(f[0]),f[1]=o.convertProjectionToLatitude(f[1]),f[2]=o.convertProjectionToLongitude(f[2]),f[3]=o.convertProjectionToLatitude(f[3])),f}}class _s extends ms{constructor(){super(),this.tiling=new gs,this.fetchOptions={},this.fetchData=(...e)=>fetch(...e)}init(e){}async processBufferToTexture(e){const i=new Blob([e]),r=await createImageBitmap(i,{premultiplyAlpha:"none",colorSpaceConversion:"none",imageOrientation:"flipY"}),s=new t.Texture2D;return s.image=r,s.generateMipmaps=!1,s.minFilter=t.TEXTURE_FILTER.LINEAR,s.encoding=t.TEXEL_ENCODING_TYPE.SRGB,s.version++,s}getMemoryUsage(e){return 0}fetchItem(...e){const t=this.getUrl(...e);return this.fetchData(t,this.fetchOptions).then(e=>e.arrayBuffer()).then(e=>this.processBufferToTexture(e))}disposeItem(e){e.dispose(),e.image instanceof ImageBitmap&&e.image.close()}getUrl(...e){}}class bs extends _s{constructor(e={}){super();const{levels:t=20,tileDimension:i=256}=e;this.tileDimension=i,this.levels=t,this.url=null}getUrl(e,t,i){return this.url.replace("{z}",i).replace("{x}",e).replace("{y}",t)}init(e){const{tiling:t,tileDimension:i,levels:r}=this;return t.flipY=!0,t.setProjection(new ds("EPSG:3857")),t.generateLevels(r,1,1,{tilePixelWidth:i,tilePixelHeight:i}),this.url=e,Promise.resolve()}}class ys extends _s{constructor(){super(),this.tileSets=null,this.extension=null,this.url=null}getUrl(e,t,i){const{url:r,extension:s,tileSets:n,tiling:o}=this;return new URL(`${parseInt(n[i-o.minLevel].href)}/${e}/${t}.${s}`,r).toString()}init(e){return this.fetchData(new URL("tilemapresource.xml",e),this.fetchOptions).then(e=>e.text()).then(i=>{const{tiling:r}=this,s=(new DOMParser).parseFromString(i,"text/xml"),n=s.querySelector("BoundingBox"),o=s.querySelector("Origin"),a=s.querySelector("TileFormat"),l=[...s.querySelector("TileSets").querySelectorAll("TileSet")].map(e=>({href:parseInt(e.getAttribute("href")),unitsPerPixel:parseFloat(e.getAttribute("units-per-pixel")),order:parseInt(e.getAttribute("order"))})).sort((e,t)=>e.order-t.order),c=parseFloat(n.getAttribute("minx"))*t.MathUtils.DEG2RAD,h=parseFloat(n.getAttribute("maxx"))*t.MathUtils.DEG2RAD,u=parseFloat(n.getAttribute("miny"))*t.MathUtils.DEG2RAD,d=parseFloat(n.getAttribute("maxy"))*t.MathUtils.DEG2RAD,p=parseFloat(o.getAttribute("x"))*t.MathUtils.DEG2RAD,m=parseFloat(o.getAttribute("y"))*t.MathUtils.DEG2RAD,f=parseInt(a.getAttribute("width")),g=parseInt(a.getAttribute("height")),_=a.getAttribute("extension"),b=s.querySelector("SRS").textContent;this.extension=_,this.url=e,this.tileSets=l,r.setProjection(new ds(b)),r.setOrigin(p,m),r.setBounds(c,u,h,d),l.forEach(({order:e})=>{r.setLevel(e,{tileCountX:r.projection.tileCountX*2**e,tilePixelWidth:f,tilePixelHeight:g})})})}}class xs extends us{constructor(...e){super(...e),this.name="TMS_TILES_PLUGIN",this.imageSource=new ys}}function vs(e){return e>>1^-(1&e)}class Ms extends i{constructor(...e){super(...e),this.fetchOptions.header={Accept:"application/vnd.quantized-mesh,application/octet-stream;q=0.9"}}loadAsync(...e){const{fetchOptions:t}=this;return t.header=t.header||{},t.header.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",t.header.Accept+=";extensions=octvertexnormals-watermask-metadata",super.loadAsync(...e)}parse(e){let t=0;const i=new DataView(e),r=()=>{const e=i.getFloat64(t,!0);return t+=8,e},s=()=>{const e=i.getFloat32(t,!0);return t+=4,e},n=()=>{const e=i.getUint32(t,!0);return t+=4,e},o=()=>{const e=i.getUint8(t);return t+=1,e},a=(i,r)=>{const s=new r(e,t,i);return t+=i*r.BYTES_PER_ELEMENT,s},l={center:[r(),r(),r()],minHeight:s(),maxHeight:s(),sphereCenter:[r(),r(),r()],sphereRadius:r(),horizonOcclusionPoint:[r(),r(),r()]},c=n(),h=a(c,Uint16Array),u=a(c,Uint16Array),d=a(c,Uint16Array),p=new Float32Array(c),m=new Float32Array(c),f=new Float32Array(c);let g=0,_=0,b=0;const y=32767;for(let e=0;e<c;++e)g+=vs(h[e]),_+=vs(u[e]),b+=vs(d[e]),p[e]=g/y,m[e]=_/y,f[e]=b/y;const x=c>65536,v=x?Uint32Array:Uint16Array;t=x?4*Math.ceil(t/4):2*Math.ceil(t/2);const M=a(3*n(),v);let T=0;for(let e=0;e<M.length;++e){const t=M[e];M[e]=T-t,0===t&&++T}const A=(e,t)=>m[t]-m[e],w=(e,t)=>p[e]-p[t],P=a(n(),v);P.sort(A);const S=a(n(),v);S.sort(w);const C=a(n(),v);C.sort((e,t)=>-A(e,t));const E=a(n(),v);E.sort((e,t)=>-w(e,t));const L={westIndices:P,southIndices:S,eastIndices:C,northIndices:E},R={};for(;t<i.byteLength;){const e=o(),t=n();if(1===e){const t=a(2*c,Uint8Array),i=new Float32Array(3*c);for(let e=0;e<c;e++){let r=t[2*e+0]/255*2-1,s=t[2*e+1]/255*2-1;const n=1-(Math.abs(r)+Math.abs(s));if(n<0){const e=r;r=(1-Math.abs(s))*Ts(e),s=(1-Math.abs(e))*Ts(s)}const o=Math.sqrt(r*r+s*s+n*n);i[3*e+0]=r/o,i[3*e+1]=s/o,i[3*e+2]=n/o}R.octvertexnormals={extensionId:e,normals:i}}else if(2===e){const i=1===t?1:256,r=a(i*i,Uint8Array);R.watermask={extensionId:e,mask:r,size:i}}else if(4===e){const t=a(n(),Uint8Array),i=(new TextDecoder).decode(t);R.metadata={extensionId:e,json:JSON.parse(i)}}}return{header:l,indices:M,vertexData:{u:p,v:m,height:f},edgeIndices:L,extensions:R}}}function Ts(e){return e<0?-1:1}const As=new t.Vector3,ws=new t.Triangle,Ps=new t.Vector3,Ss=new t.Vector3;class Cs extends Ms{constructor(e=t.DefaultLoadingManager){super(),this.manager=e,this.ellipsoid=new Bt,this.skirtLength=1e3,this.smoothSkirtNormals=!0,this.solid=!1,this.minLat=-Math.PI/2,this.maxLat=Math.PI/2,this.minLon=-Math.PI,this.maxLon=Math.PI}parse(e){const{ellipsoid:i,solid:r,skirtLength:s,smoothSkirtNormals:n,minLat:o,maxLat:a,minLon:l,maxLon:c}=this,{header:h,indices:u,vertexData:d,edgeIndices:p,extensions:m}=super.parse(e),f=new t.Geometry,g=new t.PBRMaterial;g.roughness=1,g.metalness=0;const _=new t.Mesh(f,g);_.position.set(...h.center);const b="octvertexnormals"in m,y=d.u.length,x=[],v=[],M=[],T=[];for(let e=0;e<y;e++)w(e,Ps),P(Ps.x,Ps.y,Ps.z,Ss),v.push(Ps.x,Ps.y),x.push(...Ss);for(let e=0,t=u.length;e<t;e++)M.push(u[e]);if(b){const e=m.octvertexnormals.normals;for(let t=0,i=e.length;t<i;t++)T.push(e[t])}if(r){const e=x.length/3;for(let e=0;e<y;e++)w(e,Ps),P(Ps.x,Ps.y,Ps.z,Ss,-s),v.push(Ps.x,Ps.y),x.push(...Ss);for(let t=u.length-1;t>=0;t--)M.push(u[t]+e);if(b){const e=m.octvertexnormals.normals;for(let t=0,i=e.length;t<i;t++)T.push(-e[t])}}if(s>0){const{westIndices:e,eastIndices:t,southIndices:i,northIndices:r}=p;let s;const n=S(e);s=x.length/3,v.push(...n.uv),x.push(...n.positions);for(let e=0,t=n.indices.length;e<t;e++)M.push(n.indices[e]+s);const o=S(t);s=x.length/3,v.push(...o.uv),x.push(...o.positions);for(let e=0,t=o.indices.length;e<t;e++)M.push(o.indices[e]+s);const a=S(i);s=x.length/3,v.push(...a.uv),x.push(...a.positions);for(let e=0,t=a.indices.length;e<t;e++)M.push(a.indices[e]+s);const l=S(r);s=x.length/3,v.push(...l.uv),x.push(...l.positions);for(let e=0,t=l.indices.length;e<t;e++)M.push(l.indices[e]+s);b&&(T.push(...n.normals),T.push(...o.normals),T.push(...a.normals),T.push(...l.normals))}for(let e=0,t=x.length;e<t;e+=3)x[e+0]-=h.center[0],x[e+1]-=h.center[1],x[e+2]-=h.center[2];const A=x.length/3>65535?new Uint32Array(M):new Uint16Array(M);if(f.setIndex(new t.Attribute(new t.Buffer(A,1))),f.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array(x),3))),f.addAttribute("a_Uv",new t.Attribute(new t.Buffer(new Float32Array(v),2))),b&&f.addAttribute("a_Normal",new t.Attribute(new t.Buffer(new Float32Array(T),3))),"watermask"in m){const{mask:e,size:i}=m.watermask,r=new Uint8Array(2*i*i);for(let t=0,i=e.length;t<i;t++){const i=255===e[t]?0:255;r[2*t+0]=i,r[2*t+1]=i}const s=new t.Texture2D;s.image={data:r,width:i,height:i},s.flipY=!0,s.format=t.PIXEL_FORMAT.RG,s.type=t.PIXEL_TYPE.UNSIGNED_BYTE,s.minFilter=t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR,s.magFilter=t.TEXTURE_FILTER.LINEAR,s.version++,g.roughnessMap=s}return _.userData.minHeight=h.minHeight,_.userData.maxHeight=h.maxHeight,"metadata"in m&&(_.userData.metadata=m.metadata.json),_;function w(e,t){return t.x=d.u[e],t.y=d.v[e],t.z=d.height[e],t}function P(e,r,s,n,u=0){const d=t.MathUtils.lerp(h.minHeight,h.maxHeight,s),p=t.MathUtils.lerp(l,c,e),m=t.MathUtils.lerp(o,a,r);return i.getCartographicToPosition(m,p,d+u,n),n}function S(e){const t=[],i=[],r=[],o=[],a=[];for(let n=0,a=e.length;n<a;n++)w(e[n],Ps),t.push(Ps.x,Ps.y),r.push(Ps.x,Ps.y),P(Ps.x,Ps.y,Ps.z,Ss),i.push(...Ss),P(Ps.x,Ps.y,Ps.z,Ss,-s),o.push(...Ss);const l=e.length-1;for(let t=0;t<l;t++){const i=t,r=t+1,s=t+e.length,n=t+e.length+1;a.push(i,s,r),a.push(r,s,n)}let c=null;if(b){const t=(i.length+o.length)/3;if(n){c=new Array(3*t);const i=m.octvertexnormals.normals,r=c.length/2;for(let s=0,n=t/2;s<n;s++){const t=e[s],n=3*s,o=i[3*t+0],a=i[3*t+1],l=i[3*t+2];c[n+0]=o,c[n+1]=a,c[n+2]=l,c[r+n+0]=o,c[r+n+1]=a,c[r+n+2]=l}}else{c=[],ws.a.fromArray(i,0),ws.b.fromArray(o,0),ws.c.fromArray(i,3),ws.getNormal(As);for(let e=0;e<t;e++)c.push(...As)}}return{uv:[...t,...r],positions:[...i,...o],indices:a,normals:c}}}clipToQuadrant(e,i,r){const s=new t.Vector3,n=new t.Vector3,o=new t.Vector3,a=new t.Vector3,l=new t.Vector3,c=new t.Vector3,h=new t.Vector3,u=new t.Vector3,d={},p=.5,m=new Es,f=["a","b","c"],{ellipsoid:g,skirtLength:_,solid:b,smoothSkirtNormals:y}=this,x=e.geometry,v=x.attributes.a_Normal,M=x.index;let T=0;const A={},w=[],P=v?[]:null,S=[],C=[],E=i?0:-.5,L=r?0:-.5,R=new t.Geometry,I=x.groups[0];for(let s=I.start/3;s<(I.start+I.count)/3;s++){const n=M.getX(3*s+0),o=M.getX(3*s+1),a=M.getX(3*s+2),l=m.get();l.setFromAttributeAndIndices(x,n,o,a);const c=[];O(l,"x",i,c);const h=[];for(let e=0,t=c.length;e<t;e++)O(c[e],"y",r,h);const{minLat:u,maxLat:g,minLon:_,maxLon:b,ellipsoid:y}=this;for(let i=0,r=h.length;i<r;i++){const r=h[i];f.forEach(i=>{const s=r.uv[i];if(s.x!==p&&s.y!==p)return;const n=r.position[i],o=t.MathUtils.lerp(u,g,s.y),a=t.MathUtils.lerp(_,b,s.x);n.add(e.position),y.getPositionToCartographic(n,d),y.getCartographicToPosition(o,a,d.height,n),n.sub(e.position)}),F(r.position.a,r.uv.a,r.normal.a),F(r.position.b,r.uv.b,r.normal.b),F(r.position.c,r.uv.c,r.normal.c)}m.reset()}const U=C.length/3;if(b)for(let t=3*U-1;t>=0;t--){const i=C[t];h.fromArray(w,3*i).add(e.position),g.getPositionToNormal(h,h),o.fromArray(w,3*i).addScaledVector(h,-_),s.fromArray(S,2*i),h.fromArray(P,3*i),F(o,s,h)}if(_>0)for(let t=0;t<U;t++){const i=3*t;for(let t=0;t<3;t++){const r=(t+1)%3,d=C[i+t],m=C[i+r];if(s.fromArray(S,2*d),n.fromArray(S,2*m),s.x===n.x&&(0===s.x||s.x===p||1===s.x)||s.y===n.y&&(0===s.y||s.y===p||1===s.y)){o.fromArray(w,3*d),a.fromArray(w,3*m);const t=o,i=a,r=l.copy(o),p=c.copy(a);h.copy(r).add(e.position),g.getPositionToNormal(h,h),r.addScaledVector(h,-_),h.copy(p).add(e.position),g.getPositionToNormal(h,h),p.addScaledVector(h,-_),y&&P?(h.fromArray(P,3*d),u.fromArray(P,3*m)):(h.subVectors(t,i),u.subVectors(t,r).cross(h).normalize(),h.copy(u)),F(i,n,u),F(t,s,h),F(r,s,h),F(i,n,u),F(r,s,h),F(p,n,u)}}}for(let e=0,t=S.length;e<t;e+=2)S[e]=2*(S[e]+E),S[e+1]=2*(S[e+1]+L);const D=w.length/3>65535?new Uint32Array(C):new Uint16Array(C);R.setIndex(new t.Attribute(new t.Buffer(D,1))),R.setAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array(w),3))),R.setAttribute("a_Uv",new t.Attribute(new t.Buffer(new Float32Array(S),2))),v&&R.setAttribute("a_Normal",new t.Attribute(new t.Buffer(new Float32Array(P),3)));const B=new t.Mesh(R,e.material.clone());return B.position.copy(e.position),B.quaternion.copy(e.quaternion),B.scale.copy(e.scale),B.userData.minHeight=e.userData.minHeight,B.userData.maxHeight=e.userData.maxHeight,B;function O(e,i,r,s){const n=[],o=[],a=[];for(let r=0;r<3;r++){const s=f[r],l=f[(r+1)%3],c=e.uv[s],h=e.uv[l],u=c[i],d=h[i];u<p==d<p&&u!==p||(n.push(r),o.push([s,l]),a.push(t.MathUtils.mapLinear(p,u,d,0,1)))}if(2!==n.length){Math.min(e.uv.a[i],e.uv.b[i],e.uv.c[i])<p===r&&s.push(e)}else if(2===n.length){const t=m.get(),l=m.get(),c=m.get();let h;(n[0]+1)%3===n[1]?(t.lerpVertex(e,o[0][0],o[0][1],a[0],"a"),t.copyVertex(e,o[0][1],"b"),t.lerpVertex(e,o[1][0],o[1][1],a[1],"c"),t.uv.a[i]=p,t.uv.c[i]=p,l.lerpVertex(e,o[0][0],o[0][1],a[0],"a"),l.copyVertex(e,o[1][1],"b"),l.copyVertex(e,o[0][0],"c"),l.uv.a[i]=p,c.lerpVertex(e,o[0][0],o[0][1],a[0],"a"),c.lerpVertex(e,o[1][0],o[1][1],a[1],"b"),c.copyVertex(e,o[1][1],"c"),c.uv.a[i]=p,c.uv.b[i]=p):(t.lerpVertex(e,o[0][0],o[0][1],a[0],"a"),t.lerpVertex(e,o[1][0],o[1][1],a[1],"b"),t.copyVertex(e,o[0][0],"c"),t.uv.a[i]=p,t.uv.b[i]=p,l.lerpVertex(e,o[0][0],o[0][1],a[0],"a"),l.copyVertex(e,o[0][1],"b"),l.lerpVertex(e,o[1][0],o[1][1],a[1],"c"),l.uv.a[i]=p,l.uv.c[i]=p,c.copyVertex(e,o[0][1],"a"),c.copyVertex(e,o[1][0],"b"),c.lerpVertex(e,o[1][0],o[1][1],a[1],"c"),c.uv.c[i]=p),h=Math.min(t.uv.a[i],t.uv.b[i],t.uv.c[i]),h<p===r&&s.push(t),h=Math.min(l.uv.a[i],l.uv.b[i],l.uv.c[i]),h<p===r&&s.push(l),h=Math.min(c.uv.a[i],c.uv.b[i],c.uv.c[i]),h<p===r&&s.push(c)}}function V(e,t,i){const r=1e5;return`${~~(e*r+.5)}_${~~(t*r+.5)}_${~~(i*r+.5)}`}function F(e,t,i){let r=V(e.x,e.y,e.z);P&&(r+=`_${V(i.x,i.y,i.z)}`),r in A||(A[r]=T,T++,w.push(e.x,e.y,e.z),S.push(t.x,t.y),P&&P.push(i.x,i.y,i.z));const s=A[r];return C.push(s),s}}}class Es{constructor(){this.pool=[],this.index=0}get(){if(this.index>=this.pool.length){const e=new Ls;this.pool.push(e)}const e=this.pool[this.index];return this.index++,e}reset(){this.index=0}}class Ls{constructor(){this.position=new t.Triangle,this.uv=new t.Triangle,this.normal=new t.Triangle}setFromAttributeAndIndices(e,t,i,r){this.position.setFromAttributeAndIndices(e.attributes.a_Position,t,i,r),this.uv.setFromAttributeAndIndices(e.attributes.a_Uv,t,i,r),e.attributes.a_Normal&&this.normal.setFromAttributeAndIndices(e.attributes.a_Normal,t,i,r)}lerpVertex(e,t,i,r,s){this.position[s].lerpVectors(e.position[t],e.position[i],r),this.uv[s].lerpVectors(e.uv[t],e.uv[i],r),this.normal[s].lerpVectors(e.normal[t],e.normal[i],r)}copyVertex(e,t,i){this.position[i].copy(e.position[t]),this.uv[i].copy(e.uv[t]),this.normal[i].copy(e.normal[t])}}const Rs=Symbol("TILE_X"),Is=Symbol("TILE_Y"),Us=Symbol("TILE_LEVEL"),Ds=Symbol("TILE_AVAILABLE"),Bs=1e4,Os=new t.Vector3;function Vs(e){const{available:t=null,maxzoom:i=null}=e;return null===i?t.length-1:i}function Fs(e,t){const i=e[Us],r=function(e){const{metadataAvailability:t=-1}=e;return t}(t);return i<Vs(t)&&-1!==r&&i%r===0}class ks{constructor(e={}){const{useRecommendedSettings:t=!0,skirtLength:i=null,smoothSkirtNormals:r=!0,solid:s=!1}=e;this.name="QUANTIZED_MESH_PLUGIN",this.tiles=null,this.layer=null,this.useRecommendedSettings=t,this.skirtLength=i,this.smoothSkirtNormals=r,this.solid=s,this.attribution=null,this.tiling=new gs,this.projection=new ds}init(e){e.fetchOptions.headers=e.fetchOptions.headers||{},e.fetchOptions.headers.Accept="application/vnd.quantized-mesh,application/octet-stream;q=0.9",this.useRecommendedSettings&&(e.errorTarget=2),this.tiles=e}loadRootTileSet(){const{tiles:e}=this;let t=new URL("layer.json",new URL(e.rootURL,location.href));return e.invokeAllPlugins(e=>t=e.preprocessURL?e.preprocessURL(t,null):t),e.invokeOnePlugin(e=>e.fetchData&&e.fetchData(t,this.tiles.fetchOptions)).then(e=>e.json()).then(e=>{this.layer=e;const{projection:t="EPSG:4326",extensions:i=[],attribution:r="",available:s=null}=e,{tiling:n,tiles:o,projection:a}=this;r&&(this.attribution={value:r,type:"string",collapsible:!0}),i.length>0&&(o.fetchOptions.headers.Accept+=`;extensions=${i.join("-")}`),a.setScheme(t);const{tileCountX:l,tileCountY:c}=a;n.setProjection(a),n.generateLevels(Vs(e)+1,l,c);const h=[];for(let e=0;e<l;e++){const t=this.createChild(0,e,0,s);t&&h.push(t)}const u={asset:{version:"1.1"},geometricError:1/0,root:{refine:"REPLACE",geometricError:1/0,boundingVolume:{region:[...this.tiling.getFullBounds(),-1e4,Bs]},children:h,[Ds]:s,[Us]:-1}};let d=o.rootURL;return o.invokeAllPlugins(e=>d=e.preprocessURL?e.preprocessURL(d,null):d),o.preprocessTileSet(u,d),u})}async parseToMesh(e,t,i,r){const{skirtLength:s,solid:n,smoothSkirtNormals:o,tiles:a}=this,l=a.ellipsoid,c=new Cs(a.manager);let h;if(c.ellipsoid.copy(l),c.solid=n,c.smoothSkirtNormals=o,c.skirtLength=null===s?t.geometricError:s,"tile_split"===i){const e=new URL(r).searchParams,i="true"===e.get("left"),s="true"===e.get("bottom"),[n,o,a,l]=t.parent.boundingVolume.region;c.minLat=o,c.maxLat=l,c.minLon=n,c.maxLon=a,h=c.clipToQuadrant(t.parent.cached.scene,i,s)}else{const[i,r,s,n]=t.boundingVolume.region;c.minLat=r,c.maxLat=n,c.minLon=i,c.maxLon=s,h=c.parse(e)}const{minHeight:u,maxHeight:d,metadata:p}=h.userData;if(t.boundingVolume.region[4]=u,t.boundingVolume.region[5]=d,t.cached.boundingVolume.setRegionData(l,...t.boundingVolume.region),p){"geometricerror"in p&&(t.geometricError=p.geometricerror);Fs(t,this.layer)&&"available"in p&&0===t.children.length&&(t[Ds]=[...new Array(t[Us]+1).fill(null),...p.available])}return this.expandChildren(t),h}getAttributions(e){this.attribution&&e.push(this.attribution)}createChild(e,t,i,r){const{tiles:s,layer:n,tiling:o,projection:a}=this,l=s.ellipsoid,c=null===r||function(e,t,i,r){if(t<e.length){const s=e[t];for(let e=0,t=s.length;e<t;e++){const{startX:t,startY:n,endX:o,endY:a}=s[e];if(i>=t&&i<=o&&r>=n&&r<=a)return!0}}return!1}(r,e,t,i),h=function(e,t,i,r,s){return s.tiles[0].replace(/{\s*z\s*}/g,i).replace(/{\s*x\s*}/g,e).replace(/{\s*y\s*}/g,t).replace(/{\s*version\s*}/g,r)}(t,i,e,1,n),u=[...o.getTileBounds(t,i,e),-1e4,Bs],[,d,,p,,m]=u,f=d>0!=p>0?0:Math.min(Math.abs(d),Math.abs(p));l.getCartographicToPosition(f,0,m,Os),Os.z=0;const g=a.tileCountX,_=2*Math.max(l.radius.x,l.radius.y,l.radius.z)*Math.PI*.25/(65*g)/2**e,b={[Ds]:null,[Us]:e,[Rs]:t,[Is]:i,refine:"REPLACE",geometricError:_,boundingVolume:{region:u},content:c?{uri:h}:null,children:[]};return Fs(b,n)||(b[Ds]=r),b}expandChildren(e){const t=e[Us],i=e[Rs],r=e[Is],s=e[Ds];let n=!1;for(let o=0;o<2;o++)for(let a=0;a<2;a++){const l=this.createChild(t+1,2*i+o,2*r+a,s);null!==l.content?(e.children.push(l),n=!0):(e.children.push(l),l.content={uri:`tile.tile_split?bottom=${0===a}&left=${0===o}`})}n||(e.children.length=0)}fetchData(e,t){if(/tile_split/.test(e))return new ArrayBuffer}disposeTile(e){Fs(e,this.layer)&&(e.children.length=0,e.__childrenProcessed=0,e[Ds]=null),e.children.length=0,e.__childrenProcessed=0}}class Ns extends t.Mesh{constructor(e,i=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new t.Geometry;s.setIndex(new t.Attribute(new t.Buffer(r,1))),s.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1]),3))),s.computeBoundingSphere();const n=new t.LineMaterial;n.diffuse.setHex(i),super(s,n),this.box=e}updateMatrix(e){const t=this.box;t.getCenter(this.position),t.isEmpty()?this.scale.multiplyScalar(0):(t.getSize(this.scale),this.scale.multiplyScalar(.5)),super.updateMatrix(e)}}Ns.prototype.isBox3Helper=!0;class zs extends t.Mesh{constructor(e,i=16776960,r=40){const s=[];for(let e=0;e<3;e++){const t=Hs[e],i=Hs[(e+1)%3];Gs.set(0,0,0);for(let e=0;e<r;e++){let n;n=2*Math.PI*e/(r-1),Gs[t]=Math.sin(n),Gs[i]=Math.cos(n),s.push(Gs.x,Gs.y,Gs.z),n=2*Math.PI*(e+1)/(r-1),Gs[t]=Math.sin(n),Gs[i]=Math.cos(n),s.push(Gs.x,Gs.y,Gs.z)}}const n=new t.Geometry;n.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array(s),3))),n.computeBoundingSphere();const o=new t.LineMaterial;o.diffuse.setHex(i),super(n,o),this.sphere=e}updateMatrix(e){const t=this.sphere;this.position.copy(t.center),t.isEmpty()?this.scale.setScalar(0):this.scale.setScalar(t.radius),super.updateMatrix(e)}}zs.prototype.isSphereHelper=!0;const Gs=new t.Vector3,Hs=["x","y","z"],js=function(e,t,i={}){const r=void 0!==i.thresholdAngle?i.thresholdAngle:1,s=void 0!==i.stride?i.stride:3,n=void 0!==i.offset?i.offset:0;let o,a,l,c,h;const u=[],d={},p=[],m=[],f=Math.pow(10,4);let g,_,b,y;for(l=e.length/s,o=0;o<l;o++)g=o*s+n,_=e[g+0],b=e[g+1],y=e[g+2],c=Math.round(_*f)+"_"+Math.round(b*f)+"_"+Math.round(y*f),void 0===d[c]?(d[c]=o,p.push(_,b,y),m[o]=p.length/3-1):m[o]=m[d[c]];const x=[];if(t)for(l=t.length/3,o=0;o<l;o++)h={i:[0,0,0],n:[1,1,1]},h.i[0]=m[t[3*o+0]],h.i[1]=m[t[3*o+1]],h.i[2]=m[t[3*o+2]],Ks(h,p),x.push(h);else for(o=0;o<l;o++)h={i:[0,0,0],n:[1,1,1]},h.i[0]=m[3*o+0],h.i[1]=m[3*o+1],h.i[2]=m[3*o+2],Ks(h,p),x.push(h);let v,M;const T=[0,0],A={};for(o=0,l=x.length;o<l;o++)for(h=x[o],a=0;a<3;a++)v=h.i[a],M=h.i[(a+1)%3],T[0]=Math.min(v,M),T[1]=Math.max(v,M),c=T[0]+","+T[1],void 0===A[c]?A[c]={index1:T[0],index2:T[1],face1:o,face2:void 0}:A[c].face2=o;const w=Math.cos(qs*r);for(c in A){const e=A[c];(void 0===e.face2||Xs(x[e.face1].n,x[e.face2].n)<=w)&&u.push(p[3*e.index1+0],p[3*e.index1+1],p[3*e.index1+2],p[3*e.index2+0],p[3*e.index2+1],p[3*e.index2+2])}return{positions:u}};function Xs(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Ks(e,t){const i=t[3*e.i[0]+0],r=t[3*e.i[0]+1],s=t[3*e.i[0]+2],n=t[3*e.i[1]+0],o=t[3*e.i[1]+1],a=t[3*e.i[1]+2],l=t[3*e.i[2]+0]-n,c=t[3*e.i[2]+1]-o,h=t[3*e.i[2]+2]-a,u=i-n,d=r-o,p=s-a;let m=c*p-h*d,f=h*u-l*p,g=l*d-c*u;const _=Math.sqrt(m*m+f*f+g*g);m/=_,f/=_,g/=_,e.n[0]=m,e.n[1]=f,e.n[2]=g}const qs=Math.PI/180,$s=new t.Vector3;class Ys extends t.Mesh{constructor(e=new ei,i=16776960){super(new t.Geometry,new t.LineMaterial),this.ellipsoidRegion=e,this.material.diffuse.setHex(i),this.update(),this.raycast=()=>{}}update(){this.geometry.dispose();const e=function(e){const{latRange:i,lonRange:r,heightRange:s}=e,{x:n,y:o}=i,{x:a,y:l}=r,{x:c,y:h}=s,u=new t.BoxGeometry(1,1,1,32,32),{a_Position:d}=u.attributes;for(let i=0,r=d.buffer.count;i<r;i++){$s.fromArray(d.buffer.array,3*i);const r=t.MathUtils.mapLinear($s.x,-.5,.5,n,o),s=t.MathUtils.mapLinear($s.y,-.5,.5,a,l);let u=c;$s.z<0&&(u=h),e.getCartographicToPosition(r,s,u,$s),$s.toArray(d.buffer.array,3*i)}return u}(this.ellipsoidRegion),{positions:i}=js(e.attributes.a_Position.buffer.array,e.index.buffer.array,{thresholdAngle:80}),r=new t.Geometry;r.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array(i),3))),this.geometry=r,this.geometry.computeBoundingBox(),this.geometry.computeBoundingSphere()}dispose(){this.geometry.dispose(),this.material.dispose()}}const Ws=Symbol("ORIGINAL_MATERIAL"),Qs=Symbol("HAS_RANDOM_COLOR"),Zs=Symbol("HAS_RANDOM_NODE_COLOR"),Js=Symbol("LOAD_TIME"),en=Symbol("PARENT_BOUND_REF_COUNT"),tn=new t.Sphere,rn=()=>{},sn={};function nn(e){if(!sn[e]){const i=Math.random(),r=.5+.5*Math.random(),s=.375+.25*Math.random();sn[e]=(new t.Color3).setHSL(i,r,s)}return sn[e]}const on=Object.freeze({NONE:0,SCREEN_ERROR:1,GEOMETRIC_ERROR:2,DISTANCE:3,DEPTH:4,RELATIVE_DEPTH:5,IS_LEAF:6,RANDOM_COLOR:7,RANDOM_NODE_COLOR:8,CUSTOM_COLOR:9,LOAD_ORDER:10});const an=new t.Sphere,ln=new t.Vector3;const cn=new t.Quaternion;t.Vector3.prototype.applyEuler=function(e){return this.applyQuaternion(cn.setFromEuler(e))},t.Vector3.prototype.applyAxisAngle=function(e,t){return this.applyQuaternion(cn.setFromAxisAngle(e,t))},t.Triangle.prototype.setFromAttributeAndIndices=function(e,t,i,r){const s=e.buffer.array,n=e.size,o=e.offset;this.a.fromArray(s,t*n+o),this.b.fromArray(s,i*n+o),this.c.fromArray(s,r*n+o)},t.Object3D.prototype.removeFromParent=function(){const e=this.parent;return null!==e&&e.remove(this),this},t.MathUtils.DEG2RAD=Math.PI/180,t.MathUtils.RAD2DEG=180/Math.PI;const hn=t.Camera.prototype.setOrtho;t.Camera.prototype.setOrtho=function(e,t,i,r,s,n){this.left=e,this.right=t,this.bottom=i,this.top=r,this.near=s,this.far=n,this.zoom=1,this.isPerspectiveCamera=!1,this.isOrthographicCamera=!0,hn.call(this,e,t,i,r,s,n)};const un=t.Camera.prototype.setPerspective;t.Camera.prototype.setPerspective=function(e,t,i,r){this.fov=e,this.aspect=t,this.near=i,this.far=r,this.isPerspectiveCamera=!0,this.isOrthographicCamera=!1,un.call(this,e,t,i,r)},t.Camera.prototype.updateProjectionMatrix=function(){return this.isOrthographicCamera?this.setOrtho(this.left,this.right,this.bottom,this.top,this.near,this.far):this.isPerspectiveCamera&&this.setPerspective(this.fov,this.aspect,this.near,this.far),this},e.B3DMLoader=Ee,e.CMPTLoader=at,e.CesiumIonAuthPlugin=class{get apiToken(){return this.auth.apiToken}set apiToken(e){this.auth.apiToken=e}get autoRefreshToken(){return this.auth.autoRefreshToken}set autoRefreshToken(e){this.auth.autoRefreshToken=e}constructor({apiToken:e,assetId:t=null,autoRefreshToken:i=!1,useRecommendedSettings:r=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.auth=new Kr({apiToken:e,autoRefreshToken:i}),this.assetId=t,this.autoRefreshToken=i,this.useRecommendedSettings=r,this.tiles=null,this._tileSetVersion=-1,this._attributions=[]}init(e){null!==this.assetId&&(e.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=e,this.auth.authURL=e.rootURL,e.resetFailedTiles()}loadRootTileSet(){return this.auth.refreshToken().then(e=>(this._initializeFromAsset(e),this.tiles.invokeOnePlugin(e=>e!==this&&e.loadRootTileSet&&e.loadRootTileSet()))).catch(e=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:e,url:this.auth.authURL})})}preprocessURL(e){return(e=new URL(e)).toString()}fetchData(e,t){return null!==this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")?null:this.auth.fetch(e,t)}getAttributions(e){this.tiles.visibleTiles.size>0&&e.push(...this._attributions)}_initializeFromAsset(e){const t=this.tiles;if("externalType"in e){const i=new URL(e.options.url);t.rootURL=e.options.url,t.registerPlugin(new Qr({apiToken:i.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{"TERRAIN"===e.type&&null===t.getPluginByName("QUANTIZED_MESH_PLUGIN")?t.registerPlugin(new ks({useRecommendedSettings:this.useRecommendedSettings})):"IMAGERY"===e.type&&null===t.getPluginByName("TMS_TILES_PLUGIN")&&t.registerPlugin(new xs({useRecommendedSettings:this.useRecommendedSettings,shape:"ellipsoid"})),t.rootURL=e.url;const i=new URL(e.url);i.searchParams.has("v")&&-1===this._tileSetVersion&&(this._tileSetVersion=i.searchParams.get("v")),e.attributions&&(this._attributions=e.attributions.map(e=>({value:e.html,type:"html",collapsible:e.collapsible})))}}},e.DebugLoadParser=class{static parse(e,t){let i=null;return i="gltf"===h(e.url)?t.loadFile(e.url).then(t=>{e.options.buffer=t}):t.loadFile(e.url,"arraybuffer").then(t=>{e.options.buffer=t}),i}},e.DebugTilesPlugin=class{static get ColorModes(){return on}get unlit(){return this._unlit}set unlit(e){e!==this._unlit&&(this._unlit=e,this.materialsNeedUpdate=!0)}get colorMode(){return this._colorMode}set colorMode(e){e!==this._colorMode&&(this._colorMode=e,this.materialsNeedUpdate=!0)}constructor(e){e={displayParentBounds:!1,displayBoxBounds:!1,displaySphereBounds:!1,displayRegionBounds:!1,colorMode:0,maxDebugDepth:-1,maxDebugDistance:-1,maxDebugError:-1,customColorCallback:null,unlit:!1,enabled:!0,...e},this.name="DEBUG_TILES_PLUGIN",this.tiles=null,this._colorMode=null,this._unlit=null,this.materialsNeedUpdate=!1,this.extremeDebugDepth=-1,this.extremeDebugError=-1,this.boxGroup=null,this.sphereGroup=null,this.regionGroup=null,this._enabled=e.enabled,this._displayParentBounds=e.displayParentBounds,this.displayBoxBounds=e.displayBoxBounds,this.displaySphereBounds=e.displaySphereBounds,this.displayRegionBounds=e.displayRegionBounds,this.colorMode=e.colorMode,this.maxDebugDepth=e.maxDebugDepth,this.maxDebugDistance=e.maxDebugDistance,this.maxDebugError=e.maxDebugError,this.customColorCallback=e.customColorCallback,this.unlit=e.unlit,this.getDebugColor=(e,t)=>{t.setRGB(e,e,e)}}get enabled(){return this._enabled}set enabled(e){e!==this._enabled&&null!==this.tiles&&(e?this.init(this.tiles):this.dispose()),this._enabled=e}get displayParentBounds(){return this._displayParentBounds}set displayParentBounds(e){this._displayParentBounds!==e&&(this._displayParentBounds=e,e?this.tiles.traverse(e=>{e.__visible&&this._onTileVisibilityChange(e,!0)}):T(this.tiles.root,null,e=>{e[en]=null,this._onTileVisibilityChange(e,e.__visible)}))}init(e){if(this.tiles=e,!this.enabled)return;const i=e.group;this.boxGroup=new t.Object3D,this.boxGroup.name="DebugTilesPlugin.boxGroup",i.add(this.boxGroup),this.boxGroup.updateMatrix(),this.sphereGroup=new t.Object3D,this.sphereGroup.name="DebugTilesPlugin.sphereGroup",i.add(this.sphereGroup),this.sphereGroup.updateMatrix(),this.regionGroup=new t.Object3D,this.regionGroup.name="DebugTilesPlugin.regionGroup",i.add(this.regionGroup),this.regionGroup.updateMatrix(),this._onLoadTileSetCB=()=>{this._initExtremes()},this._onLoadModelCB=({scene:e,tile:t})=>{this._onLoadModel(e,t)},this._onDisposeModelCB=({tile:e})=>{this._onDisposeModel(e)},this._onUpdateAfterCB=()=>{this._onUpdateAfter()},this._onTileVisibilityChangeCB=({scene:e,tile:t,visible:i})=>{this._onTileVisibilityChange(t,i)},e.addEventListener("load-tile-set",this._onLoadTileSetCB),e.addEventListener("load-model",this._onLoadModelCB),e.addEventListener("dispose-model",this._onDisposeModelCB),e.addEventListener("update-after",this._onUpdateAfterCB),e.addEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this._initExtremes(),e.traverse(e=>{e.cached.scene&&this._onLoadModel(e.cached.scene,e)}),e.visibleTiles.forEach(e=>{this._onTileVisibilityChange(e,!0)})}getTileInformationFromActiveObject(e){let t=null;return this.tiles.activeTiles.forEach(i=>{if(t)return!0;const r=i.cached.scene;r&&r.traverse(r=>{r===e&&(t=i)})}),t?{distanceToCamera:t.__distanceFromCamera,geometricError:t.geometricError,screenSpaceError:t.__error,depth:t.__depth,isLeaf:t.__isLeaf}:null}_initExtremes(){if(!this.tiles||!this.tiles.root)return;let e=-1,t=-1;T(this.tiles.root,null,(i,r,s)=>{e=Math.max(e,s),t=Math.max(t,i.geometricError)}),this.extremeDebugDepth=e,this.extremeDebugError=t}_onUpdateAfter(){const{tiles:e,colorMode:t}=this;if(!e.root)return;this.materialsNeedUpdate&&(e.forEachLoadedModel(e=>{this._updateMaterial(e)}),this.materialsNeedUpdate=!1),this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds,this.regionGroup.visible=this.displayRegionBounds;let i=-1;i=-1===this.maxDebugDepth?this.extremeDebugDepth:this.maxDebugDepth;let r=-1;r=-1===this.maxDebugError?this.extremeDebugError:this.maxDebugError;let s=-1;-1===this.maxDebugDistance?(e.getBoundingSphere(tn),s=tn.radius):s=this.maxDebugDistance;const{errorTarget:n,visibleTiles:o}=e;let a;10===t&&(a=Array.from(o).sort((e,t)=>e[Js]-t[Js])),o.forEach(e=>{const o=e.cached.scene;let l,c,h;7===t&&(l=Math.random(),c=.5+.5*Math.random(),h=.375+.25*Math.random()),o.traverse(o=>{if(8===t&&(l=Math.random(),c=.5+.5*Math.random(),h=.375+.25*Math.random()),o.material)switch(7!==t&&delete o.material[Qs],8!==t&&delete o.material[Zs],t){case 4:{const t=e.__depth/i;this.getDebugColor(t,o.material.diffuse);break}case 5:{const t=e.__depthFromRenderedParent/i;this.getDebugColor(t,o.material.diffuse);break}case 1:{const t=e.__error/n;t>1?o.material.diffuse.setRGB(1,0,0):this.getDebugColor(t,o.material.diffuse);break}case 2:{const t=Math.min(e.geometricError/r,1);this.getDebugColor(t,o.material.diffuse);break}case 3:{const t=Math.min(e.__distanceFromCamera/s,1);this.getDebugColor(t,o.material.diffuse);break}case 6:e.children&&0!==e.children.length?this.getDebugColor(0,o.material.diffuse):this.getDebugColor(1,o.material.diffuse);break;case 8:o.material[Zs]||(o.material.diffuse.setHSL(l,c,h),o.material[Zs]=!0);break;case 7:o.material[Qs]||(o.material.diffuse.setHSL(l,c,h),o.material[Qs]=!0);break;case 9:this.customColorCallback?this.customColorCallback(e,o):console.warn("DebugTilesPlugin: customColorCallback not defined");break;case 10:{const t=a.indexOf(e);this.getDebugColor(t/(a.length-1),o.material.diffuse);break}}})})}_onTileVisibilityChange(e,t){this.displayParentBounds?function(e,t=null){let i=e;for(;i;){const e=i.__depth,r=i.parent;t&&t(i,r,e),i=r}}(e,i=>{null==i[en]&&(i[en]=0),t?i[en]++:i[en]>0&&i[en]--;const r=i===e&&t||this.displayParentBounds&&i[en]>0;this._updateBoundHelper(i,r)}):this._updateBoundHelper(e,t)}_createBoundHelper(e){const i=this.tiles,r=e.cached,{sphere:s,obb:n,region:o}=r.boundingVolume;if(n){const s=new t.Object3D;s.name="DebugTilesPlugin.boxHelperGroup",s.matrix.copy(n._originBoxTransform),s.matrixAutoUpdate=!1,s.matrixNeedsUpdate=!1;const o=new Ns(n._originBox,nn(e.__depth).getHex());o.raycast=rn,s.add(o),r.boxHelperGroup=s,i.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(s),s.updateMatrix(!0))}if(s){const t=new zs(s,nn(e.__depth).getHex());t.raycast=rn,r.sphereHelper=t,i.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(t),t.updateMatrix(!0))}if(o){const t=new Ys(o,nn(e.__depth).getHex());t.raycast=rn,r.regionHelper=t,i.visibleTiles.has(e)&&this.displayRegionBounds&&(this.regionGroup.add(t),t.updateMatrix(!0))}}_updateHelperMaterial(e,t){e.__visible||!this.displayParentBounds?t.opacity=1:t.opacity=.2,t.transparent=t.opacity<1}_updateBoundHelper(e,t){const i=e.cached;if(!i)return;const r=this.sphereGroup,s=this.boxGroup,n=this.regionGroup;t&&null==i.boxHelperGroup&&null==i.sphereHelper&&null==i.regionHelper&&this._createBoundHelper(e);const o=i.boxHelperGroup,a=i.sphereHelper,l=i.regionHelper;t?(o&&(s.add(o),o.updateMatrix(!0),this._updateHelperMaterial(e,o.children[0].material)),a&&(r.add(a),a.updateMatrix(!0),this._updateHelperMaterial(e,a.material)),l&&(n.add(l),l.updateMatrix(!0),this._updateHelperMaterial(e,l.material))):(o&&s.remove(o),a&&r.remove(a),l&&n.remove(l))}_updateMaterial(e){const{colorMode:i,unlit:r}=this;e.traverse(e=>{if(!e.material)return;const s=e.material,n=e[Ws];if(s!==n&&s.dispose(),0!==i||r){if(e.material.drawMode===t.DRAW_MODE.POINTS){const i=new t.PointsMaterial;i.size=n.size,i.sizeAttenuation=n.sizeAttenuation,e.material=i}else e.geometry.instanceCount>=0?(e.material=r?new Oe:new De,e.material.metalness=0,e.material.roughness=1,e.material.shading=r?t.SHADING_TYPE.SMOOTH_SHADING:t.SHADING_TYPE.FLAT_SHADING):(e.material=r?new t.BasicMaterial:new t.PBRMaterial,e.material.metalness=0,e.material.roughness=1,e.material.shading=r?t.SHADING_TYPE.SMOOTH_SHADING:t.SHADING_TYPE.FLAT_SHADING);e.material.envMap=void 0,0===i&&(e.material.diffuseMap=n.diffuseMap,e.material.diffuse.setRGB(n.diffuse))}else e.material=n})}_onLoadModel(e,t){t[Js]=performance.now(),e.traverse(e=>{const t=e.material;t&&(e[Ws]=t)}),this._updateMaterial(e)}_onDisposeModel(e){const t=e.cached;t.boxHelperGroup&&(t.boxHelperGroup.children[0].geometry.dispose(),delete t.boxHelperGroup),t.sphereHelper&&(t.sphereHelper.geometry.dispose(),delete t.sphereHelper),t.regionHelper&&(t.regionHelper.geometry.dispose(),delete t.regionHelper)}dispose(){if(!this.enabled)return;const e=this.tiles;e.removeEventListener("load-tile-set",this._onLoadTileSetCB),e.removeEventListener("load-model",this._onLoadModelCB),e.removeEventListener("dispose-model",this._onDisposeModelCB),e.removeEventListener("update-after",this._onUpdateAfterCB),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this.colorMode=0,this.unlit=!1,e.forEachLoadedModel(e=>{this._updateMaterial(e)}),e.traverse(e=>{this._onDisposeModel(e)}),this.boxGroup?.removeFromParent(),this.sphereGroup?.removeFromParent(),this.regionGroup?.removeFromParent()}},e.EnvironmentControls=xr,e.GlobeControls=class extends xr{get tilesGroup(){return console.warn('GlobeControls: "tilesGroup" has been deprecated. Use "ellipsoidGroup", instead.'),this.ellipsoidFrame}get ellipsoidFrame(){return this.ellipsoidGroup.worldMatrix}get ellipsoidFrameInverse(){const{ellipsoidGroup:e,ellipsoidFrame:t,_ellipsoidFrameInverse:i}=this;return e.worldMatrixInverse?e.worldMatrixInverse:i.copy(t).invert()}constructor(e=null,i=null,r=null,s=null){super(e,i,r),this.isGlobeControls=!0,this._dragMode=0,this._rotationMode=0,this.maxZoom=.01,this.nearMargin=.25,this.farMargin=0,this.useFallbackPlane=!1,this.autoAdjustCameraRotation=!1,this.globeInertia=new t.Quaternion,this.globeInertiaFactor=0,this.ellipsoid=Mi.clone(),this.ellipsoidGroup=new t.Object3D,this._ellipsoidFrameInverse=new t.Matrix4,null!==s&&this.setTilesRenderer(s)}setTilesRenderer(e){super.setTilesRenderer(e),null!==e&&this.setEllipsoid(e.ellipsoid,e.group)}setEllipsoid(e,i){this.ellipsoid=e||Mi.clone(),this.ellipsoidGroup=i||new t.Object3D}getPivotPoint(e){const{camera:t,ellipsoidFrame:i,ellipsoidFrameInverse:r,ellipsoid:s}=this;return Pr.set(0,0,-1).transformDirection(t.worldMatrix),Ir.origin.copy(t.position),Ir.direction.copy(Pr),Ir.applyMatrix4(r),ji(Ir,s,Ar),Ar.applyMatrix4(i),(null===super.getPivotPoint(e)||Tr.subVectors(e,Ir.origin).dot(Ir.direction)>Tr.subVectors(Ar,Ir.origin).dot(Ir.direction))&&e.copy(Ar),e}getVectorToCenter(e){const{ellipsoidFrame:t,camera:i}=this;return e.setFromMatrixPosition(t).sub(i.position)}getDistanceToCenter(){return this.getVectorToCenter(Ar).getLength()}getUpDirection(e,t){const{ellipsoidFrame:i,ellipsoidFrameInverse:r,ellipsoid:s}=this;Ar.copy(e).applyMatrix4(r),s.getPositionToNormal(Ar,t),t.transformDirection(i)}getCameraUpDirection(e){const{ellipsoidFrame:t,ellipsoidFrameInverse:i,ellipsoid:r,camera:s}=this;s.isOrthographicCamera?(this._getVirtualOrthoCameraPosition(Ar),Ar.applyMatrix4(i),r.getPositionToNormal(Ar,e),e.transformDirection(t)):this.getUpDirection(s.position,e)}update(e=.064){if(!this.enabled||!this.camera||0===e)return;const{camera:t,pivotMesh:i}=this;this._isNearControls()?this.scaleZoomOrientationAtEdges=this.zoomDelta<0:(0!==this.state&&1!==this._dragMode&&1!==this._rotationMode&&(i.visible=!1),this.scaleZoomOrientationAtEdges=!1);const r=this.needsUpdate||this._inertiaNeedsUpdate();super.update(e),this.adjustCamera(t),r&&this._isNearControls()&&(this.getCameraUpDirection(Cr),this._alignCameraUp(Cr,1),this.getCameraUpDirection(Cr),this._clampRotation(Cr))}adjustCamera(e){super.adjustCamera(e);const{ellipsoidFrame:i,ellipsoidFrameInverse:r,ellipsoid:s,nearMargin:n,farMargin:o}=this,a=Math.max(...s.radius);if(e.isPerspectiveCamera){const l=Ar.setFromMatrixPosition(i).sub(e.position).getLength(),c=n*a,h=t.MathUtils.clamp((l-a)/c,0,1),u=t.MathUtils.lerp(1,1e3,h);e.near=Math.max(u,l-a-c),Tr.copy(e.position).applyMatrix4(r),s.getPositionToCartographic(Tr,Br);const d=Math.max(s.getPositionElevation(Tr),2550),p=s.calculateHorizonDistance(Br.lat,d);e.far=p+.1+a*o,e.updateProjectionMatrix()}else{this._getVirtualOrthoCameraPosition(e.position,e),e.updateMatrix(),vr.copy(e.worldMatrix).invert(),Ar.setFromMatrixPosition(i).applyMatrix4(vr);const t=-Ar.z;e.near=t-a*(1+n),e.far=t+.1+a*o,e.position.addScaledVector(Pr,e.near),e.far-=e.near,e.near=0,e.updateProjectionMatrix(),e.updateMatrix()}}setState(...e){super.setState(...e),this._dragMode=0,this._rotationMode=0}_updateInertia(e){super._updateInertia(e);const{globeInertia:t,enableDamping:i,dampingFactor:r,camera:s,cameraRadius:n,minDistance:o,inertiaTargetDistance:a,ellipsoidFrame:l}=this;if(!this.enableDamping||this.inertiaStableFrames>1)return this.globeInertiaFactor=0,void this.globeInertia.identity();const c=Math.pow(2,-e/r),h=Math.max(s.near,n,o,a),u=25e-5;if(wr.setFromMatrixPosition(l),0!==this.globeInertiaFactor){Xi(Ir,Ar.set(0,0,-1),s),Ir.applyMatrix4(s.viewMatrix),Ir.direction.normalize(),Ir.recast(-Ir.direction.dot(Ir.origin)).at(h/Ir.direction.z,Ar),Ar.applyMatrix4(s.worldMatrix),Xi(Ir,Tr.set(u,u,-1),s),Ir.applyMatrix4(s.viewMatrix),Ir.direction.normalize(),Ir.recast(-Ir.direction.dot(Ir.origin)).at(h/Ir.direction.z,Tr),Tr.applyMatrix4(s.worldMatrix),Ar.sub(wr).normalize(),Tr.sub(wr).normalize(),this.globeInertiaFactor*=c;const r=Ar.angleTo(Tr)/e;(2*Math.acos(t.w)*this.globeInertiaFactor<r||!i)&&(this.globeInertiaFactor=0,t.identity())}0!==this.globeInertiaFactor&&(1!==t.w||0===t.x&&0===t.y&&0===t.z||(t.w=Math.min(t.w,1-1e-9)),wr.setFromMatrixPosition(l),Er.identity().slerp(t,this.globeInertiaFactor*e),Gi(wr,Er,Mr),s.worldMatrix.premultiply(Mr),s.worldMatrix.decompose(s.position,s.quaternion,Ar))}_inertiaNeedsUpdate(){return super._inertiaNeedsUpdate()||0!==this.globeInertiaFactor}_updatePosition(e){if(1===this.state){0===this._dragMode&&(this._dragMode=this._isNearControls()?1:-1);const{raycaster:t,camera:i,pivotPoint:r,pointerTracker:s,domElement:n,ellipsoidFrame:o,ellipsoidFrameInverse:a}=this,l=Tr,c=Sr;s.getCenterPoint(Dr),Hi(Dr.x,Dr.y,n,Dr),Xi(t,Dr,i),t.ray.applyMatrix4(a);const h=Ar.copy(r).applyMatrix4(vr).getLength();if(Ur.radius.setScalar(h),!Ur.intersectRay(t.ray,Ar))return this.resetState(),void this._updateInertia(e);Ar.applyMatrix4(o),wr.setFromMatrixPosition(o),l.subVectors(r,wr).normalize(),c.subVectors(Ar,wr).normalize(),Er.setFromUnitVectors(c,l),Gi(wr,Er,Mr),i.worldMatrix.premultiply(Mr),i.worldMatrix.decompose(i.position,i.quaternion,Ar),s.getMoveDistance()/e<2*window.devicePixelRatio?this.inertiaStableFrames++:(this.globeInertia.copy(Er),this.globeInertiaFactor=1/e,this.inertiaStableFrames=0)}}_updateRotation(...e){1===this._rotationMode||this._isNearControls()?(this._rotationMode=1,super._updateRotation(...e)):(this.pivotMesh.visible=!1,this._rotationMode=-1)}_updateZoom(){const{zoomDelta:e,ellipsoid:i,zoomSpeed:r,zoomPoint:s,camera:n,maxZoom:o,state:a}=this;if(3!==a&&0===e)return;this.rotationInertia.set(0,0),this.dragInertia.set(0,0,0),this.globeInertia.identity(),this.globeInertiaFactor=0;const l=t.MathUtils.clamp(t.MathUtils.mapLinear(Math.abs(e),0,20,0,1),0,1);if(this._isNearControls()||e>0){if(this._updateZoomDirection(),e<0&&(this.zoomPointSet||this._updateZoomPoint())){Pr.set(0,0,-1).transformDirection(n.worldMatrix).normalize(),Rr.copy(this.up).multiplyScalar(-1),this.getUpDirection(s,Lr);const e=t.MathUtils.clamp(t.MathUtils.mapLinear(-Lr.dot(Rr),1,.95,0,1),0,1),i=1-Pr.dot(Rr),r=n.isOrthographicCamera?.05:1,o=t.MathUtils.clamp(3*l,0,1),a=Math.min(e*i*r*o,.1);Rr.lerpVectors(Pr,Rr,a).normalize(),Er.setFromUnitVectors(Pr,Rr),Gi(s,Er,Mr),n.worldMatrix.premultiply(Mr),n.worldMatrix.decompose(n.position,n.quaternion,Rr),this.zoomDirection.subVectors(s,n.position).normalize()}super._updateZoom()}else if(n.isPerspectiveCamera){const s=this._getPerspectiveTransitionDistance(),n=this._getMaxPerspectiveDistance(),o=t.MathUtils.mapLinear(this.getDistanceToCenter(),s,n,0,1);this._tiltTowardsCenter(t.MathUtils.lerp(0,.4,o*l)),this._alignCameraUpToNorth(t.MathUtils.lerp(0,.2,o*l));const a=e*(this.getDistanceToCenter()-i.radius.x)*r*.0025,c=Math.max(a,Math.min(this.getDistanceToCenter()-n,0));this.getVectorToCenter(Ar).normalize(),this.camera.position.addScaledVector(Ar,c),this.camera.updateMatrix(),this.zoomDelta=0}else{const e=this._getOrthographicTransitionZoom(),i=this._getMinOrthographicZoom(),s=t.MathUtils.mapLinear(n.zoom,e,i,0,1);this._tiltTowardsCenter(t.MathUtils.lerp(0,.4,s*l)),this._alignCameraUpToNorth(t.MathUtils.lerp(0,.2,s*l));const a=this.zoomDelta,c=Math.pow(.95,Math.abs(.05*a)),h=a>0?1/Math.abs(c):c,u=i/n.zoom,d=Math.max(h*r,Math.min(u,1));n.zoom=Math.min(o,n.zoom*d),n.updateProjectionMatrix(),this.zoomDelta=0,this.zoomDirectionSet=!1}}_alignCameraUpToNorth(e){const{ellipsoidFrame:t}=this;Cr.set(0,0,1).transformDirection(t),this._alignCameraUp(Cr,e)}_tiltTowardsCenter(e){const{camera:t,ellipsoidFrame:i}=this;Pr.set(0,0,-1).transformDirection(t.worldMatrix).normalize(),Ar.setFromMatrixPosition(i).sub(t.position).normalize(),Ar.lerp(Pr,1-e).normalize(),Er.setFromUnitVectors(Pr,Ar),t.quaternion.premultiply(Er),t.updateMatrix()}_getPerspectiveTransitionDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const i=Math.max(...t.radius),r=2*Math.atan(Math.tan(.5*e.fov)*e.aspect),s=i/Math.tan(.5*e.fov),n=i/Math.tan(.5*r);return Math.max(s,n)}_getMaxPerspectiveDistance(){const{camera:e,ellipsoid:t}=this;if(!e.isPerspectiveCamera)throw new Error;const i=Math.max(...t.radius),r=2*Math.atan(Math.tan(.5*e.fov)*e.aspect),s=i/Math.tan(.5*e.fov),n=i/Math.tan(.5*r);return 2*Math.max(s,n)}_getOrthographicTransitionZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const i=e.top-e.bottom,r=e.right-e.left;return 2*Math.max(i,r)/(2*Math.max(t.radius.x,t.radius.y,t.radius.z))}_getMinOrthographicZoom(){const{camera:e,ellipsoid:t}=this;if(!e.isOrthographicCamera)throw new Error;const i=e.top-e.bottom,r=e.right-e.left;return.7*Math.min(i,r)/(2*Math.max(t.radius.x,t.radius.y,t.radius.z))}_getVirtualOrthoCameraPosition(e,t=this.camera){const{ellipsoidFrame:i,ellipsoidFrameInverse:r,ellipsoid:s}=this;if(!t.isOrthographicCamera)throw new Error;Ir.origin.copy(t.position),Ir.direction.set(0,0,-1).transformDirection(t.worldMatrix),Ir.applyMatrix4(r),ji(Ir,s,Tr),Tr.applyMatrix4(i);const n=t.top-t.bottom,o=t.right-t.left,a=Math.max(n,o)/t.zoom;Pr.set(0,0,-1).transformDirection(t.worldMatrix);const l=Tr.sub(t.position).dot(Pr);e.copy(t.position).addScaledVector(Pr,l-4*a)}_isNearControls(){const{camera:e}=this;return e.isPerspectiveCamera?this.getDistanceToCenter()<this._getPerspectiveTransitionDistance():e.zoom>this._getOrthographicTransitionZoom()}_raycast(e){const t=super._raycast(e);if(null===t){const{ellipsoid:t,ellipsoidFrame:i,ellipsoidFrameInverse:r}=this;Ir.copy(e.ray).applyMatrix4(r);const s=t.intersectRay(Ir,Ar);return null!==s?{point:s.clone().applyMatrix4(i)}:null}return t}},e.I3DMLoader=it,e.ImplicitTilingPlugin=class{constructor(){this.name="IMPLICIT_TILING_PLUGIN"}init(e){this.tiles=e}preprocessNode(e,t,i){e.implicitTiling?(e.__hasUnrenderableContent=!0,e.__hasRenderableContent=!1,e.__subtreeIdx=0,e.__implicitRoot=e,e.__x=0,e.__y=0,e.__z=0,e.__level=0):/.subtree$/i.test(e.content?.uri)&&(e.__hasUnrenderableContent=!0,e.__hasRenderableContent=!1)}parseTile(e,t,i){if(/^subtree$/i.test(i)){const i=new c(t);return i.workingPath=t.__basePath,i.fetchOptions=this.tiles.fetchOptions,i.parse(e)}}preprocessURL(e,t){if(t&&t.implicitTiling){const e=t.implicitTiling.subtrees.uri.replace("{level}",t.__level).replace("{x}",t.__x).replace("{y}",t.__y).replace("{z}",t.__z);return new URL(e,t.__basePath+"/").toString()}return e}disposeTile(e){/.subtree$/i.test(e.content?.uri)&&(e.children.forEach(e=>{this.tiles.processNodeQueue.remove(e)}),e.children.length=0,e.__childrenProcessed=0)}},e.OBB=yt,e.PNTSLoader=st,e.QuantizedMeshPlugin=ks,e.ReorientationPlugin=class{constructor(e){e={up:"+z",recenter:!0,lat:null,lon:null,height:0,...e},this.tiles=null,this.up=e.up.toLowerCase().replace(/\s+/,""),this.lat=e.lat,this.lon=e.lon,this.height=e.height,this.recenter=e.recenter,this._callback=null}init(e){this.tiles=e,this._callback=()=>{const{up:t,lat:i,lon:r,height:s,recenter:n}=this;if(null!==i&&null!==r)this.transformLatLonHeightToOrigin(i,r,s);else{const{ellipsoid:i}=e,r=Math.min(i.radius.x,i.radius.y,i.radius.z);if(e.getBoundingSphere(an),an.center.getLength()>.5*r){const e={};i.getPositionToCartographic(an.center,e),this.transformLatLonHeightToOrigin(e.lat,e.lon,e.height)}else{const i=e.group;switch(i.euler.set(0,0,0),t){case"x":case"+x":i.euler.z=Math.PI/2;break;case"-x":i.euler.z=-Math.PI/2;break;case"y":case"+y":break;case"-y":i.euler.z=Math.PI;break;case"z":case"+z":i.euler.x=-Math.PI/2;break;case"-z":i.euler.x=Math.PI/2}i.position.copy(an.center).applyEuler(i.euler).multiplyScalar(-1)}}n||e.group.position.setScalar(0),e.removeEventListener("load-tile-set",this._callback)},e.addEventListener("load-tile-set",this._callback)}transformLatLonHeightToOrigin(e,t,i=0){const{group:r,ellipsoid:s}=this.tiles;s.getRotationMatrixFromAzElRoll(e,t,0,0,0,r.matrix,Jt),s.getCartographicToPosition(e,t,i,ln),r.matrix.setPosition(ln).invert().decompose(r.position,r.quaternion,r.scale),r.updateMatrix()}dispose(){const{group:e}=this.tiles;e.position.setScalar(0),e.quaternion.identity(),e.scale.set(1,1,1),this.tiles.addEventListener("load-tile-set",this._callback)}},e.TMSTilesPlugin=xs,e.TileGLTFLoader=wi,e.TilesFadePlugin=class{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(e){this._fadeManager.duration=Number(e)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(e){e={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...e},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._fadeManager=new Or,this._fadeMaterialManager=new Vr,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=e.maximumFadeOutTiles,this.fadeRootTiles=e.fadeRootTiles,this.fadeDuration=e.fadeDuration}init(e){this._onLoadModel=({scene:e})=>{this._fadeMaterialManager.prepareScene(e)},this._onDisposeModel=({tile:e,scene:t})=>{this._fadeManager.deleteObject(e),this._fadeMaterialManager.deleteScene(t)},this._onAddCamera=({camera:e})=>{this._prevCameraTransforms.set(e,new t.Matrix4)},this._onDeleteCamera=({camera:e})=>{this._prevCameraTransforms.delete(e)},this._onTileVisibilityChange=({tile:e,visible:t})=>{const i=e.cached.scene;i&&(i.visible=!0)},this._onUpdateBefore=()=>{jr.call(this)},this._onUpdateAfter=()=>{Xr.call(this)},e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("add-camera",this._onAddCamera),e.addEventListener("delete-camera",this._onDeleteCamera),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const i=this._fadeManager;i.onFadeSetStart=()=>{e.dispatchEvent({type:"fade-start"}),e.dispatchEvent({type:"needs-render"})},i.onFadeSetComplete=()=>{e.dispatchEvent({type:"fade-end"}),e.dispatchEvent({type:"needs-render"})},i.onFadeComplete=(t,i)=>{this._fadeMaterialManager.setFade(t.cached.scene,0,0),i||(e.invokeOnePlugin(e=>e!==this&&e.setTileVisible&&e.setTileVisible(t,!1)),this._fadingOutCount--)};const r=new Map;e.$cameras._cameras.forEach(e=>{r.set(e,new t.Matrix4)}),e.forEachLoadedModel((e,t)=>{this._onLoadModel({scene:e})}),this.tiles=e,this._fadeManager=i,this._prevCameraTransforms=r}setTileVisible(e,t){const i=this._fadeManager,r=i.isFading(e);if(i.isFadingOut(e)&&this._fadingOutCount--,t){1===e.__depthFromRenderedParent?((e[Fr]||this.fadeRootTiles)&&this._fadeManager.fadeIn(e),e[Fr]=!0):this._fadeManager.fadeIn(e)}else this._fadingOutCount++,i.fadeOut(e);if(r)return!0;const s=this._fadeManager.isFading(e);return!(t||!s)}dispose(){const e=this.tiles;this._fadeManager.completeAllFades(),null!==this.batchedMesh&&this._onBatchedMeshDispose(),e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("add-camera",this._onAddCamera),e.removeEventListener("delete-camera",this._onDeleteCamera),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),e.forEachLoadedModel((e,t)=>{this._fadeManager.deleteObject(t),e&&(e.visible=!0)})}},e.TilesRenderer=class extends R{get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(this._autoDisableRendererCulling=e,this.forEachLoadedModel(t=>{Li(t,!e)}))}get optimizeRaycast(){return this._optimizeRaycast}set optimizeRaycast(e){console.warn('TilesRenderer: The "optimizeRaycast" option has been deprecated.'),this._optimizeRaycast=e}constructor(...e){super(...e),this.group=new ct(this),this.ellipsoid=Mi.clone(),this.$cameras=new vi,this._optimizeRaycast=!0,this._upRotationMatrix=new t.Matrix4,this._bytesUsed=new WeakMap,this._autoDisableRendererCulling=!0;const i=new t.LoadingManager;i.setURLModifier(e=>this.preprocessURL?this.preprocessURL(e):e),this.manager=i,this._listeners={};const r=new Ee(i),s=new it(i),n=new st(i),o=new at(i),a=new wi(i);this._loaders=new Map([["b3dm",r],["i3dm",s],["pnts",n],["cmpt",o],["gltf",a]])}addEventListener(...e){t.EventDispatcher.prototype.addEventListener.call(this,...e)}hasEventListener(...e){t.EventDispatcher.prototype.hasEventListener.call(this,...e)}removeEventListener(...e){t.EventDispatcher.prototype.removeEventListener.call(this,...e)}dispatchEvent(...e){t.EventDispatcher.prototype.dispatchEvent.call(this,...e)}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingBox(e),!0)}getOrientedBoundingBox(e,t){if(!this.root)return!1;const i=this.root.cached.boundingVolume;return!!i&&(i.getOrientedBoundingBox(e,t),!0)}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingSphere(e),!0)}forEachLoadedModel(e){this.traverse(t=>{const i=t.cached&&t.cached.scene;i&&e(i,t)},null,!1)}raycast(e,t){if(!this.root)return null;bt(this,this.root,e,t)}raycastFirst(e){return this.root?_t(this,this.root,e):null}addCamera(e){const t=this.$cameras.add(e);return t&&this.dispatchEvent({type:"add-camera",camera:e}),t}setResolution(e,t){this.$cameras.setResolution(e,t)}removeCamera(e){const t=this.$cameras.remove(e);return t&&this.dispatchEvent({type:"delete-camera",camera:e}),t}loadRootTileSet(...e){return super.loadRootTileSet(...e).then(e=>{const{asset:t,extensions:i={}}=e;switch((t&&t.gltfUpAxis||"y").toLowerCase()){case"x":this._upRotationMatrix.makeRotationAxis(Ei,-Math.PI/2);break;case"y":this._upRotationMatrix.makeRotationAxis(Ci,Math.PI/2);break;default:this._upRotationMatrix.identity()}if("3DTILES_ellipsoid"in i){const e=i["3DTILES_ellipsoid"],{ellipsoid:t}=this;t.name=e.body,e.radii?t.radius.set(...e.radii):t.radius.set(1,1,1)}return e})}update(){let e=null;if(this.invokeAllPlugins(t=>{if(t.doTilesNeedUpdate){const i=t.doTilesNeedUpdate();e=null===e?i:Boolean(e||i)}}),!1===e)return this.dispatchEvent({type:"update-before"}),void this.dispatchEvent({type:"update-after"});this.dispatchEvent(Ri),this.$cameras.updateInfos(this.group),super.update(),this.dispatchEvent(Ii);if(0===this.$cameras._cameras.length&&this.root){let e=!1;this.invokeAllPlugins(t=>e=e||Boolean(t!==this&&t.calculateTileViewError)),!1===e&&console.warn("TilesRenderer: no cameras defined. Cannot update 3d tiles.")}}preprocessNode(e,i,r=null){e.contents&&(e.content=e.contents[0]),super.preprocessNode(e,i,r);const s=new t.Matrix4;e.transform&&s.fromArray(e.transform),r&&s.premultiply(r.cached.transform);const n=(new t.Matrix4).copy(s).invert(),o=new di;"sphere"in e.boundingVolume&&o.setSphereData(e.boundingVolume.sphere,s),"box"in e.boundingVolume&&o.setOBBData(e.boundingVolume.box,s),"region"in e.boundingVolume&&o.setRegionData(this.ellipsoid,...e.boundingVolume.region),e.cached={transform:s,transformInverse:n,active:!1,boundingVolume:o,metadata:null,scene:null,geometry:null,materials:null,textures:null,featureTable:null,batchTable:null}}async parseTile(e,t,i,s,n){const o=t.cached,a=s.split(/[\\\/]/g);a.pop();const l=a.join("/"),c=this.fetchOptions;let h=null;const u=o.transform,d=this._upRotationMatrix,p=(r(e)||i).toLowerCase();switch(p){case"b3dm":h=this._loaders.get("b3dm").load(s,{fetchOptions:c,path:l,buffer:e,adjustmentTransform:d.clone()});break;case"pnts":h=this._loaders.get("pnts").load(s,{fetchOptions:c,path:l,buffer:e});break;case"i3dm":case"cmpt":h=this._loaders.get("i3dm").load(s,{fetchOptions:c,path:l,buffer:e,adjustmentTransform:d.clone()});break;case"gltf":case"glb":h=this._loaders.get("gltf").load(s,{fetchOptions:c,path:l,buffer:e}).then(e=>{const{root:t}=e;return t.matrix.multiply(d).decompose(t.position,t.quaternion,t.scale),e});break;default:h=this.invokeOnePlugin(r=>r.parseToMesh&&r.parseToMesh(e,t,i,s,n))}const m=await h;if(null===m)throw new Error(`TilesRenderer: Content type "${p}" not supported.`);let f,g;m.isObject3D?(f=m,g=null):(f=m.root,g=m),f.updateMatrix(),f.matrix.premultiply(u),f.matrix.decompose(f.position,f.quaternion,f.scale),await this.invokeAllPlugins(e=>e.processTileModel&&e.processTileModel(f,t)),f.traverse(e=>{e[Pi]=e.frustumCulled}),Li(f,!this.autoDisableRendererCulling);const _=[],b=[],y=[];if(f.traverse(e=>{if(e.geometry&&b.push(e.geometry),e.material){const t=e.material;_.push(e.material);for(const e in t){const i=t[e];i&&i.isTexture&&y.push(i)}}}),n.aborted)for(let e=0,t=y.length;e<t;e++){const t=y[e];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}else o.materials=_,o.geometry=b,o.textures=y,o.scene=f,o.metadata=g,o.featureTable=m.featureTable,o.batchTable=m.batchTable}disposeTile(e){super.disposeTile(e);const t=e.cached;if(t.scene){const i=t.materials,r=t.geometry,s=t.textures,n=t.scene.parent;for(let e=0,t=r.length;e<t;e++)r[e].dispose();for(let e=0,t=i.length;e<t;e++)i[e].dispose();for(let e=0,t=s.length;e<t;e++){const t=s[e];t.image instanceof ImageBitmap&&t.image.close(),t.dispose()}n&&n.remove(t.scene),this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null,t.metadata=null}}setTileVisible(e,t){const i=e.cached.scene,r=this.group;t?i&&(r.add(i),i.updateMatrix(!0)):i&&r.remove(i),super.setTileVisible(e,t),this.dispatchEvent({type:"tile-visibility-change",scene:i,tile:e,visible:t})}calculateBytesUsed(e,t){const i=this._bytesUsed;return!i.has(e)&&t&&i.set(e,0),i.get(e)??null}calculateTileViewError(e,t){const i=e.cached,r=this.$cameras.getInfos(),s=i.boundingVolume;let n=!1,o=-1/0,a=1/0,l=-1/0,c=1/0;for(let t=0,i=r.length;t<i;t++){const i=r[t];let h,u;if(i.isOrthographic){const t=i.pixelSize;h=e.geometricError/t,u=1/0}else{const t=i.sseDenominator;u=s.distanceToPoint(i.position),h=0===u?1/0:e.geometricError/(u*t)}const d=r[t].frustum;s.intersectsFrustum(d)&&(n=!0,o=Math.max(o,h),a=Math.min(a,u)),l=Math.max(l,h),c=Math.min(c,u)}this.invokeAllPlugins(t=>{t!==this&&t.calculateTileViewError&&(t.calculateTileViewError(e,Si),Si.inView&&(n=!0,o=Math.max(o,Si.error)),l=Math.max(l,Si.error))}),n?(t.inView=!0,t.error=o,t.distanceToCamera=a):(t.inView=!1,t.error=l,t.distanceToCamera=c)}dispose(){super.dispose(),this.group.removeFromParent()}setDRACOLoader(e){this._loaders.get("b3dm").setDRACOLoader(e),this._loaders.get("i3dm").setDRACOLoader(e),this._loaders.get("cmpt").setDRACOLoader(e),this._loaders.get("gltf").setDRACOLoader(e)}setKTX2Loader(e){this._loaders.get("b3dm").setKTX2Loader(e),this._loaders.get("i3dm").setKTX2Loader(e),this._loaders.get("cmpt").setKTX2Loader(e),this._loaders.get("gltf").setKTX2Loader(e)}},e.XYZTilesPlugin=class extends us{constructor(e={}){const{levels:t=20,tileDimension:i=256,pixelSize:r=1e-5,...s}=e;super({pixelSize:r,...s}),this.name="XYZ_TILES_PLUGIN",this.imageSource=new bs({levels:t,tileDimension:i})}}});
