// t3d-3dtiles
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("t3d")):"function"==typeof define&&define.amd?define(["exports","t3d"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).t3d=e.t3d||{},e.t3d)}(this,(function(e,t){"use strict";class s{constructor(e=new t.Box3,s=new t.Matrix3){this.box=e,this.rotation=s}setFromCenterAndAxes(e,t,s,r){i.copy(t),n.copy(s),a.copy(r);const o=i.getLength(),l=n.getLength(),c=a.getLength();i.normalize(),n.normalize(),a.normalize(),0===o&&i.crossVectors(n,a),0===l&&n.crossVectors(i,a),0===c&&a.crossVectors(i,n),this.rotation.set(i.x,n.x,a.x,i.y,n.y,a.y,i.z,n.z,a.z);const d=i.set(o,l,c);return this.box.min.copy(e).sub(d),this.box.max.copy(e).add(d),this}applyMatrix4(e){const t=e.elements;let s=i.set(t[0],t[1],t[2]).getLength();const r=i.set(t[4],t[5],t[6]).getLength(),a=i.set(t[8],t[9],t[10]).getLength();e.determinant()<0&&(s=-s),o.setFromMatrix4(e);const l=1/s,c=1/r,d=1/a;o.elements[0]*=l,o.elements[1]*=l,o.elements[2]*=l,o.elements[3]*=c,o.elements[4]*=c,o.elements[5]*=c,o.elements[6]*=d,o.elements[7]*=d,o.elements[8]*=d,this.rotation.multiply(o);const h=this.box.getCenter(i),u=this.box.getSize(n).multiplyScalar(.5);return u.x*=s,u.y*=r,u.z*=a,h.applyMatrix4(e),this.box.min.copy(h).sub(u),this.box.max.copy(h).add(u),this}getPoints(e){const t=this.box.getCenter(i),s=n.subVectors(this.box.min,t),r=a.subVectors(this.box.max,t);let o=0;for(let i=-1;i<=1;i+=2)for(let n=-1;n<=1;n+=2)for(let a=-1;a<=1;a+=2)e[o].set(i<0?s.x:r.x,n<0?s.y:r.y,a<0?s.z:r.z).applyMatrix3(this.rotation).add(t),o++;return e}getPlanes(e){const t=this.box.getCenter(i),s=n.subVectors(this.box.min,t).applyMatrix3(this.rotation).add(t),r=a.subVectors(this.box.max,t).applyMatrix3(this.rotation).add(t);return i.set(0,0,1).applyMatrix3(this.rotation).normalize(),e[0].setFromNormalAndCoplanarPoint(i,s),e[1].setFromNormalAndCoplanarPoint(i,r),e[1].normal.negate(),e[1].constant*=-1,i.set(0,1,0).applyMatrix3(this.rotation).normalize(),e[2].setFromNormalAndCoplanarPoint(i,s),e[3].setFromNormalAndCoplanarPoint(i,r),e[3].normal.negate(),e[3].constant*=-1,i.set(1,0,0).applyMatrix3(this.rotation).normalize(),e[4].setFromNormalAndCoplanarPoint(i,s),e[5].setFromNormalAndCoplanarPoint(i,r),e[5].normal.negate(),e[5].constant*=-1,e}containsPoint(e){const t=m(this,u),s=i.subVectors(e,t.c);return Math.abs(s.dot(t.u[0]))<=t.e[0]&&Math.abs(s.dot(t.u[1]))<=t.e[1]&&Math.abs(s.dot(t.u[2]))<=t.e[2]}clampPoint(e,t){const s=m(this,u),r=i.subVectors(e,s.c);t.copy(s.c);const n=Math.max(Math.min(r.dot(s.u[0]),s.e[0]),-s.e[0]);t.add(s.u[0].multiplyScalar(n));const a=Math.max(Math.min(r.dot(s.u[1]),s.e[1]),-s.e[1]);t.add(s.u[1].multiplyScalar(a));const o=Math.max(Math.min(r.dot(s.u[2]),s.e[2]),-s.e[2]);return t.add(s.u[2].multiplyScalar(o)),t}intersectsSphere(e){return this.clampPoint(e.center,r),r.distanceToSquared(e.center)<=e.radius*e.radius}intersectsOBB(e,t=Number.EPSILON){m(this,u),m(e,p);for(let e=0;e<3;e++)for(let t=0;t<3;t++)l[e][t]=u.u[e].dot(p.u[t]);const s=i.subVectors(p.c,u.c);d[0]=s.dot(u.u[0]),d[1]=s.dot(u.u[1]),d[2]=s.dot(u.u[2]);for(let e=0;e<3;e++)for(let s=0;s<3;s++)c[e][s]=Math.abs(l[e][s])+t;let r,n;for(let e=0;e<3;e++)if(r=u.e[e],n=p.e[0]*c[e][0]+p.e[1]*c[e][1]+p.e[2]*c[e][2],Math.abs(d[e])>r+n)return!1;for(let e=0;e<3;e++)if(r=u.e[0]*c[0][e]+u.e[1]*c[1][e]+u.e[2]*c[2][e],n=p.e[e],Math.abs(d[0]*l[0][e]+d[1]*l[1][e]+d[2]*l[2][e])>r+n)return!1;return r=u.e[1]*c[2][0]+u.e[2]*c[1][0],n=p.e[1]*c[0][2]+p.e[2]*c[0][1],!(Math.abs(d[2]*l[1][0]-d[1]*l[2][0])>r+n)&&(r=u.e[1]*c[2][1]+u.e[2]*c[1][1],n=p.e[0]*c[0][2]+p.e[2]*c[0][0],!(Math.abs(d[2]*l[1][1]-d[1]*l[2][1])>r+n)&&(r=u.e[1]*c[2][2]+u.e[2]*c[1][2],n=p.e[0]*c[0][1]+p.e[1]*c[0][0],!(Math.abs(d[2]*l[1][2]-d[1]*l[2][2])>r+n)&&(r=u.e[0]*c[2][0]+u.e[2]*c[0][0],n=p.e[1]*c[1][2]+p.e[2]*c[1][1],!(Math.abs(d[0]*l[2][0]-d[2]*l[0][0])>r+n)&&(r=u.e[0]*c[2][1]+u.e[2]*c[0][1],n=p.e[0]*c[1][2]+p.e[2]*c[1][0],!(Math.abs(d[0]*l[2][1]-d[2]*l[0][1])>r+n)&&(r=u.e[0]*c[2][2]+u.e[2]*c[0][2],n=p.e[0]*c[1][1]+p.e[1]*c[1][0],!(Math.abs(d[0]*l[2][2]-d[2]*l[0][2])>r+n)&&(r=u.e[0]*c[1][0]+u.e[1]*c[0][0],n=p.e[1]*c[2][2]+p.e[2]*c[2][1],!(Math.abs(d[1]*l[0][0]-d[0]*l[1][0])>r+n)&&(r=u.e[0]*c[1][1]+u.e[1]*c[0][1],n=p.e[0]*c[2][2]+p.e[2]*c[2][0],!(Math.abs(d[1]*l[0][1]-d[0]*l[1][1])>r+n)&&(r=u.e[0]*c[1][2]+u.e[1]*c[0][2],n=p.e[0]*c[2][1]+p.e[1]*c[2][0],!(Math.abs(d[1]*l[0][2]-d[0]*l[1][2])>r+n)))))))))}toBoundingBoxWithTransform(e,t){const s=this.box.getCenter(i);e.min.copy(this.box.min).sub(s),e.max.copy(this.box.max).sub(s);const r=this.rotation.elements;t.set(r[0],r[3],r[6],s.x,r[1],r[4],r[7],s.y,r[2],r[5],r[8],s.z,0,0,0,1)}}const r=new t.Vector3,i=new t.Vector3,n=new t.Vector3,a=new t.Vector3,o=new t.Matrix3,l=[[],[],[]],c=[[],[],[]],d=[],h=new t.Vector3,u={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]},p={c:new t.Vector3,u:[new t.Vector3,new t.Vector3,new t.Vector3],e:[]};function m(e,t){e.box.getCenter(t.c);const s=e.rotation.elements;return t.u[0].fromArray(s,0),t.u[1].fromArray(s,3),t.u[2].fromArray(s,6),e.box.getSize(h).multiplyScalar(.5).toArray(t.e),t}class f extends s{constructor(){super(),this._points=new Array(8).fill().map((()=>new t.Vector3)),this._planes=new Array(6).fill().map((()=>new t.Plane)),this._originBox=new t.Box3,this._originBoxTransform=new t.Matrix4,this._originBoxTransformInverse=new t.Matrix4}updateCache(){this.getPoints(this._points),this.getPlanes(this._planes),this.toBoundingBoxWithTransform(this._originBox,this._originBoxTransform),this._originBoxTransformInverse.copy(this._originBoxTransform).inverse()}containsPoint(e){return _.copy(e).applyMatrix4(this._originBoxTransformInverse),this.box.containsPoint(_)}intersectsRay(e){return g.copy(e).applyMatrix4(this._originBoxTransformInverse),g.intersectsBox(this._originBox)}intersectRay(e,t){return g.copy(e).applyMatrix4(this._originBoxTransformInverse),g.intersectBox(this._originBox,t)?t.applyMatrix4(this._originBoxTransform):null}intersectsFrustum(e){for(let t=0;t<6;t++){const s=e.planes[t];let r=-1/0;for(let e=0;e<8;e++){const t=this._points[e],i=s.distanceToPoint(t);r=r<i?i:r}if(r<0)return!1}for(let t=0;t<6;t++){const s=this._planes[t];let r=-1/0;for(let t=0;t<8;t++){const i=e.points[t],n=s.distanceToPoint(i);r=r<n?n:r}if(r<0)return!1}return!0}distanceToPoint(e){return _.copy(e).applyMatrix4(this._originBoxTransformInverse),this._originBox.distanceToPoint(_)}getBoundingSphere(e){return this.box.getBoundingSphere(e)}getBoundingBox(e){return e.setFromPoints(this._points)}}const g=new t.Ray,_=new t.Vector3;class b{constructor(e=new t.Vector3(1,1,1)){this.name="",this.radius=e}getEastNorthUpFrame(e,t,s){return this.getEastNorthUpAxes(e,t,w,L,R,S),s.makeBasis(w,L,R).setPosition(S)}getEastNorthUpAxes(e,t,s,r,i,n=S){this.getCartographicToPosition(e,t,0,n),this.getCartographicToNormal(e,t,i),s.set(-n.y,n.x,0).normalize(),r.crossVectors(i,s).normalize()}getRotationMatrixFromAzElRoll(e,t,s,r,i,n,a=P){return this.getEastNorthUpFrame(e,t,M),v.set(r,i,-s,"ZXY"),n.makeRotationFromEuler(v).premultiply(M).setPosition(0,0,0),a===I?(v.set(Math.PI/2,0,0,"XYZ"),E.makeRotationFromEuler(v),n.multiply(E)):a===D&&(v.set(-Math.PI/2,0,Math.PI,"XYZ"),E.makeRotationFromEuler(v),n.multiply(E)),n}getCartographicToPosition(e,t,s,r){this.getCartographicToNormal(e,t,A);const i=this.radius;y.copy(A),y.x*=i.x**2,y.y*=i.y**2,y.z*=i.z**2;const n=Math.sqrt(A.dot(y));return y.multiplyScalar(1/n),r.copy(y).addScaledVector(A,s)}getPositionToCartographic(e,t){this.getPositionToSurfacePoint(e,y),this.getPositionToNormal(e,A);const s=T.subVectors(e,y);return t.lon=Math.atan2(A.y,A.x),t.lat=Math.asin(A.z),t.height=Math.sign(s.dot(e))*s.getLength(),t}getCartographicToNormal(e,t,s){return x.set(1,-e+Math.PI/2,t),s.setFromSpherical(x).normalize(),function(e){const{x:t,y:s,z:r}=e;e.x=r,e.y=t,e.z=s}(s),s}getPositionToNormal(e,t){const s=this.radius;return t.copy(e),t.x/=s.x**2,t.y/=s.y**2,t.z/=s.z**2,t.normalize(),t}getPositionToSurfacePoint(e,t){const s=this.radius,r=1/s.x**2,i=1/s.y**2,n=1/s.z**2,a=e.x*e.x*r,o=e.y*e.y*i,l=e.z*e.z*n,c=a+o+l,d=Math.sqrt(1/c),h=y.copy(e).multiplyScalar(d);if(c<O)return isFinite(d)?t.copy(h):null;const u=T.set(h.x*r*2,h.y*i*2,h.z*n*2);let p,m,f,g,_,b,x,A,M,E,v,w=(1-d)*e.getLength()/(.5*u.getLength()),L=0;do{w-=L,f=1/(1+w*r),g=1/(1+w*i),_=1/(1+w*n),b=f*f,x=g*g,A=_*_,M=b*f,E=x*g,v=A*_,p=a*b+o*x+l*A-1,m=a*M*r+o*E*i+l*v*n;L=p/(-2*m)}while(Math.abs(p)>C);return t.set(e.x*f,e.y*g,e.z*_)}copy(e){return this.radius.copy(e.radius),this}clone(){return(new this.constructor).copy(this)}}const x=new t.Spherical,A=new t.Vector3,y=new t.Vector3,T=new t.Vector3,M=new t.Matrix4,E=new t.Matrix4,v=new t.Euler,w=new t.Vector3,L=new t.Vector3,R=new t.Vector3,S=new t.Vector3,C=1e-12,O=.1,P=0,I=1,D=2;class B extends b{constructor(e=new t.Vector3(1,1,1),s=new t.Vector2(-z,z),r=new t.Vector2(0,2*G),i=new t.Vector2(0,1)){super(e),this.latRange=s,this.lonRange=r,this.heightRange=i}getOrientedBoundingBox(e){X();const{latRange:t,lonRange:s}=this;if(t.y-t.x<G/2){const e=H(.5,0,1,t.x,t.y),r=H(.5,0,1,s.x,s.y);this.getCartographicToNormal(e,r,U),F.set(0,0,1),N.crossVectors(F,U),F.crossVectors(N,U)}else N.set(1,0,0),F.set(0,1,0),U.set(0,0,1);e.rotation.set(N.x,F.x,U.x,N.y,F.y,U.y,N.z,F.z,U.z),V.setFromMatrix3(e.rotation).inverse();const r=this._getPoints(!0);k.set(0,0,0);for(let e=0,t=r.length;e<t;e++)k.add(r[e]);k.multiplyScalar(1/r.length);for(let e=0,t=r.length;e<t;e++)r[e].sub(k).applyMatrix4(V).add(k);e.box.makeEmpty(),e.box.setFromPoints(r)}getBoundingSphere(e){X();const t=this._getPoints(!0);e.makeEmpty(),e.setFromPoints(t)}_getPoints(e=!1){const{latRange:t,lonRange:s,heightRange:r}=this,i=H(.5,0,1,t.x,t.y),n=H(.5,0,1,s.x,s.y),a=Math.floor(s.x/z)*z,o=[[-G/2,0],[G/2,0],[0,a],[0,a+G/2],[0,a+G],[0,a+3*G/2],[t.x,s.y],[t.y,s.y],[t.x,s.x],[t.y,s.x],[0,s.x],[0,s.y],[i,n],[t.x,n],[t.y,n],[i,s.x],[i,s.y]],l=[],c=o.length;for(let i=0;i<=1;i++){const n=H(i,0,1,r.x,r.y);for(let r=0,i=c;r<i;r++){const[i,a]=o[r];if(i>=t.x&&i<=t.y&&a>=s.x&&a<=s.y){const t=j(e);l.push(t),this.getCartographicToPosition(i,a,n,t)}}}return l}}const N=new t.Vector3,F=new t.Vector3,U=new t.Vector3,k=new t.Vector3,V=new t.Matrix4,G=Math.PI,z=G/2;function H(e,t,s,r,i){return r+(e-t)*(i-r)/(s-t)}let $=0;const K=[];function j(e=!1){return e?(K[$]||(K[$]=new t.Vector3),$++,K[$-1]):new t.Vector3}function X(){$=0}class Y{constructor(){this.sphere=null,this.obb=null,this.region=null}setOBBData(e,t){const s=new f;s.setFromCenterAndAxes(q.set(e[0],e[1],e[2]),W.set(e[3],e[4],e[5]),Q.set(e[6],e[7],e[8]),J.set(e[9],e[10],e[11])).applyMatrix4(t),s.updateCache(),this.obb=s}setSphereData(e,s){const r=new t.Sphere;r.center.set(e[0],e[1],e[2]),r.radius=e[3],r.applyMatrix4(s),this.sphere=r}setRegionData(e,s,r,i,n,a,o){const l=new B(e.radius.clone(),new t.Vector2(r,n),new t.Vector2(s,i),new t.Vector2(a,o));this.region=l;const c=new f;l.getOrientedBoundingBox(c),c.updateCache(),this.obb=c}intersectsRay(e){const t=this.sphere,s=this.obb;return!(t&&!e.intersectsSphere(t))&&!(s&&!s.intersectsRay(e))}intersectRay(e,t){const s=this.sphere,r=this.obb;let i=-1/0,n=-1/0;s&&e.intersectSphere(s,W)&&(i=s.containsPoint(e.origin)?0:e.origin.distanceToSquared(W)),r&&r.intersectRay(e,W)&&(n=r.containsPoint(e.origin)?0:e.origin.distanceToSquared(W));const a=Math.max(i,n);return a===-1/0?null:e.at(Math.sqrt(a),t)}distanceToPoint(e){const t=this.sphere,s=this.obb;let r=-1/0,i=-1/0;return t&&(r=Math.max(t.distanceToPoint(e),0)),s&&(i=s.distanceToPoint(e)),r>i?r:i}intersectsFrustum(e){const t=this.sphere;if(t&&!e.intersectsSphere(t))return!1;const s=this.obb;return!(s&&!s.intersectsFrustum(e))&&Boolean(t||s)}getOrientedBoundingBox(e,t){this.obb?(e.copy(this.obb._originBox),t.copy(this.obb._originBoxTransform)):(this.getBoundingBox(e),t.identity())}getBoundingBox(e){return this.sphere?this.sphere.getBoundingBox(e):this.obb.getBoundingBox(e)}getBoundingSphere(e){return this.sphere?e.copy(this.sphere):this.obb.getBoundingSphere(e)}}const W=new t.Vector3,Q=new t.Vector3,J=new t.Vector3,q=new t.Vector3,Z=e=>{let t;try{t=new URL(e,"http://fakehost.com/")}catch(e){return null}const s=t.pathname.split("/").pop(),r=s.lastIndexOf(".");if(-1===r||r===s.length-1)return null;return s.substring(r+1)},ee=(e,t=null,s=null,r=null,i=0)=>{if(t&&t(e,r,i))return void(s&&s(e,r,i));const n=e.children;for(let r=0,a=n.length;r<a;r++)ee(n[r],t,s,e,i+1);s&&s(e,r,i)};const te=(e,t,s,r,i=null)=>{const{activeTiles:n}=t,a=e.cached.boundingVolume;if(null===i&&(i=ae,ne.copy(t.worldMatrix).inverse(),i.copy(s).applyMatrix4(ne)),!e.__used||!a.intersectsRay(i))return;n.has(e)&&ie(e,s,r);const o=e.children;for(let e=0,n=o.length;e<n;e++)te(o[e],t,s,r,i)},se=(e,t,s,r=null)=>{const{activeTiles:i}=t;null===r&&(r=ae,ne.copy(t.worldMatrix).inverse(),r.copy(s).applyMatrix4(ne));const n=[],a=e.children;for(let e=0,i=a.length;e<i;e++){const i=a[e];if(!i.__used)continue;i.cached.boundingVolume.intersectRay(r,oe)&&(oe.applyMatrix4(t.worldMatrix),n.push({distance:oe.distanceToSquared(s.origin),tile:i}))}n.sort(re);let o=null,l=1/0;if(i.has(e)&&(ie(e,s,le),le.length>0)){le.length>1&&le.sort(re);const e=le[0];le.length=0,o=e,l=e.distance*e.distance}for(let e=0,i=n.length;e<i;e++){const i=n[e],a=i.distance,c=i.tile;if(a>l)break;const d=se(c,t,s,r);if(d){const e=d.distance*d.distance;e<l&&(o=d,l=e)}}return o},re=(e,t)=>e.distance-t.distance,ie=(e,t,s)=>{const r=e.cached.scene,i=s.length;r.traverse((e=>{Object.getPrototypeOf(e).raycast.call(e,t,s)}));const n=s.length;if(n>i)for(let t=i;t<n;t++)s[t].tile=e},ne=new t.Matrix4,ae=new t.Ray,oe=new t.Vector3,le=[];var ce=Object.freeze({UNLOADED:0,LOADING:1,PARSING:2,LOADED:3,FAILED:4});class de extends t.Frustum{constructor(){super(),this.points=new Array(8).fill().map((()=>new t.Vector3))}updateCache(){const{planes:e,points:t}=this;[[e[0],e[3],e[4]],[e[1],e[3],e[4]],[e[0],e[2],e[4]],[e[1],e[2],e[4]],[e[0],e[3],e[5]],[e[1],e[3],e[5]],[e[0],e[2],e[5]],[e[1],e[2],e[5]]].forEach(((e,s)=>{!function(e,t,s,r){const i=he.set(e.normal.x,e.normal.y,e.normal.z,t.normal.x,t.normal.y,t.normal.z,s.normal.x,s.normal.y,s.normal.z);r.set(-e.constant,-t.constant,-s.constant),r.applyMatrix3(i.inverse())}(e[0],e[1],e[2],t[s])}))}}const he=new t.Matrix3;class ue{constructor(){this._cameras=[],this._resolution=new t.Vector2,this._infos=[]}add(e){const t=this._cameras;return-1===t.indexOf(e)&&(t.push(e),!0)}remove(e){const t=this._cameras,s=t.indexOf(e);return-1!==s&&(t.splice(s,1),!0)}setResolution(e,t){this._resolution.set(e,t)}updateInfos(e){const s=this._cameras,r=s.length,i=this._infos,n=this._resolution;if(0===r)return void console.warn("CameraList.updateInfos(): No camera added.");for(;i.length>s.length;)i.pop();for(;i.length<s.length;)i.push({frustum:new de,isOrthographic:!1,sseDenominator:-1,position:new t.Vector3,invScale:-1,pixelSize:0});pe.copy(e).inverse();const a=fe.setFromMatrixColumn(pe,0).getLength(),o=fe.setFromMatrixColumn(pe,1).getLength(),l=fe.setFromMatrixColumn(pe,2).getLength();Math.abs(Math.max(a-o,a-l))>1e-6&&console.warn("CameraList.updateInfos(): Non uniform scale used for tile which may cause issues when calculating screen space error.");const c=a,d=pe;for(let t=0,r=i.length;t<r;t++){const r=s[t],a=i[t],o=n.x*(r.rect.z-r.rect.x),l=n.y*(r.rect.w-r.rect.y);0!==o&&0!==l||console.warn("CameraList.updateInfos(): Resolution for camera error calculation is not set.");const h=r.projectionMatrix.elements;if(a.isOrthographic=1===h[15],a.isOrthographic){const e=2/h[0],t=2/h[5];a.pixelSize=Math.max(t/l,e/o)}else a.sseDenominator=2/h[5]/l;a.invScale=c,me.copy(e).premultiply(r.projectionViewMatrix),a.frustum.setFromMatrix(me),a.frustum.updateCache(),a.position.setFromMatrixPosition(r.worldMatrix).applyMatrix4(d)}}getInfos(){return this._infos}}const pe=new t.Matrix4,me=new t.Matrix4,fe=new t.Vector3;class ge{constructor({maxSize:e=800,minSize:t=600,unloadPercent:s=.05,unloadPriorityCallback:r=_e}){this.maxSize=e,this.minSize=t,this.unloadPercent=s,this.itemSet=new Map,this.itemList=[],this.usedSet=new Set,this.callbacks=new Map,this.scheduled=!1,this.unloadPriorityCallback=r}isFull(){return this.itemSet.size>=this.maxSize}add(e,t){const s=this.itemSet;if(s.has(e))return!1;if(this.isFull())return!1;const r=this.usedSet,i=this.itemList,n=this.callbacks;return i.push(e),r.add(e),s.set(e,Date.now()),n.set(e,t),!0}remove(e){const t=this.usedSet,s=this.itemSet,r=this.itemList,i=this.callbacks;if(s.has(e)){i.get(e)(e);const n=r.indexOf(e);return r.splice(n,1),t.delete(e),s.delete(e),i.delete(e),!0}return!1}markUsed(e){const t=this.itemSet,s=this.usedSet;return!(!t.has(e)||s.has(e))&&(t.set(e,Date.now()),s.add(e),!0)}markAllUnused(){this.usedSet.clear()}unloadToMinSize(){const e=this.unloadPercent,t=this.minSize,s=this.itemList,r=this.itemSet,i=this.usedSet,n=this.callbacks,a=s.length-i.size,o=s.length-t,l=this.unloadPriorityCallback;if(o<=0||a<=0)return!1;s.sort(((e,t)=>{const s=i.has(e),n=i.has(t);return s&&n?0:s||n?s?1:-1:l(r,t)-l(r,e)}));const c=Math.min(o,a),d=Math.max(t*e,c*e);let h=Math.min(d,a);h=Math.ceil(h);const u=s.splice(0,h);for(let e=0,t=u.length;e<t;e++){const t=u[e];n.get(t)(t),r.delete(t),n.delete(t)}return!0}scheduleUnload(e=!0){if(this.scheduled)return!1;this.scheduled=!0,be((()=>{this.scheduled=!1,this.unloadToMinSize(),e&&this.markAllUnused()}))}}const _e=(e,t)=>e.get(t),be=e=>{Promise.resolve().then(e)};class xe{constructor({maxJobs:e=6,autoUpdate:t=!0,priorityCallback:s=Ae}){this.maxJobs=e,this.autoUpdate=t,this.items=[],this.callbacks=new Map,this.currJobs=0,this.scheduled=!1,this.priorityCallback=s,this._runjobs=()=>{this.tryRunJobs(),this.scheduled=!1}}schedulingCallback(e){requestAnimationFrame(e)}sort(){const e=this.priorityCallback;this.items.sort(e)}add(e,t){return new Promise(((s,r)=>{const i=this.items,n=this.callbacks;i.push(e),n.set(e,((...e)=>t(...e).then(s).catch(r))),this.autoUpdate&&this.scheduleJobRun()}))}remove(e){const t=this.items,s=this.callbacks,r=t.indexOf(e);-1!==r&&(t.splice(r,1),s.delete(e))}tryRunJobs(){this.sort();const e=this.items,t=this.callbacks,s=this.maxJobs;let r=this.currJobs;for(;s>r&&e.length>0;){r++;const s=e.pop(),i=t.get(s);t.delete(s),i(s).then((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()})).catch((()=>{this.currJobs--,this.autoUpdate&&this.scheduleJobRun()}))}this.currJobs=r}scheduleJobRun(){this.scheduled||(this.schedulingCallback(this._runjobs.bind(this)),this.scheduled=!0)}}const Ae=()=>{throw new Error("PriorityQueue: PriorityCallback function not defined.")};class ye{constructor(){this.lruCache=new ge({unloadPriorityCallback:Te}),this.downloadQueue=new xe({maxJobs:4,priorityCallback:Me}),this.parseQueue=new xe({maxJobs:1,priorityCallback:Me})}requestTileContents(e,t){if(e.__loadingState!==ce.UNLOADED)return;const s=t.stats,r=this.lruCache,i=this.downloadQueue,n=this.parseQueue,a=e.__externalTileSet;r.add(e,(e=>{e.__loadingState===ce.LOADING?(e.__loadAbort.abort(),e.__loadAbort=null):a?e.children.length=0:t.$disposeTile(e),e.__loadingState===ce.LOADING?s.downloading--:e.__loadingState===ce.PARSING&&s.parsing--,e.__loadingState=ce.UNLOADED,e.__loadIndex++,i.remove(e),n.remove(e)})),e.__loadIndex++;const o=e.__loadIndex,l=new AbortController,c=l.signal;s.downloading++,e.__loadAbort=l,e.__loadingState=ce.LOADING;const d=t=>{e.__loadIndex===o&&("AbortError"!==t.name?(i.remove(e),n.remove(e),e.__loadingState===ce.PARSING?s.parsing--:e.__loadingState===ce.LOADING&&s.downloading--,s.failed++,e.__loadingState=ce.FAILED,"Failed to fetch"!==t.message&&(console.error(`TilesLoader: Failed to load tile at url "${e.content.uri}".`),console.error(t))):r.remove(e))};let h=e.content.uri;t.invokeAllPlugins((t=>h=t.preprocessURL?t.preprocessURL(h,e):h)),a?i.add(e,(e=>e.__loadIndex!==o?Promise.resolve():t.invokeOnePlugin((e=>e.fetchData&&e.fetchData(h,{...t.fetchOptions,signal:c}))))).then((e=>{if(e.ok)return e.json();throw new Error(`TilesLoader: Failed to load tileset "${h}" with status ${e.status} : ${e.statusText}`)})).then((s=>(t.preprocessTileSet(s,h,e),s))).then((r=>{e.__loadIndex===o&&(s.downloading--,e.__loadAbort=null,e.__loadingState=ce.LOADED,e.children.push(r.root),t.dispatchEvent({type:"load-tile-set",tileSet:r,url:h}))})).catch(d):i.add(e,(e=>e.__loadIndex!==o?Promise.resolve():t.invokeOnePlugin((e=>e.fetchData&&e.fetchData(h,{...t.fetchOptions,signal:c}))))).then((t=>{if(e.__loadIndex===o){if(t.ok){return"gltf"===Z(t.url)?t.json():t.arrayBuffer()}throw new Error(`Failed to load model with error code ${t.status}`)}})).then((r=>{if(e.__loadIndex===o)return s.downloading--,s.parsing++,e.__loadAbort=null,e.__loadingState=ce.PARSING,n.add(e,(e=>{if(e.__loadIndex!==o)return Promise.resolve();const s=e.content.uri,i=Z(s);return t.$parseTile(r,e,i)}))})).then((()=>{e.__loadIndex===o&&(s.parsing--,e.__loadingState=ce.LOADED,e.__wasSetVisible&&t.invokeOnePlugin((t=>t.setTileVisible&&t.setTileVisible(e,!0))),e.__wasSetActive&&t.$setTileActive(e,!0))})).catch(d)}}const Te=(e,t)=>1/(t.__depthFromRenderedParent+1),Me=(e,t)=>e.__depth!==t.__depth?e.__depth>t.__depth?-1:1:e.__inFrustum!==t.__inFrustum?e.__inFrustum?1:-1:e.__used!==t.__used?e.__used?1:-1:e.__error!==t.__error?e.__error>t.__error?1:-1:e.__distanceFromCamera!==t.__distanceFromCamera?e.__distanceFromCamera>t.__distanceFromCamera?-1:1:0;class Ee extends t.Loader{constructor(e){super(e),"undefined"==typeof createImageBitmap&&console.warn("ImageBitmapLoader: createImageBitmap() not supported."),"undefined"==typeof fetch&&console.warn("ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,r){void 0===e&&(e=""),void 0!==this.path&&(e=this.path+e),e=this.manager.resolveURL(e);const i=this,n={};n.credentials="anonymous"===this.crossOrigin?"same-origin":"include",n.headers=this.requestHeader,fetch(e,n).then((function(e){return e.blob()})).then((function(e){return createImageBitmap(e,Object.assign(i.options,{colorSpaceConversion:"none"}))})).then((function(s){t&&t(s),i.manager.itemEnd(e)})).catch((function(t){r&&r(t),i.manager.itemError(e),i.manager.itemEnd(e)})),i.manager.itemStart(e)}}const ve=new t.Vector4;class we{constructor(){}static extractUrlBase(e){const t=e.split("/");return t.pop(),(t.length<1?".":t.join("/"))+"/"}static resolveURL(e,t){return"string"!=typeof e||""===e?"":/^(https?:)?\/\//i.test(e)||/^data:/i.test(e)||/^blob:/i.test(e)?e:t+e}static decodeText(e){if("undefined"!=typeof TextDecoder)return(new TextDecoder).decode(e);let t="";for(let s=0,r=e.length;s<r;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch(e){return t}}static parseGLB(e){const t=1313821514,s=5130562,r=new DataView(e),i={magic:r.getUint32(0,!0),version:r.getUint32(4,!0),length:r.getUint32(8,!0)};if(1179937895!==i.magic)return console.error("Invalid glb magic number. Expected 0x46546C67, found 0x"+i.magic.toString(16)),null;i.version<2&&console.error("GLTFLoader: Legacy binary file detected.");let n=r.getUint32(12,!0),a=r.getUint32(16,!0);if(a!==t)return console.error("Invalid glb chunk type. Expected 0x4E4F534A, found 0x"+a.toString(16)),null;const o=new Uint8Array(e,20,n),l=JSON.parse(we.decodeText(o)),c=[];let d=20+n;for(;d<i.length;){if(n=r.getUint32(d,!0),a=r.getUint32(d+4,!0),a!==s)return console.error("Invalid glb chunk type. Expected 0x004E4942, found 0x"+a.toString(16)),null;const t=d+8,i=e.slice(t,t+n);c.push(i),d+=n+8}return{gltf:l,buffers:c}}static getNormalizedComponentScale(e){if(e===Int8Array)return 1/127;if(e===Uint8Array)return 1/255;if(e===Int16Array)return 1/32767;if(e===Uint16Array)return 1/65535;throw new Error("Unsupported normalized accessor component type.")}static normalizeSkinWeights(e){const t=e.offset,s=e.buffer,r=s.stride;for(let e=0,i=s.count;e<i;e++){ve.fromArray(s.array,e*r+t);const i=1/ve.getManhattanLength();i!==1/0?ve.multiplyScalar(i):ve.set(1,0,0,0),ve.toArray(s.array,e*r+t)}}}class Le{static parse(e,t){const{gltf:s,path:r}=e,{nodes:i=[],skins:n=[],meshes:a=[],buffers:o,images:l}=s;if(n.forEach((e=>{const{joints:t=[]}=e;t.forEach((e=>{i[e].isBone=!0}))})),i.forEach((e=>{void 0!==e.mesh&&void 0!==e.skin&&(a[e.mesh].isSkinned=!0)})),t.detailLoadProgress){const s=new Set;o&&o.forEach((e=>{if(!e.uri)return;const t=we.resolveURL(e.uri,r);s.add(t)})),l&&l.forEach(((e,t)=>{const{uri:i,bufferView:n}=e;let a=i;void 0!==n&&(a="blob<"+t+">"),a=we.resolveURL(a,r),s.add(a)})),s.forEach((e=>t.manager.itemStart(e))),e.loadItems=s}}}class Re{static parse(e){const{gltf:{asset:{version:t}}}=e,s=Number(t);if(!(s>=2&&s<3))throw"Only support gltf 2.x."}}class Se{static parse(e,t){const{gltf:s,loadItems:r}=e;return null!==e.buffers?null:Promise.all(s.buffers.map((s=>{const i=we.resolveURL(s.uri,e.path);t.detailLoadProgress&&r.delete(i);const n=t.loadFile(i,"arraybuffer").then((e=>(t.detailLoadProgress&&t.manager.itemEnd(i),e)));return t.detailLoadProgress&&n.catch((()=>t.manager.itemEnd(i))),n}))).then((t=>{e.buffers=t}))}}class Ce{static parse(e,t){const{buffers:s,gltf:r}=e;if(!r.bufferViews)return;const i=t.extensions.get("EXT_meshopt_compression");return Promise.all(r.bufferViews.map((e=>{const{buffer:r,byteOffset:n=0,byteLength:a=0}=e;if(e.extensions){const{EXT_meshopt_compression:r}=e.extensions;if(r&&i)return i.loadBufferView(r,s,t.getMeshoptDecoder())}return s[r].slice(n,n+a)}))).then((t=>{e.bufferViews=t}))}}class Oe{static parse(e,t){const{gltf:s,bufferViews:r,path:i,loadItems:n}=e;if(!s.images)return;const a=t.extensions.get("KHR_texture_basisu");return Promise.all(s.images.map(((e,s)=>{const{uri:o,bufferView:l,mimeType:c,name:d}=e;let h=!1,u=o||"";if(void 0!==l){const e=r[l],t=new Blob([e],{type:c});u=URL.createObjectURL(t),h=!0}const p=we.resolveURL(u,i);let m;if(t.detailLoadProgress&&n.delete(p),c&&c.includes("ktx2")&&a)m=a.loadTextureData(p,t.getKTX2Loader()).then((e=>(t.detailLoadProgress&&(h?t.manager.itemEnd(we.resolveURL("blob<"+s+">",i)):t.manager.itemEnd(p)),e)));else{const e={loader:t,imageUrl:p,imageName:d,isObjectURL:h,sourceUrl:u,index:s,path:i};if(!c||!c.includes("avif")&&!c.includes("webp"))return Pe(e);m=function(e){const t=new Promise((t=>{const s=new Image;e.includes("avif")?s.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=":s.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",s.onload=()=>{t(1===s.height)}}));return t}(c).then((t=>{if(t)return Pe(e);throw new Error("GLTFLoader: WebP or AVIF required by asset but unsupported.")}))}return t.detailLoadProgress&&m.catch((()=>t.manager.itemEnd(p))),m}))).then((t=>{e.images=t}))}}function Pe(e){const{loader:t,imageUrl:s,imageName:r,isObjectURL:i,sourceUrl:n,index:a,path:o}=e;return t.loadImage(s).then((e=>(e.__name=r,!0===i&&URL.revokeObjectURL(n),t.detailLoadProgress&&(i?t.manager.itemEnd(we.resolveURL("blob<"+a+">",o)):t.manager.itemEnd(s)),e)))}const Ie={POSITION:"a_Position",NORMAL:"a_Normal",TANGENT:"a_Tangent",TEXCOORD_0:"a_Uv",TEXCOORD_1:"a_Uv2",TEXCOORD_2:"a_Uv3",TEXCOORD_3:"a_Uv4",TEXCOORD_4:"a_Uv5",TEXCOORD_5:"a_Uv6",TEXCOORD_6:"a_Uv7",TEXCOORD_7:"a_Uv8",COLOR_0:"a_Color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex",TEXCOORD0:"a_Uv",TEXCOORD:"a_Uv",COLOR0:"a_Color",COLOR:"a_Color",WEIGHT:"skinWeight",JOINT:"skinIndex"},De="MASK",Be="BLEND",Ne={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Fe={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Ue={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},ke={9728:t.TEXTURE_FILTER.NEAREST,9729:t.TEXTURE_FILTER.LINEAR,9984:t.TEXTURE_FILTER.NEAREST_MIPMAP_NEAREST,9985:t.TEXTURE_FILTER.LINEAR_MIPMAP_NEAREST,9986:t.TEXTURE_FILTER.NEAREST_MIPMAP_LINEAR,9987:t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR},Ve={33071:t.TEXTURE_WRAP.CLAMP_TO_EDGE,33648:t.TEXTURE_WRAP.MIRRORED_REPEAT,10497:t.TEXTURE_WRAP.REPEAT},Ge=0,ze=1,He=2,$e=3,Ke=5,je=6;class Xe{static parse(e){const{gltf:s,images:r}=e;if(!s.textures)return;const i=new Map;return Promise.all(s.textures.map(((e,n)=>{const{sampler:a,source:o=0,name:l}=e;let c=o,d=!1;if(e.extensions){const{KHR_texture_basisu:t}=e.extensions;t?(c=t.source,d=!0):Object.values(e.extensions).length&&Object.values(e.extensions)[0].hasOwnProperty("source")?c=Object.values(e.extensions)[0].source:console.warn("GLTFLoader: unknown texture extension")}const h=c+":"+a;if(i.has(h))return i.get(h);const u=new t.Texture2D;if(d){const{image:e,mipmaps:t,type:s,format:i,minFilter:n,magFilter:a,generateMipmaps:o,encoding:l,premultiplyAlpha:d}=r[c];u.image=e,u.mipmaps=t,u.type=s,u.format=i,u.minFilter=n,u.magFilter=a,u.generateMipmaps=o,u.encoding=l,u.premultiplyAlpha=d}else u.image=r[c];u.version++,u.name=l||u.image.__name||`texture_${n}`,u.flipY=!1;return function(e,s={}){const{magFilter:r,minFilter:i,wrapS:n,wrapT:a}=s;e.magFilter=ke[r]||t.TEXTURE_FILTER.LINEAR,e.minFilter=ke[i]||t.TEXTURE_FILTER.LINEAR_MIPMAP_LINEAR,e.wrapS=Ve[n]||t.TEXTURE_WRAP.REPEAT,e.wrapT=Ve[a]||t.TEXTURE_WRAP.REPEAT}(u,(s.samplers||{})[a]),i.set(h,u),u}))).then((t=>{e.textures=t,i.clear()}))}}class Ye{static parse(e){const{bufferViews:s,gltf:r}=e;if(!r.accessors)return;const i=new Map,n=r.accessors.map((e=>{const{bufferView:n,type:a,componentType:o,count:l,byteOffset:c=0,normalized:d=!1,sparse:h}=e;if(void 0===n&&void 0===h)return null;const u=void 0!==n?s[n]:null,p=void 0!==n?r.bufferViews[n].byteStride:void 0,m=Fe[a],f=Ue[o],g=f.BYTES_PER_ELEMENT;let _,b;if(p&&p!==g*m){const e=Math.floor(c/p),s="Buffer:"+n+":"+o+":"+e+":"+l;let r=i.get(s);r||(_=new f(u,e*p,l*p/g),r=new t.Buffer(_,p/g),i.set(s,r)),b=new t.Attribute(r,m,c%p/g,d)}else _=null===u?new f(l*m):new f(u,c,l*m),b=new t.Attribute(new t.Buffer(_,m),m,0,d);if(h){const e=Fe.SCALAR,r=Ue[h.indices.componentType],i=h.indices.byteOffset||0,n=h.values.byteOffset||0,a=new r(s[h.indices.bufferView],i,h.count*e),o=new f(s[h.values.bufferView],n,h.count*m);null!==u&&(b=new t.Attribute(b.buffer.clone(),b.size,b.offset,b.normalized));const l=b.buffer;for(let e=0,t=a.length;e<t;e++){const t=a[e];if(l.array[t*b.size]=o[e*m],m>=2&&(l.array[t*b.size+1]=o[e*m+1]),m>=3&&(l.array[t*b.size+2]=o[e*m+2]),m>=4&&(l.array[t*b.size+3]=o[e*m+3]),m>=5)throw new Error("Unsupported itemSize in sparse Attribute.")}}return b}));i.clear(),e.accessors=n}}let We=class{static parse(e,s){const{gltf:r,accessors:i,materials:n,bufferViews:a}=e;if(!r.meshes)return;const o=s.extensions.get("KHR_draco_mesh_compression"),l=new Map,c=new Map,d=[];for(let e=0;e<r.meshes.length;e++){const h=r.meshes[e],u=[];for(let e=0;e<h.primitives.length;e++){const d=h.primitives[e],{extensions:p={},mode:m,material:f}=d,{KHR_draco_mesh_compression:g}=p;let _;const b=qe(d);c.has(b)?_=c.get(b):(_=g&&o?o.getGeometry(g,a,d.attributes,r.accessors,s.getDRACOLoader()):Promise.resolve(new t.Geometry),_=_.then((e=>(Qe(e,d,r,i),e))),c.set(b,_));const x=_.then((e=>{const s={mode:m,geometry:e,material:void 0===f?new t.PBRMaterial:n[f],weights:Object.keys(e.morphAttributes).length>0&&h.weights?h.weights.slice(0):void 0,skinned:h.isSkinned};return Je(s,l),s}));u.push(x)}d.push(Promise.all(u))}return l.clear(),c.clear(),Promise.all(d).then((t=>{e.primitives=t}))}};function Qe(e,t,s,r){const{attributes:i,indices:n,targets:a}=t;for(const t in i){const s=i[t],n=void 0===Ie[t]?t:Ie[t];n in e.attributes||e.addAttribute(n,r[s])}void 0===n||e.index||e.setIndex(r[n]);const{boundingBox:o,boundingSphere:l}=e;if(void 0!==i.POSITION){const t=i.POSITION,r=s.accessors[t];if(r.min&&r.max){if(o.min.fromArray(r.min),o.max.fromArray(r.max),r.normalized){const e=we.getNormalizedComponentScale(Ue[r.componentType]);o.min.multiplyScalar(e),o.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(o.getCenter(l.center),l.radius=o.min.distanceTo(o.max)/2,a){let t=!1,s=!1;for(let e=0,r=a.length;e<r;e++){const r=a[e];if(void 0!==r.POSITION&&(t=!0),void 0!==r.NORMAL&&(s=!0),t&&s)break}if(t||s){const i=[],n=[];for(let o=0,l=a.length;o<l;o++){const l=a[o];t&&i.push(void 0!==l.POSITION?r[l.POSITION]:e.attributes[Ie.POSITION]),s&&n.push(void 0!==l.NORMAL?r[l.NORMAL]:e.attributes[Ie.NORMAL])}t&&(e.morphAttributes.position=i),s&&(e.morphAttributes.normal=n)}}return e}function Je(e,s){let{geometry:r,material:i,skinned:n,mode:a}=e;const o=void 0!==r.attributes[Ie.TANGENT],l=void 0!==r.attributes[Ie.COLOR_0],c=void 0===r.attributes[Ie.NORMAL],d=n;if(a===Ge){const e="PointsMaterial:"+i.id;let r=s.get(e);r||(r=new t.PointsMaterial,t.Material.prototype.copy.call(r,i),r.diffuse.copy(i.diffuse),r.diffuseMap=i.map,r.drawMode=a,r.acceptLight=!1,s.set(e,r)),i=r}else if(a===ze||a===$e||a===He){const e="BasicMaterial:"+i.id;let r=s.get(e);r||(r=new t.BasicMaterial,r.envMap=void 0,r.diffuse.copy(i.diffuse),r.diffuseMap=i.diffuseMap,r.drawMode=a,s.set(e,r)),i=r}else a===Ke?(console.warn("TRIANGLE_STRIP will be removed later."),i.drawMode=Ke):a===je&&(console.warn("TRIANGLE_FAN will be removed later."),i.drawMode=je);if(o||l||c||d){let e="ClonedMaterial:"+i.id+":";o&&(e+="vertex-tangents:"),l&&(3===r.attributes[Ie.COLOR_0].size?e+="vertex-colors-rgb:":4===r.attributes[Ie.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let n=s.get(e);n||(n=i.clone(),o&&(n.vertexTangents=!0,n.normalMap&&(n.normalScale.y*=-1)),l&&(3===r.attributes[Ie.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGB:4===r.attributes[Ie.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+r.attributes[Ie.COLOR_0].size)),c&&(n.shading=t.SHADING_TYPE.FLAT_SHADING)),i=n}e.material=i}function qe(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let s;if(s=t?"draco:"+t.bufferView+":"+t.indices+":"+Ze(t.attributes):e.indices+":"+Ze(e.attributes)+":"+e.mode,e.targets)for(let t=0,r=e.targets.length;t<r;t++)s+=":"+Ze(e.targets[t]);return s}function Ze(e){let t="";const s=Object.keys(e).sort();for(let r=0,i=s.length;r<i;r++)t+=s[r]+":"+e[s[r]]+";";return t}class et{static parse(e,s){const{gltf:{nodes:r,cameras:i,extensions:n}}=e;if(!r)return;const a=s.extensions.get("KHR_lights_punctual"),o=s.extensions.get("EXT_mesh_gpu_instancing"),l=[],c=[],d=r.map((s=>{const{matrix:r,translation:d,rotation:h,scale:u,camera:p,mesh:m,extensions:f={}}=s,{KHR_lights_punctual:g,EXT_mesh_gpu_instancing:_}=f;let b=null;if(s.isBone)b=new t.Bone;else if(void 0!==m)b=_&&o?o.getInstancedMesh(e,s):function(e,s){const{primitives:r}=e,{mesh:i,skin:n}=s,a=r[i].map((e=>{const{geometry:s,material:r,weights:i}=e;let a;return void 0!==n?(a=new t.SkinnedMesh(s,r),s.attributes.skinWeight&&!s.attributes.skinWeight.normalized&&we.normalizeSkinWeights(s.attributes.skinWeight)):(a=new t.Mesh(s,r),i&&(a.morphTargetInfluences=i.slice())),a}));if(a.length>1){const e=new t.Object3D;return a.forEach((t=>e.add(t))),e}return a[0]}(e,s);else if(void 0!==p)b=function(e){const{orthographic:s,perspective:r,type:i}=e,n=new t.Camera;if("perspective"==i){const{aspectRatio:e,yfov:t,zfar:s,znear:i}=r;n.setPerspective(t,e||1,i||1,s||2e6)}else if("orthographic"==i){const{xmag:e,ymag:t,zfar:r,znear:i}=s;n.setOrtho(-e,e,-t,t,i||1,r||2e6)}return n}(i[p]),l.push(b);else if(g&&a){const e=g.light,t=n.KHR_lights_punctual.lights;b=a.getLight(t[e]),c.push(b)}else b=new t.Object3D;if(b.name=s.name||"",b.name&&b.children.length>0)for(let e=0;e<b.children.length;e++)b.children[e].name=b.name+"_"+e;return void 0!==r?(b.matrix.fromArray(r),b.matrix.decompose(b.position,b.quaternion,b.scale)):(void 0!==d&&b.position.fromArray(d),void 0!==h&&b.quaternion.fromArray(h),void 0!==u&&b.scale.fromArray(u)),b}));e.nodes=d,e.cameras=l,e.lights=c}}class tt{static parse(e){const{gltf:s,accessors:r,nodes:i}=e,n=s.skins;if(!n)return;const a=n.map((e=>{const{inverseBindMatrices:s,joints:n}=e,a=r[s],o=[],l=[];return n.forEach(((e,s)=>{const r=i[e];if(r){o.push(r);const e=new t.Matrix4;a&&e.fromArray(a.buffer.array,16*s),l.push(e)}else console.warn("Joint "+e+" could not be found.")})),new t.Skeleton(o,l)}));e.skins=a,i.forEach(((e,t)=>{const{skin:r}=s.nodes[t];void 0!==r&&e.traverse((function(e){e.isSkinnedMesh&&e.bind(a[r],e.worldMatrix)}))}))}}class st{static parse(e){const{gltf:s,nodes:r}=e,i=s.scenes.map((e=>{const{name:i="",nodes:n=[]}=e,a=new t.Object3D;a.name=i;for(let e=0;e<n.length;e++)rt(n[e],a,s.nodes,r);return a}));e.roots=i,e.root=i[s.scene||0]}}function rt(e,t,s,r){const i=r[e],n=s[e];if(t.add(i),n.children){const e=n.children;for(let t=0,n=e.length;t<n;t++){rt(e[t],i,s,r)}}}class it{static parse(e){const{gltf:s,nodes:r,accessors:i}=e,{animations:n}=s;if(!n)return;const a=n.map(((e,s)=>{const{channels:n,samplers:a,name:o=`animation_${s}`}=e,l=[];let c=0;for(let e=0;e<n.length;e++){const s=n[e],o=a[s.sampler];if(o){const e=s.target,n=void 0!==e.node?e.node:e.id,a=i[o.input],d=i[o.output],h=r[n];if(!h)continue;let u;switch(h.updateMatrix(),h.matrixAutoUpdate=!0,Ne[e.path]){case Ne.rotation:u=t.QuaternionKeyframeTrack;break;case Ne.weights:u=t.NumberKeyframeTrack;break;default:u=t.VectorKeyframeTrack}if(!u)continue;const p=new a.buffer.array.constructor(a.buffer.array),m=new Float32Array(d.buffer.array);if(d.normalized){const e=we.getNormalizedComponentScale(d.buffer.array.constructor);for(let t=0,s=m.length;t<s;t++)m[t]*=e}const f=[];Ne[e.path]===Ne.weights?h.traverse((function(e){e.isMesh&&e.morphTargetInfluences&&f.push(e)})):f.push(h);for(let s=0,r=f.length;s<r;s++){const r=nt(o.interpolation,u===t.QuaternionKeyframeTrack),i=new u(f[s],Ne[e.path],p,m,r);l.push(i)}const g=p[p.length-1];c<g&&(c=g)}}return new t.KeyframeClip(o,l,c)}));e.animations=a}}function nt(e,s){switch(e){case"STEP":return t.StepInterpolant;case"CUBICSPLINE":return s?t.QuaternionCubicSplineInterpolant:t.CubicSplineInterpolant;default:return s?t.QuaternionLinearInterpolant:t.LinearInterpolant}}let at=0;class ot{constructor(){this.id=++at,this.url="",this.path="",this.options=null,this.gltf=null,this.loadItems=null,this.buffers=null,this.bufferViews=null,this.images=null,this.textures=null,this.materials=null,this.accessors=null,this.primitives=null,this.nodes=null,this.cameras=null,this.lights=null,this.skins=null,this.root=null,this.roots=null,this.animations=null}}class lt{static getMaterial(){return new t.PBRMaterial}static parseParams(e,s,r){const{clearcoatFactor:i,clearcoatTexture:n,clearcoatRoughnessFactor:a,clearcoatRoughnessTexture:o,clearcoatNormalTexture:l}=s;if(i&&(e.clearcoat=i),n&&(e.clearcoatMap=r[n.index]),a&&(e.clearcoatRoughness=a),o&&(e.clearcoatRoughnessMap=r[o.index]),l&&(e.clearcoatNormalMap=r[l.index],l.scale)){const s=l.scale;e.clearcoatNormalScale=new t.Vector2(s,s)}}}class ct{static getMaterial(){return new t.PBR2Material}static parseParams(e,s,r,i){const{diffuseFactor:n,diffuseTexture:a,specularFactor:o,glossinessFactor:l,specularGlossinessTexture:c}=s;Array.isArray(n)&&(e.diffuse.fromArray(n),e.opacity=n[3]||1),a&&(e.diffuseMap=r[a.index],e.diffuseMapCoord=a.texCoord||0,e.diffuseMap&&(e.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,i&&i.handleMaterialMap(e,"diffuseMap",a))),e.glossiness=void 0!==l?l:1,Array.isArray(o)&&e.specular.fromArray(o),c&&(e.glossinessMap=r[c.index],e.specularMap=r[c.index])}}const dt=[class{static parse(e,t){const{url:s}=e;return t.loadFile(s,"arraybuffer").then((t=>{if("glTF"===we.decodeText(new Uint8Array(t,0,4))){const s=we.parseGLB(t);e.gltf=s.gltf,e.buffers=s.buffers}else{const s=we.decodeText(new Uint8Array(t));e.gltf=JSON.parse(s)}}))}},Le,Re,Se,Ce,Oe,Xe,class{static parse(e,s){const{gltf:r,textures:i}=e;if(!r.materials)return;const n=s.extensions.get("KHR_texture_transform"),a=s.extensions.get("KHR_materials_unlit"),o=s.extensions.get("KHR_materials_pbrSpecularGlossiness"),l=s.extensions.get("KHR_materials_clearcoat"),c=[];for(let e=0;e<r.materials.length;e++){const{extensions:s={},pbrMetallicRoughness:d,normalTexture:h,occlusionTexture:u,emissiveTexture:p,emissiveFactor:m,alphaMode:f,alphaCutoff:g,doubleSided:_,name:b=""}=r.materials[e],{KHR_materials_unlit:x,KHR_materials_pbrSpecularGlossiness:A,KHR_materials_clearcoat:y}=s;let T=null;if(x&&a?T=a.getMaterial():A&&o?(T=o.getMaterial(),o.parseParams(T,A,i,n)):y&&l?(T=l.getMaterial(),l.parseParams(T,y,i)):T=new t.PBRMaterial,T.name=b,d){const{baseColorFactor:e,baseColorTexture:s,metallicFactor:r,roughnessFactor:a,metallicRoughnessTexture:o}=d;Array.isArray(e)&&(T.diffuse.fromArray(e),T.opacity=void 0!==e[3]?e[3]:1),s&&(T.diffuseMap=i[s.index],T.diffuseMapCoord=s.texCoord||0,T.diffuseMap&&(T.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(T,"diffuseMap",s))),x||A||(T.metalness=void 0!==r?r:1,T.roughness=void 0!==a?a:1,o&&(T.metalnessMap=i[o.index],T.roughnessMap=i[o.index]))}m&&T.emissive.fromArray(m),p&&(T.emissiveMap=i[p.index],T.emissiveMapCoord=p.texCoord||0,T.emissiveMap&&(T.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(T,"emissiveMap",p))),u&&(T.aoMap=i[u.index],T.aoMapCoord=u.texCoord||0,void 0!==u.strength&&(T.aoMapIntensity=u.strength),T.aoMap&&n&&n.handleMaterialMap(T,"aoMap",u)),x||h&&(T.normalMap=i[h.index],T.normalScale.set(1,-1),void 0!==h.scale&&T.normalScale.set(h.scale,-h.scale)),T.side=!0===_?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,f===Be?T.transparent=!0:(T.transparent=!1,f===De&&(T.alphaTest=void 0!==g?g:.5)),c[e]=T}e.materials=c}},Ye,We,et,tt,st,it],ht=new Map([["EXT_meshopt_compression",class{static loadBufferView(e,t,s){const r=t[e.buffer];if(!s||!s.supported)throw new Error("GLTFLoader: setMeshoptDecoder must be called before loading compressed files.");const i=e.byteOffset||0,n=e.byteLength||0,a=e.count,o=e.byteStride,l=new Uint8Array(r,i,n);return s.decodeGltfBufferAsync?s.decodeGltfBufferAsync(a,o,l,e.mode,e.filter).then((e=>e.buffer)):s.ready.then((()=>{const t=new ArrayBuffer(a*o);return s.decodeGltfBuffer(new Uint8Array(t),a,o,l,e.mode,e.filter),t}))}}],["KHR_draco_mesh_compression",class{static getGeometry(e,t,s,r,i){const{bufferView:n,attributes:a}=e;if(!i)throw new Error("GLTFLoader: No DRACOLoader instance provided.");const o={};for(const e in a){o[void 0===Ie[e]?e:Ie[e]]=a[e]}const l={},c={};for(const e in s){const t=Ie[e]||e.toLowerCase();if(void 0!==a[e]){const i=r[s[e]],n=Ue[i.componentType];c[t]=n.name,l[t]=!0===i.normalized}}const d=t[n];return new Promise((function(e){i.decodeDracoFile(d,(function(t){for(const e in t.attributes){const s=t.attributes[e],r=l[e];void 0!==r&&(s.normalized=r)}e(t)}),o,c)}))}}],["KHR_lights_punctual",class{static getLight(e){const{color:s,intensity:r=1,type:i,range:n,spot:a}=e;let o;if("directional"===i)o=new t.DirectionalLight;else if("point"===i)o=new t.PointLight,void 0!==n&&(o.distance=n);else{if("spot"!==i)throw new Error("Unexpected light type: "+i);if(o=new t.SpotLight,void 0!==n&&(o.distance=n),a){const{innerConeAngle:e=0,outerConeAngle:t=Math.PI/4}=a;o.angle=t,o.penumbra=1-e/t}}return s&&o.color.fromArray(s),o.intensity=r,o}}],["KHR_materials_clearcoat",lt],["KHR_materials_pbrSpecularGlossiness",ct],["KHR_materials_unlit",class{static getMaterial(){return new t.BasicMaterial}}],["KHR_mesh_quantization",{}],["KHR_texture_basisu",class{static loadTextureData(e,t){return new Promise(((s,r)=>{t.load(e,s,void 0,r)}))}}],["KHR_texture_transform",class{static handleMaterialMap(e,t,s){if(!s.extensions)return;const r=s.extensions.KHR_texture_transform;if(!r)return;let i=0,n=0,a=1,o=1,l=0;void 0!==r.offset&&(i=r.offset[0],n=r.offset[1]),void 0!==r.rotation&&(l=r.rotation),void 0!==r.scale&&(a=r.scale[0],o=r.scale[1]);const c=e[t+"Transform"];c&&c.setUvTransform(i,n,a,o,l,0,0),void 0!==r.texCoord&&(e[t+"Coord"]=r.texCoord)}}]]);class ut{constructor(e=t.DefaultLoadingManager,s=dt,r=ht){this.manager=e,this.detailLoadProgress=!0,this.autoLogError=!0,this.extensions=new Map(r),this._parsers=s.slice(0),this._dracoLoader=null,this._meshoptDecoder=null,this._ktx2Loader=null,this._fileLoader=new t.FileLoader;const i=navigator.userAgent,n=!0===/^((?!chrome|android).)*safari/i.test(i),a=i.match(/Version\/(\d+)/),o=n&&a?parseInt(a[1],10):-1,l=i.indexOf("Firefox")>-1,c=l?i.match(/Firefox\/([0-9]+)\./)[1]:-1;"undefined"==typeof createImageBitmap||n&&o<17||l&&c<98?this._imageLoader=new t.ImageLoader:this._imageLoader=new Ee}load(e,t={}){return this.manager.itemStart(e),new Promise(((s,r)=>{const i=new ot;i.url=e,i.path=we.extractUrlBase(e),i.options=t,this._parse(i).then(s).then((()=>this.manager.itemEnd(e))).catch((t=>{this.autoLogError&&console.error(t),this.detailLoadProgress&&i.loadItems&&i.loadItems.forEach((e=>{this.manager.itemEnd(e)})),this.manager.itemError(e),this.manager.itemEnd(e),r(`Error loading glTF model from ${e} .`)}))}))}_parse(e){let t;return new Promise(((s,r)=>{this._parsers.forEach((s=>{t=t?t.then((()=>s.parse(e,this))):s.parse(e,this)})),t?t.then((()=>s(e))).catch(r):s(e)}))}setDRACOLoader(e){return this._dracoLoader=e,this}getDRACOLoader(){return this._dracoLoader}setMeshoptDecoder(e){return this._meshoptDecoder=e,this}getMeshoptDecoder(){return this._meshoptDecoder}setKTX2Loader(e){return this._ktx2Loader=e,this}getKTX2Loader(){return this._ktx2Loader}loadFile(e,t="json"){return this._fileLoader.setResponseType(t),new Promise(((t,s)=>{e=this.manager.resolveURL(e),this._fileLoader.load(e,t,void 0,s)}))}loadImage(e){return new Promise(((t,s)=>{e=this.manager.resolveURL(e),this._imageLoader.load(e,t,void 0,s)}))}insertParser(e,t){this._parsers.splice(t,0,e)}replaceParser(e,t){this._parsers.splice(t,1,e)}}class pt{static parse(e,t){const s=e.options.buffer,r=new DataView(s),i=String.fromCharCode(r.getUint8(0))+String.fromCharCode(r.getUint8(1))+String.fromCharCode(r.getUint8(2))+String.fromCharCode(r.getUint8(3)),n=Z(e.url);if(i!==n)throw`Not a ${n} type resource, with url ${e.url}!`;const a=r.getUint32(4,!0);if(1!==a)throw`${n} version must be 1, with url ${e.url}!`;const o=r.getUint32(8,!0);if(o!==s.byteLength)throw`${n} data byte length check failed, with url ${e.url}!`;if("cmpt"===n){const t=r.getUint32(12,!0);return void(e.header={magic:i,version:a,byteLength:o,tilesLength:t})}const l=r.getUint32(12,!0),c=r.getUint32(16,!0),d=r.getUint32(20,!0),h=r.getUint32(24,!0);let u=null;"i3dm"===n&&(u=r.getUint32(28,!0)),e.header={magic:i,version:a,byteLength:o,featureTableJSONByteLength:l,featureTableBinaryByteLength:c,batchTableJSONByteLength:d,batchTableBinaryByteLength:h,gltfFormat:u}}}class mt{constructor(e,t,s,r){this.buffer=e,this.binOffset=t+s,this.binLength=r;let i=null;if(0!==s){const r=new Uint8Array(e,t,s);i=JSON.parse(we.decodeText(r))}else i={};this.header=i}getKeys(){return Object.keys(this.header)}getData(e,t,s=null,r=null){const i=this.header;if(!(e in i))return null;const n=i[e];if(n instanceof Object){if(Array.isArray(n))return n;{const{buffer:i,binOffset:a,binLength:o}=this,l=n.byteOffset||0,c=n.type||r,d=n.componentType||s;if("type"in n&&r&&n.type!==r)throw new Error("FeatureTable: Specified type does not match expected type.");let h,u;switch(c){case"SCALAR":h=1;break;case"VEC2":h=2;break;case"VEC3":h=3;break;case"VEC4":h=4;break;default:throw new Error(`FeatureTable: Feature type not provided for "${e}".`)}const p=a+l,m=t*h;switch(d){case"BYTE":u=new Int8Array(i,p,m);break;case"UNSIGNED_BYTE":u=new Uint8Array(i,p,m);break;case"SHORT":u=new Int16Array(i,p,m);break;case"UNSIGNED_SHORT":u=new Uint16Array(i,p,m);break;case"INT":u=new Int32Array(i,p,m);break;case"UNSIGNED_INT":u=new Uint32Array(i,p,m);break;case"FLOAT":u=new Float32Array(i,p,m);break;case"DOUBLE":u=new Float64Array(i,p,m);break;default:throw new Error(`FeatureTable: Feature component type not provided for "${e}".`)}if(p+m*u.BYTES_PER_ELEMENT>a+o)throw new Error("FeatureTable: Feature data read outside binary body length.");return u}}return n}}class ft extends mt{constructor(e,t,s,r,i){super(e,s,r,i),this.batchSize=t}getData(e,t=null,s=null){return super.getData(e,this.batchSize,t,s)}}class gt{static parse(e,t){const{header:s,options:r}=e,i=r.buffer,n="i3dm"===s.magic?32:28,a=n+s.featureTableJSONByteLength+s.featureTableBinaryByteLength,o=a,l=o+s.batchTableJSONByteLength+s.batchTableBinaryByteLength,c=i.slice(n,a),d=new mt(c,0,s.featureTableJSONByteLength,s.featureTableBinaryByteLength);let h;if("b3dm"===s.magic)h=d.getData("BATCH_LENGTH");else if("i3dm"===s.magic)h=d.getData("INSTANCES_LENGTH");else{if("pnts"!==s.magic)throw`Unrecognized magic: ${s.magic}!`;h=d.getData("BATCH_LENGTH")||d.getData("POINTS_LENGTH")}const u=i.slice(o,l),p=new ft(u,h,0,s.batchTableJSONByteLength,s.batchTableBinaryByteLength);e.featureTable=d,e.batchTable=p,e.batchTableEnd=l}}class _t{static parse(e,t){const s=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd),r=we.parseGLB(s.slice().buffer);e.gltf=r.gltf,e.buffers=r.buffers}}let bt=class{static parse(e,s){const{gltf:r,textures:i}=e;if(!r.materials)return;const n=s.extensions.get("KHR_texture_transform"),a=s.extensions.get("KHR_materials_unlit"),o=s.extensions.get("KHR_materials_pbrSpecularGlossiness"),l=s.extensions.get("KHR_materials_clearcoat"),c=s.extensions.get("KHR_techniques_webgl"),d=[];for(let e=0;e<r.materials.length;e++){const{extensions:s={},pbrMetallicRoughness:h,normalTexture:u,occlusionTexture:p,emissiveTexture:m,emissiveFactor:f,alphaMode:g,alphaCutoff:_,doubleSided:b,name:x=""}=r.materials[e],{KHR_materials_unlit:A,KHR_materials_pbrSpecularGlossiness:y,KHR_materials_clearcoat:T,KHR_techniques_webgl:M}=s;let E=null;if(A&&a?E=a.getMaterial():y&&o?(E=o.getMaterial(),o.parseParams(E,y,i,n)):T&&l?(E=l.getMaterial(),l.parseParams(E,T,i)):M&&c?(E=c.getMaterial(),c.parseParams(E,M,i)):E=new t.PBRMaterial,E.name=x,h){const{baseColorFactor:e,baseColorTexture:s,metallicFactor:r,roughnessFactor:a,metallicRoughnessTexture:o}=h;Array.isArray(e)&&(E.diffuse.fromArray(e),E.opacity=void 0!==e[3]?e[3]:1),s&&(E.diffuseMap=i[s.index],E.diffuseMapCoord=s.texCoord||0,E.diffuseMap&&(E.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(E,"diffuseMap",s))),A||y||(E.metalness=void 0!==r?r:1,E.roughness=void 0!==a?a:1,o&&(E.metalnessMap=i[o.index],E.roughnessMap=i[o.index]))}f&&E.emissive.fromArray(f),m&&(E.emissiveMap=i[m.index],E.emissiveMapCoord=m.texCoord||0,E.emissiveMap&&(E.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(E,"emissiveMap",m))),p&&(E.aoMap=i[p.index],E.aoMapCoord=p.texCoord||0,void 0!==p.strength&&(E.aoMapIntensity=p.strength),E.aoMap&&n&&n.handleMaterialMap(E,"aoMap",p)),A||u&&(E.normalMap=i[u.index],E.normalScale.set(1,-1),void 0!==u.scale&&E.normalScale.set(u.scale,-u.scale)),E.side=!0===b?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,g===Be?E.transparent=!0:(E.transparent=!1,g===De&&(E.alphaTest=void 0!==_?_:.5)),d[e]=E}e.materials=d}};class xt{static parse(e,t){const{root:s,featureTable:r,options:i}=e,n=r.getData("RTC_CENTER");n&&(s.position.x+=n[0],s.position.y+=n[1],s.position.z+=n[2]),i.adjustmentTransform&&(s.matrix.transform(s.position,s.scale,s.quaternion),s.matrix.multiply(i.adjustmentTransform),s.matrix.decompose(s.position,s.quaternion,s.scale))}}class At{static getMaterial(){return new t.PBRMaterial}static parseParams(e,t,s){const{values:r}=t,{u_diffuse:i}=r;i&&(e.diffuseMap=s[i.index],e.diffuseMapCoord=i.texCoord||0)}}class yt extends ut{constructor(e){super(e,[pt,gt,_t,Le,Re,Se,Ce,Oe,Xe,bt,Ye,We,et,tt,st,it,xt]),this.extensions.set("KHR_techniques_webgl",At)}}class Tt{static parse(e,t){const s=new Uint8Array(e.options.buffer,e.batchTableEnd,e.header.byteLength-e.batchTableEnd);let r=null;if(1===e.header.gltfFormat)r=Promise.resolve(s);else{const i=we.resolveURL(we.decodeText(s),e.path);r=t.loadFile(i,"arraybuffer").then((e=>new Uint8Array(e)))}return r.then((t=>{const s=we.parseGLB(t.slice().buffer);e.gltf=s.gltf,e.buffers=s.buffers}))}}const Mt="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\tattribute mat4 instanceMatrix;\n\t\t#endif\n",Et="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\ttransformed = (instanceMatrix * vec4(transformed, 1.0)).xyz;\n\t\t#endif\n",vt="\n\t\t#ifdef USE_INSTANCING\n\t\t\t\t#ifdef USE_INSTANCING\n\t\t\t\t\t\tobjectNormal = (transposeMat4(inverseMat4(instanceMatrix)) * vec4(objectNormal, 0.0)).xyz;\n\t\t\t\t#endif\n\n\t\t\t\t#ifdef USE_TANGENT\n\t\t\t\t\t\tobjectTangent = (transposeMat4(inverseMat4(instanceMatrix)) * vec4(objectTangent, 0.0)).xyz;\n\t\t\t\t#endif\n\t\t#endif\n";class wt extends t.PBRMaterial{constructor(){super(),this.type=t.MATERIAL_TYPE.SHADER,this.shaderName="TILE_I_PBR",this.vertexShader=Lt,this.fragmentShader=t.ShaderLib.pbr_frag,this.defines.USE_INSTANCING=!0}}wt.prototype.isInstancedPBRMaterial=!0;let Lt=t.ShaderLib.pbr_vert;Lt=Lt.replace("#include <logdepthbuf_pars_vert>",`\n\t\t#include <logdepthbuf_pars_vert>\n\t\t${Mt}\n`),Lt=Lt.replace("#include <pvm_vert>",`\n\t\t${Et}\n\t\t#include <pvm_vert>\n`),Lt=Lt.replace("#include <normal_vert>",`\n\t\t${vt}\n\t\t#include <normal_vert>\n`);class Rt{static parse(e,s){const{gltf:r,textures:i}=e;if(!r.materials)return;const n=s.extensions.get("KHR_texture_transform"),a=s.extensions.get("KHR_materials_unlit"),o=s.extensions.get("KHR_materials_pbrSpecularGlossiness"),l=s.extensions.get("KHR_materials_clearcoat"),c=s.extensions.get("KHR_techniques_webgl"),d=[];for(let e=0;e<r.materials.length;e++){const{extensions:s={},pbrMetallicRoughness:h,normalTexture:u,occlusionTexture:p,emissiveTexture:m,emissiveFactor:f,alphaMode:g,alphaCutoff:_,doubleSided:b,name:x=""}=r.materials[e],{KHR_materials_unlit:A,KHR_materials_pbrSpecularGlossiness:y,KHR_materials_clearcoat:T,KHR_techniques_webgl:M}=s;let E=null;if(A&&a?E=a.getMaterial():y&&o?(E=o.getMaterial(),o.parseParams(E,y,i,n)):T&&l?(E=l.getMaterial(),l.parseParams(E,T,i)):M&&c?(E=c.getMaterial(),c.parseParams(E,M,i)):E=new wt,E.name=x,h){const{baseColorFactor:e,baseColorTexture:s,metallicFactor:r,roughnessFactor:a,metallicRoughnessTexture:o}=h;Array.isArray(e)&&(E.diffuse.fromArray(e),E.opacity=void 0!==e[3]?e[3]:1),s&&(E.diffuseMap=i[s.index],E.diffuseMapCoord=s.texCoord||0,E.diffuseMap&&(E.diffuseMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(E,"diffuseMap",s))),A||y||(E.metalness=void 0!==r?r:1,E.roughness=void 0!==a?a:1,o&&(E.metalnessMap=i[o.index],E.roughnessMap=i[o.index]))}f&&E.emissive.fromArray(f),m&&(E.emissiveMap=i[m.index],E.emissiveMapCoord=m.texCoord||0,E.emissiveMap&&(E.emissiveMap.encoding=t.TEXEL_ENCODING_TYPE.SRGB,n&&n.handleMaterialMap(E,"emissiveMap",m))),p&&(E.aoMap=i[p.index],E.aoMapCoord=p.texCoord||0,void 0!==p.strength&&(E.aoMapIntensity=p.strength),E.aoMap&&n&&n.handleMaterialMap(E,"aoMap",p)),A||u&&(E.normalMap=i[u.index],E.normalScale.set(1,-1),void 0!==u.scale&&E.normalScale.set(u.scale,-u.scale)),E.side=!0===b?t.DRAW_SIDE.DOUBLE:t.DRAW_SIDE.FRONT,g===Be?E.transparent=!0:(E.transparent=!1,g===De&&(E.alphaTest=void 0!==_?_:.5)),d[e]=E}e.materials=d}}class St{static parse(e,s){const{gltf:r,accessors:i,materials:n,bufferViews:a}=e;if(!r.meshes)return;const o=s.extensions.get("KHR_draco_mesh_compression"),l=new Map,c=new Map,d=[];for(let e=0;e<r.meshes.length;e++){const h=r.meshes[e],u=[];for(let e=0;e<h.primitives.length;e++){const d=h.primitives[e],{extensions:p={},mode:m,material:f}=d,{KHR_draco_mesh_compression:g}=p;let _;const b=Pt(d);c.has(b)?_=c.get(b):(_=g&&o?o.getGeometry(g,a,d.attributes,r.accessors,s.getDRACOLoader()):Promise.resolve(new t.Geometry),_=_.then((e=>(Ct(e,d,r,i),e))),c.set(b,_));const x=_.then((e=>{const t={mode:m,geometry:e,material:void 0===f?new wt:n[f],weights:Object.keys(e.morphAttributes).length>0&&h.weights?h.weights.slice(0):void 0,skinned:h.isSkinned};return Ot(t,l),t}));u.push(x)}d.push(Promise.all(u))}return l.clear(),c.clear(),Promise.all(d).then((t=>{e.primitives=t}))}}function Ct(e,t,s,r){const{attributes:i,indices:n,targets:a}=t;for(const t in i){const s=i[t],n=void 0===Ie[t]?t:Ie[t];n in e.attributes||e.addAttribute(n,r[s])}void 0===n||e.index||e.setIndex(r[n]);const{boundingBox:o,boundingSphere:l}=e;if(void 0!==i.POSITION){const t=i.POSITION,r=s.accessors[t];if(r.min&&r.max){if(o.min.fromArray(r.min),o.max.fromArray(r.max),r.normalized){const e=we.getNormalizedComponentScale(Ue[r.componentType]);o.min.multiplyScalar(e),o.max.multiplyScalar(e)}}else e.computeBoundingBox()}else e.computeBoundingBox();if(o.getCenter(l.center),l.radius=o.min.distanceTo(o.max)/2,a){let t=!1,s=!1;for(let e=0,r=a.length;e<r;e++){const r=a[e];if(void 0!==r.POSITION&&(t=!0),void 0!==r.NORMAL&&(s=!0),t&&s)break}if(t||s){const i=[],n=[];for(let o=0,l=a.length;o<l;o++){const l=a[o];t&&i.push(void 0!==l.POSITION?r[l.POSITION]:e.attributes[Ie.POSITION]),s&&n.push(void 0!==l.NORMAL?r[l.NORMAL]:e.attributes[Ie.NORMAL])}t&&(e.morphAttributes.position=i),s&&(e.morphAttributes.normal=n)}}return e}function Ot(e,s){let{geometry:r,material:i,skinned:n,mode:a}=e;const o=void 0!==r.attributes[Ie.TANGENT],l=void 0!==r.attributes[Ie.COLOR_0],c=void 0===r.attributes[Ie.NORMAL],d=n;if(a===Ge){const e="PointsMaterial:"+i.id;let r=s.get(e);r||(r=new t.PointsMaterial,t.Material.prototype.copy.call(r,i),r.diffuse.copy(i.diffuse),r.diffuseMap=i.map,r.drawMode=a,r.acceptLight=!1,s.set(e,r)),i=r}else if(a===ze||a===$e||a===He){const e="BasicMaterial:"+i.id;let r=s.get(e);r||(r=new t.BasicMaterial,r.envMap=void 0,r.diffuse.copy(i.diffuse),r.diffuseMap=i.diffuseMap,r.drawMode=a,s.set(e,r)),i=r}else a===Ke?(console.warn("TRIANGLE_STRIP will be removed later."),i.drawMode=Ke):a===je&&(console.warn("TRIANGLE_FAN will be removed later."),i.drawMode=je);if(o||l||c||d){let e="ClonedMaterial:"+i.id+":";o&&(e+="vertex-tangents:"),l&&(3===r.attributes[Ie.COLOR_0].size?e+="vertex-colors-rgb:":4===r.attributes[Ie.COLOR_0].size&&(e+="vertex-colors-rgba:")),c&&(e+="flat-shading:");let n=s.get(e);n||(n=i.clone(),o&&(n.vertexTangents=!0,n.normalMap&&(n.normalScale.y*=-1)),l&&(3===r.attributes[Ie.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGB:4===r.attributes[Ie.COLOR_0].size?n.vertexColors=t.VERTEX_COLOR.RGBA:console.warn("Illegal vertex color size: "+r.attributes[Ie.COLOR_0].size)),c&&(n.shading=t.SHADING_TYPE.FLAT_SHADING)),i=n}e.material=i}function Pt(e){const t=e.extensions&&e.extensions.KHR_draco_mesh_compression;let s;if(s=t?"draco:"+t.bufferView+":"+t.indices+":"+It(t.attributes):e.indices+":"+It(e.attributes)+":"+e.mode,e.targets)for(let t=0,r=e.targets.length;t<r;t++)s+=":"+It(e.targets[t]);return s}function It(e){let t="";const s=Object.keys(e).sort();for(let r=0,i=s.length;r<i;r++)t+=s[r]+":"+e[s[r]]+";";return t}class Dt{static parse(e,s){const{featureTable:r,root:i,options:n}=e,a=r.getData("INSTANCES_LENGTH"),o=r.getData("POSITION",a,"FLOAT","VEC3"),l=r.getData("NORMAL_UP",a,"FLOAT","VEC3"),c=r.getData("NORMAL_RIGHT",a,"FLOAT","VEC3"),d=r.getData("SCALE",a,"FLOAT","SCALAR"),h=r.getData("SCALE_NON_UNIFORM",a,"FLOAT","VEC3");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","EAST_NORTH_UP","POSITION_QUANTIZED","NORMAL_UP_OCT32P","NORMAL_RIGHT_OCT32P"].forEach((e=>{e in r.header&&console.warn(`I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const u=new t.Vector3;for(let e=0;e<a;e++)u.x+=o[3*e+0]/a,u.y+=o[3*e+1]/a,u.z+=o[3*e+2]/a;const p=[];i.traverse((e=>{if(e.isMesh){const{geometry:s}=e;s.instanceCount=a;const r=new t.Attribute(new t.Buffer(new Float32Array(16*a),16),16);r.divisor=1,s.addAttribute("instanceMatrix",r),e.updateMatrix(!0),e.position.copy(u).applyMatrix4(e.worldMatrix),p.push(e)}}));for(let e=0;e<a;e++){Ut.fromArray(o,3*e).sub(u),l?(Nt.fromArray(l,3*e),Ft.fromArray(c,3*e),Bt.crossVectors(Ft,Nt).normalize(),Gt.set(Ft.x,Nt.x,Bt.x,0,Ft.y,Nt.y,Bt.y,0,Ft.z,Nt.z,Bt.z,0,0,0,0,1),kt.setFromRotationMatrix(Gt)):kt.set(0,0,0,1),d?Vt.set(d[e],d[e],d[e]):h?Vt.fromArray(h,3*e):Vt.set(1,1,1),Gt.transform(Ut,Vt,kt).multiply(n.adjustmentTransform);for(let t=0,s=p.length;t<s;t++){const{geometry:s}=p[t],r=s.getAttribute("instanceMatrix").buffer.array;Gt.toArray(r,16*e),s.version++}}const m=r.getData("RTC_CENTER");m&&(i.position.x+=m[0],i.position.y+=m[1],i.position.z+=m[2])}}const Bt=new t.Vector3,Nt=new t.Vector3,Ft=new t.Vector3,Ut=new t.Vector3,kt=new t.Quaternion,Vt=new t.Vector3,Gt=new t.Matrix4;class zt extends At{static getMaterial(){return new wt}}class Ht extends t.BasicMaterial{constructor(){super(),this.type=t.MATERIAL_TYPE.SHADER,this.shaderName="TILE_I_BASIC",this.vertexShader=$t,this.fragmentShader=t.ShaderLib.basic_frag,this.defines.USE_INSTANCING=!0}}Ht.prototype.isInstancedBasicMaterial=!0;let $t=t.ShaderLib.basic_vert;$t=$t.replace("#include <logdepthbuf_pars_vert>",`\n\t\t#include <logdepthbuf_pars_vert>\n\t\t${Mt}\n`),$t=$t.replace("#include <pvm_vert>",`\n\t\t${Et}\n\t\t#include <pvm_vert>\n`),$t=$t.replace("#include <normal_vert>",`\n\t\t${vt}\n\t\t#include <normal_vert>\n`);class Kt{static getMaterial(){return new Ht}}class jt extends ct{static getMaterial(){const e=new wt;return e.specular=new t.Color3(1118481),e}}class Xt extends lt{static getMaterial(){return new wt}}class Yt extends ut{constructor(e){super(e,[pt,gt,Tt,Le,Re,Se,Ce,Oe,Xe,Rt,Ye,St,et,tt,st,it,Dt]),this.extensions.set("KHR_techniques_webgl",zt),this.extensions.set("KHR_materials_unlit",Kt),this.extensions.set("KHR_materials_pbrSpecularGlossiness",jt),this.extensions.set("KHR_materials_clearcoat",Xt)}}class Wt{static parse(e,s){const{featureTable:r}=e,i=r.getData("POINTS_LENGTH"),n=r.getData("POSITION",i,"FLOAT","VEC3"),a=r.getData("RGB",i,"UNSIGNED_BYTE","VEC3"),o=r.getData("RGBA",i,"UNSIGNED_BYTE","VEC4");["QUANTIZED_VOLUME_OFFSET","QUANTIZED_VOLUME_SCALE","CONSTANT_RGBA","BATCH_LENGTH","POSITION_QUANTIZED","RGB565","NORMAL","NORMAL_OCT16P","BATCH_ID"].forEach((e=>{e in r.header&&console.warn(`PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`)}));const l=new t.Geometry;l.addAttribute("a_Position",new t.Attribute(new t.Buffer(n,3),3,0,!0)),l.computeBoundingBox(),l.computeBoundingSphere();const c=new t.PointsMaterial;c.size=2,c.sizeAttenuation=!1,null!==a?(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(a,3),3,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGB):null!==o&&(l.addAttribute("a_Color",new t.Attribute(new t.Buffer(o,4),4,0,!0)),c.vertexColors=t.VERTEX_COLOR.RGBA);const d=new t.Mesh(l,c);e.root=d;const h=r.getData("RTC_CENTER");h&&(d.position.x+=h[0],d.position.y+=h[1],d.position.z+=h[2])}}class Qt extends ut{constructor(e){super(e,[pt,gt,Wt])}}class Jt{static parse(e,t){const s=e.options.buffer,r=e.header.tilesLength,i=[];let n=16;for(let e=0;e<r;e++){const e=new DataView(s,n,12),t=String.fromCharCode(e.getUint8(0))+String.fromCharCode(e.getUint8(1))+String.fromCharCode(e.getUint8(2))+String.fromCharCode(e.getUint8(3)),r=e.getUint32(4,!0),a=e.getUint32(8,!0),o=new Uint8Array(s,n,a);i.push({type:t,buffer:o,version:r}),n+=a}e.tiles=i}}class qt{static parse(e,s){const{tiles:r,options:i,path:n}=e,a=i.adjustmentTransform,o=[];for(const e in r){const{type:t,buffer:l}=r[e],c={fetchOptions:i.fetchOptions,path:n,buffer:l.slice().buffer};"b3dm"!==t&&"i3dm"!==t||(c.adjustmentTransform=a);const d=s._loaders.get(t);d&&o.push(d.load(`${n}/temp.${t}`,c))}return Promise.all(o).then((e=>{const s=new t.Object3D;return e.forEach((e=>{s.add(e.root)})),{tiles:e,root:s}}))}}class Zt extends ut{constructor(e){super(e,[pt,Jt,qt]);const t=new yt(e),s=new Yt(e),r=new Qt(e);this._loaders=new Map([["b3dm",t],["i3dm",s],["pnts",r]])}setDRACOLoader(e){for(const t of this._loaders.values())t.setDRACOLoader(e);return super.setDRACOLoader(e)}setKTX2Loader(e){for(const t of this._loaders.values())t.setKTX2Loader(e);return super.setKTX2Loader(e)}}class es{static parse(e,t){const{url:s,options:r}=e,i=r.buffer;if(ts(s)){const t=we.parseGLB(i);e.gltf=t.gltf,e.buffers=t.buffers}else e.gltf=i}}const ts=e=>"glb"===e.substring(e.lastIndexOf(".")+1);class ss extends ut{constructor(e){super(e),this.replaceParser(es,0)}}class rs{constructor(e){const t=new yt(e),s=new Yt(e),r=new Qt(e),i=new Zt(e),n=new ss(e);this._loaders=new Map([["b3dm",t],["i3dm",s],["pnts",r],["cmpt",i],["gltf",n],["glb",n]])}setDRACOLoader(e){this._loaders.get("b3dm").setDRACOLoader(e),this._loaders.get("i3dm").setDRACOLoader(e),this._loaders.get("cmpt").setDRACOLoader(e),this._loaders.get("gltf").setDRACOLoader(e)}setKTX2Loader(e){this._loaders.get("b3dm").setKTX2Loader(e),this._loaders.get("i3dm").setKTX2Loader(e),this._loaders.get("cmpt").setKTX2Loader(e),this._loaders.get("gltf").setKTX2Loader(e)}loadTileContent(e,t,s,r){t._loadIndex=t._loadIndex||0,t._loadIndex++;const i=t.content.uri,n=i.split(/[\\\/]/g);n.pop();const a=n.join("/"),o=r.fetchOptions,l=t._loadIndex;let c=null;const d=r.rootTileSet.asset&&r.rootTileSet.asset.gltfUpAxis||"y",h=t.cached,u=h.transform;switch(d.toLowerCase()){case"x":is.makeRotationAxis(as,-Math.PI/2);break;case"y":is.makeRotationAxis(ns,Math.PI/2);break;case"z":is.identity()}const p=this._loaders.get(s);if(p){const t={fetchOptions:o,path:a,buffer:e};"b3dm"!==s&&"i3dm"!==s&&"cmpt"!==s||(t.adjustmentTransform=is.clone()),c=p.load(i,t)}else console.warn(`TilesRenderer: Content type "${s}" not supported.`),c=Promise.resolve(null);return c.then((e=>{const r=e.root;if(t._loadIndex!==l||!r)return;r.updateMatrix(),"glb"!==s&&"gltf"!==s||r.matrix.multiply(is),r.matrix.premultiply(u),r.matrix.decompose(r.position,r.quaternion,r.scale),h.scene=r,h.featureTable=e.featureTable,h.batchTable=e.batchTable;const i=[],n=[],a=[];return r.traverse((e=>{if(e.geometry&&n.push(e.geometry),e.material){const t=e.material;i.push(e.material);for(const e in t){const s=t[e];s&&s.isTexture&&a.push(s)}}})),h.materials=i,h.geometry=n,h.textures=a,r}))}}const is=new t.Matrix4,ns=new t.Vector3(1,0,0),as=new t.Vector3(0,1,0),os=(e,t)=>{const s=t.stats,r=t.frameCount,i=t.errorTarget,n=t.maxDepth,a=t.loadSiblings,o=t.$tilesLoader.lruCache,l=t.stopAtEmptyTiles;hs(e,r);if(!1===us(e,t))return!1;if(e.__used=!0,o.markUsed(e),e.__inFrustum=!0,s.inFrustum++,(l||!e.__contentEmpty)&&!e.__externalTileSet){ps(e,t);if(e.__error<=i)return!0;if(n>0&&e.__depth+1>=n)return!0}let c=!1;const d=e.children;for(let e=0,s=d.length;e<s;e++){const s=d[e],r=os(s,t);c=c||r}if(c&&a)for(let e=0,t=d.length;e<t;e++){const t=d[e];ms(t,r,o)}return!0},ls=(e,t)=>{const s=t.stats,r=t.frameCount;if(!fs(e,r))return;s.used++;const i=e.children;let n=!1;for(let e=0,t=i.length;e<t;e++){const t=i[e];n=n||fs(t,r)}if(n){let s=!1,n=!0;for(let e=0,a=i.length;e<a;e++){const a=i[e];if(ls(a,t),s=s||a.__wasSetVisible||a.__childrenWereVisible,fs(a,r)){const e=a.__allChildrenLoaded||!a.__contentEmpty&&gs(a.__loadingState)||a.__externalTileSet&&a.__loadingState===ce.FAILED;n=n&&e}}e.__childrenWereVisible=s,e.__allChildrenLoaded=n}else e.__isLeaf=!0},cs=(e,t)=>{const s=t.stats,r=t.frameCount;if(!fs(e,r))return;const i=e.parent,n=i?i.__depthFromRenderedParent:-1;e.__depthFromRenderedParent=n;const a=t.$tilesLoader.lruCache;if(e.__isLeaf)return e.__depthFromRenderedParent++,void(e.__loadingState===ce.LOADED?(e.__inFrustum&&(e.__visible=!0,s.visible++),e.__active=!0,s.active++):a.isFull()||e.__contentEmpty&&!e.__externalTileSet||t.$tilesLoader.requestTileContents(e,t));const o=(t.errorTarget+1)*t.errorThreshold,l=e.__error<=o,c=l||"ADD"===e.refine,d=!e.__contentEmpty,h=d||e.__externalTileSet,u=gs(e.__loadingState)&&h,p=e.__childrenWereVisible,m=e.children,f=e.__allChildrenLoaded;if(c&&d&&e.__depthFromRenderedParent++,c&&!u&&!a.isFull()&&h&&t.$tilesLoader.requestTileContents(e,t),(l&&!f&&!p&&u||"ADD"===e.refine&&u)&&(e.__inFrustum&&(e.__visible=!0,s.visible++),e.__active=!0,s.active++),"ADD"!==e.refine&&l&&!f&&u)for(let s=0,i=m.length;s<i;s++){const i=m[s];fs(i,r)&&!a.isFull()&&(i.__depthFromRenderedParent=e.__depthFromRenderedParent+1,_s(i,i.__depthFromRenderedParent,t))}else for(let e=0,s=m.length;e<s;e++){const s=m[e];fs(s,r)&&cs(s,t)}},ds=(e,t)=>{const s=t.frameCount,r=fs(e,s);if(r||e.__usedLastFrame){let s=!1,i=!1;r&&(s=e.__active,i=t.displayActiveTiles&&e.__active||e.__visible),e.__contentEmpty||e.__loadingState!==ce.LOADED||(e.__wasSetActive!==s&&t.$setTileActive(e,s),e.__wasSetVisible!==i&&t.invokeOnePlugin((t=>t.setTileVisible&&t.setTileVisible(e,i)))),e.__wasSetActive=s,e.__wasSetVisible=i,e.__usedLastFrame=r;const n=e.children;for(let e=0,s=n.length;e<s;e++){const s=n[e];ds(s,t)}}},hs=(e,t)=>{e.__lastFrameVisited!==t&&(e.__lastFrameVisited=t,e.__used=!1,e.__inFrustum=!1,e.__isLeaf=!1,e.__visible=!1,e.__active=!1,e.__error=1/0,e.__distanceFromCamera=1/0,e.__childrenWereVisible=!1,e.__allChildrenLoaded=!1)},us=(e,t)=>{const s=t.$cameras.getInfos(),r=e.cached,i=r.boundingVolume,n=r.inFrustum;let a=!1;for(let e=0,t=s.length;e<t;e++){const t=s[e].frustum;i.intersectsFrustum(t)?(a=!0,n[e]=!0):n[e]=!1}return a},ps=(e,t)=>{const s=t.$cameras.getInfos(),r=e.cached,i=r.inFrustum,n=r.boundingVolume;let a=-1/0,o=1/0;for(let e=0,t=s.length;e<t;e++){if(!i[e])continue;const t=s[e],l=t.invScale;let c;if(t.isOrthographic){const e=t.pixelSize;c=r.geometricError/(e*l)}else{const e=n.distanceToPoint(t.position)*l,s=t.sseDenominator;c=r.geometricError/(e*s),o=Math.min(o,e)}a=Math.max(a,c)}e.__distanceFromCamera=o,e.__error=a},ms=(e,t,s)=>{if(hs(e,t),e.__used=!0,s.markUsed(e),e.__contentEmpty){const r=e.children;for(let e=0,i=r.length;e<i;e++)ms(r[e],t,s)}},fs=(e,t)=>e.__lastFrameVisited===t&&e.__used;function gs(e){return e===ce.LOADED||e===ce.FAILED}const _s=(e,t,s)=>{if(e.__contentEmpty&&(!e.__externalTileSet||gs(e.__loadingState))){const r=e.children;for(let e=0,i=r.length;e<i;e++){const i=r[e];i.__depthFromRenderedParent=t,_s(i,t,s)}}else s.$tilesLoader.requestTileContents(e,s)},bs=6378137,xs=new b(new t.Vector3(bs,bs,6356752.314245179));xs.name="WGS84 Earth";class As extends t.Object3D{constructor(e,s=new t.LoadingManager){super(),this.ellipsoid=xs.clone(),this.fetchOptions={},this.errorTarget=6,this.errorThreshold=1/0,this.loadSiblings=!0,this.displayActiveTiles=!1,this.maxDepth=1/0,this.stopAtEmptyTiles=!0,this.preprocessURL=null,s.setURLModifier((e=>this.preprocessURL?this.preprocessURL(e):e)),this.manager=s,this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0,this.activeTiles=new Set,this.visibleTiles=new Set,this.rootURL=e,this._rootTileSet=null,this._autoDisableRendererCulling=!0,this.plugins=[],this.$cameras=new ue,this.$tilesLoader=new ye,this.$modelLoader=new rs(s),this.$events=new t.EventDispatcher}preprocessTileSet(e,t,s=null){const r=e.asset.version,[i,n]=r.split(".").map((e=>parseInt(e)));console.assert(i<=1,"TilesLoader: asset.version is expected to be a 1.x or a compatible version."),1===i&&n>0&&console.warn("TilesLoader: tiles versions at 1.1 or higher have limited support. Some new extensions and features may not be supported.");let a=t.replace(/\/[^/]*$/,"");a=new URL(a,window.location.href).toString(),ee(e.root,((e,t)=>Rs(this.ellipsoid,e,t,a)),null,s,s?s.__depth:0)}loadRootTileSet(){let e=this.rootURL;this.invokeAllPlugins((t=>e=t.preprocessURL?t.preprocessURL(e,null):e));return this.invokeOnePlugin((t=>t.fetchData&&t.fetchData(e,this.fetchOptions))).then((t=>{if(t.ok)return t.json();throw new Error(`Tiles3D: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`)})).then((t=>{const{extensions:s={}}=t;if("3DTILES_ellipsoid"in s){const e=s["3DTILES_ellipsoid"],{ellipsoid:t}=this;t.name=e.body,e.radii?t.radius.set(...e.radii):t.radius.set(1,1,1),console.log(s)}return this.preprocessTileSet(t,e),t}))}fetchData(e,t){return fetch(e,t)}get rootTileSet(){const e=this._rootTileSet;return e?e instanceof Promise||e instanceof Error?null:e:(this._rootTileSet=this.invokeOnePlugin((e=>e.loadRootTileSet&&e.loadRootTileSet())).then((e=>{let t=this.rootURL;null!==t&&this.invokeAllPlugins((e=>t=e.preprocessURL?e.preprocessURL(t,null):t)),this._rootTileSet=e,this.dispatchEvent({type:"load-tile-set",tileSet:e,url:t})})).catch((e=>{console.error(e),this._rootTileSet=e})),null)}get root(){const e=this.rootTileSet;return e?e.root:null}get autoDisableRendererCulling(){return this._autoDisableRendererCulling}set autoDisableRendererCulling(e){this._autoDisableRendererCulling!==e&&(super._autoDisableRendererCulling=e,this.traverse((t=>{const s=t.cached.scene;s&&s.traverse((t=>{t.frustumCulled=t[Es]&&!e}))})))}registerPlugin(e){if(!0===e[Ms])throw new Error("Tiles3D: A plugin can only be registered to a single tile set");const t=this.plugins,s=e.priority||0;let r=t.length;for(let e=0;e<t.length;e++){if((t[e].priority||0)>s){r=e;break}}t.splice(r,0,e),e[Ms]=!0,e.init&&e.init(this)}unregisterPlugin(e){const t=this.plugins;if("string"==typeof e&&(e=this.getPluginByName(name)),t.includes(e)){const s=t.indexOf(e);return t.splice(s,1),e.dispose&&e.dispose(),!0}return!1}getPluginByName(e){return this.plugins.find((t=>t.name===e))||null}setDRACOLoader(e){this.$modelLoader.setDRACOLoader(e)}setKTX2Loader(e){this.$modelLoader.setKTX2Loader(e)}addEventListener(e,t,s){this.$events.addEventListener(e,t,s)}removeEventListener(e,t,s){this.$events.removeEventListener(e,t,s)}dispatchEvent(e){this.$events.dispatchEvent(e)}markTileUsed(e){this.$tilesLoader.lruCache.markUsed(e)}update(){const e=this.root;if(!e)return;this.dispatchEvent(ys);const{stats:t}=this;var s,r;t.inFrustum=0,t.used=0,t.active=0,t.visible=0,this.frameCount++,this.$cameras.updateInfos(this.worldMatrix),os(s=e,r=this),ls(s,r),cs(s,r),ds(s,r),r.$tilesLoader.lruCache.scheduleUnload(),this.dispatchEvent(Ts)}addCamera(e){const t=this.$cameras.add(e);return t&&this.dispatchEvent({type:"add-camera",camera:e}),t}removeCamera(e){const t=this.$cameras.remove(e);return t&&this.dispatchEvent({type:"delete-camera",camera:e}),t}resize(e,t){this.$cameras.setResolution(e,t)}raycast(e,t){if(!this.root)return null;te(this.root,this,e,t),t.sort(re)}raycastFirst(e){return this.root?se(this.root,this,e):null}getBoundingBox(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingBox(e),!0)}getOrientedBoundingBox(e,t){if(!this.root)return!1;const s=this.root.cached.boundingVolume;return!!s&&(s.getOrientedBoundingBox(e,t),!0)}getBoundingSphere(e){if(!this.root)return!1;const t=this.root.cached.boundingVolume;return!!t&&(t.getBoundingSphere(e),!0)}forEachLoadedModel(e){this.traverse((t=>{const s=t.cached&&t.cached.scene;s&&e(s,t)}),null)}traverse(e,t){const s=this.root;s&&ee(s,e,t)}resetFailedTiles(){const e=this.stats;0!==e.failed&&(this.traverse((e=>{e.__loadingState===ce.FAILED&&(e.__loadingState=ce.UNLOADED)})),e.failed=0)}dispose(){this.plugins.forEach((e=>{this.unregisterPlugin(e)}));const e=this.$tilesLoader.lruCache;this.traverse((t=>{e.remove(t)})),this.stats={parsing:0,downloading:0,failed:0,inFrustum:0,used:0,active:0,visible:0},this.frameCount=0}updateMatrix(e){if((this.matrixAutoUpdate||this.matrixNeedsUpdate)&&(this.matrix.transform(this.position,this.scale,this.quaternion),this.matrixNeedsUpdate=!1,this.worldMatrixNeedsUpdate=!0),(this.worldMatrixNeedsUpdate||e)&&(null===this.parent?vs.copy(this.matrix):vs.multiplyMatrices(this.parent.worldMatrix,this.matrix),this.worldMatrixNeedsUpdate=!1,!ws(vs,this.worldMatrix))){this.worldMatrix.copy(vs);const e=this.children;for(let t=0,s=e.length;t<s;t++)e[t].updateMatrix()}}getAttributions(e=[]){return this.invokeAllPlugins((t=>t!==this&&t.getAttributions&&t.getAttributions(e))),e}invokeOnePlugin(e){const t=[...this.plugins,this];for(let s=0;s<t.length;s++){const r=e(t[s]);if(r)return r}return null}invokeAllPlugins(e){const t=[...this.plugins,this],s=[];for(let r=0;r<t.length;r++){const i=e(t[r]);i&&s.push(i)}return 0===s.length?null:Promise.all(s)}$parseTile(e,t,s){return this.$modelLoader.loadTileContent(e,t,s,this).then((e=>{e.traverse((e=>{e[Es]=e.frustumCulled,e.frustumCulled=e.frustumCulled&&!this._autoDisableRendererCulling})),this.dispatchEvent({type:"load-model",scene:e,tile:t})}))}setTileVisible(e,t){const s=e.cached.scene;if(!s)return;const r=this.visibleTiles;t?(this.add(s),r.add(e),s.updateMatrix(!0)):(this.remove(s),r.delete(e)),this.dispatchEvent({type:"tile-visibility-change",scene:s,tile:e,visible:t})}$setTileActive(e,t){const s=this.activeTiles;t?s.add(e):s.delete(e)}$disposeTile(e){const t=e.cached;if(t.scene){const s=t.materials,r=t.geometry,i=t.textures;for(let e=0,t=r.length;e<t;e++)r[e].dispose();for(let e=0,t=s.length;e<t;e++)s[e].dispose();for(let e=0,t=i.length;e<t;e++){i[e].dispose()}this.dispatchEvent({type:"dispose-model",scene:t.scene,tile:e}),t.scene=null,t.materials=null,t.textures=null,t.geometry=null}e._loadIndex++}}const ys={type:"update-before"},Ts={type:"update-after"},Ms=Symbol("PLUGIN_REGISTERED"),Es=Symbol("INITIAL_FRUSTUM_CULLED"),vs=new t.Matrix4,ws=(e,t,s=Number.EPSILON)=>{const r=e.elements,i=t.elements;for(let e=0;e<16;e++)if(Math.abs(r[e]-i[e])>s)return!1;return!0},Ls=new t.Vector3,Rs=(e,s,r,i)=>{s.contents&&(s.content=s.contents[0]),s.content&&(!("uri"in s.content)&&"url"in s.content&&(s.content.uri=s.content.url,delete s.content.url),s.content.uri&&(s.content.uri=new URL(s.content.uri,i+"/").toString()),s.content.boundingVolume&&!("box"in s.content.boundingVolume||"sphere"in s.content.boundingVolume||"region"in s.content.boundingVolume)&&delete s.content.boundingVolume),s.parent=r,s.children=s.children||[];if(s.content&&s.content.uri){const e=Z(s.content.uri),t=Boolean(e&&"json"===e.toLowerCase());s.__externalTileSet=t,s.__contentEmpty=t}else s.__externalTileSet=!1,s.__contentEmpty=!0;s.__distanceFromCamera=1/0,s.__error=1/0,s.__inFrustum=!1,s.__isLeaf=!1,s.__usedLastFrame=!1,s.__used=!1,s.__wasSetVisible=!1,s.__visible=!1,s.__childrenWereVisible=!1,s.__allChildrenLoaded=!1,s.__wasSetActive=!1,s.__active=!1,s.__loadingState=ce.UNLOADED,s.__loadIndex=0,s.__loadAbort=null,s.__depthFromRenderedParent=-1,null===r?(s.__depth=0,s.refine=s.refine||"REPLACE"):(s.__depth=r.__depth+1,s.refine=s.refine||r.refine);const n=new t.Matrix4;s.transform&&n.fromArray(s.transform),r&&n.premultiply(r.cached.transform);const a=(new t.Matrix4).copy(n).inverse(),o=Ls.setFromMatrixScale(n),l=Math.max(o.x,o.y,o.z);let c=s.geometricError*l;const d=new Y;"box"in s.boundingVolume&&d.setOBBData(s.boundingVolume.box,n),"sphere"in s.boundingVolume&&d.setSphereData(s.boundingVolume.sphere,n),"region"in s.boundingVolume&&(d.setRegionData(e,...s.boundingVolume.region),c=s.geometricError),s.cached={loadIndex:0,transform:n,transformInverse:a,geometricError:c,boundingVolume:d,active:!1,inFrustum:[],scene:null,geometry:null,material:null,featureTable:null,batchTable:null}};class Ss{constructor(){this.duration=250,this.fadeCount=0,this._lastTick=-1,this._fadeState=new Map,this.onFadeComplete=null,this.onFadeStart=null,this.onFadeSetComplete=null,this.onFadeSetStart=null}deleteObject(e){e&&this.completeFade(e)}guaranteeState(e){const t=this._fadeState;if(t.has(e))return!1;return t.set(e,{fadeInTarget:0,fadeOutTarget:0,fadeIn:0,fadeOut:0}),!0}completeFade(e){const t=this._fadeState;if(!t.has(e))return;const s=0===t.get(e).fadeOutTarget;t.delete(e),this.fadeCount--,this.onFadeComplete&&this.onFadeComplete(e,s),0===this.fadeCount&&this.onFadeSetComplete&&this.onFadeSetComplete()}completeAllFades(){this._fadeState.forEach(((e,t)=>{this.completeFade(t)}))}forEachObject(e){this._fadeState.forEach(((t,s)=>{e(s,t)}))}fadeIn(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeInTarget=1,s.fadeOutTarget=0,s.fadeOut=0,t&&(this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}fadeOut(e){const t=this.guaranteeState(e),s=this._fadeState.get(e);s.fadeOutTarget=1,t&&(s.fadeInTarget=1,s.fadeIn=1,this.fadeCount++,1===this.fadeCount&&this.onFadeSetStart&&this.onFadeSetStart(),this.onFadeStart&&this.onFadeStart(e))}isFading(e){return this._fadeState.has(e)}isFadingOut(e){const t=this._fadeState.get(e);return t&&1===t.fadeOutTarget}update(){const e=window.performance.now();-1===this._lastTick&&(this._lastTick=e);const s=t.MathUtils.clamp((e-this._lastTick)/this.duration,0,1);this._lastTick=e;this._fadeState.forEach(((e,r)=>{const{fadeOutTarget:i,fadeInTarget:n}=e;let{fadeOut:a,fadeIn:o}=e;const l=Math.sign(n-o);o=t.MathUtils.clamp(o+l*s,0,1);const c=Math.sign(i-a);a=t.MathUtils.clamp(a+c*s,0,1),e.fadeIn=o,e.fadeOut=a;((1===a||0===a)&&(1===o||0===o)||a>=o)&&this.completeFade(r)}))}}class Cs{constructor(){this._fadeParams=new WeakMap,this.fading=0}setFade(e,t,s){if(!e)return;const r=this._fadeParams;e.traverse((e=>{const i=e.material;if(i){const e=r.get(i);e.fadeIn=t,e.fadeOut=s;const n=Number(!(0===t||1===t)||!(0===s||1===s));i.defines.FEATURE_FADE!==n&&(this.fading+=1===n?1:-1,i.defines.FEATURE_FADE=n,i.needsUpdate=!0)}}))}prepareScene(e){e.traverse((e=>{e.material&&this.prepareMaterial(e.material)}))}deleteScene(e){if(!e)return;const t=this._fadeParams;e.traverse((e=>{const s=e.material;s&&(t.delete(s),s.defines.FEATURE_FADE=!1,s.needsUpdate=!0)}))}prepareMaterial(e){const s=this._fadeParams;s.has(e)||s.set(e,function(e){e.shaderName=`${e.shaderName||e.type}_fade`,e.defines.FEATURE_FADE=0,e.uniforms.fadeIn=0,e.uniforms.fadeOut=0;const s=e.fragmentShader||(e.type===t.MATERIAL_TYPE.BASIC?t.ShaderLib.basic_frag:t.ShaderLib.pbr_frag);return e.type=t.MATERIAL_TYPE.SHADER,e.vertexShader=e.type===t.MATERIAL_TYPE.BASIC?t.ShaderLib.basic_vert:t.ShaderLib.pbr_vert,e.fragmentShader=s.replace(/void main\(/,(e=>`\n\t\t\t#if FEATURE_FADE\n\n\t\t\t// adapted from https://www.shadertoy.com/view/Mlt3z8\n\t\t\tfloat bayerDither2x2(vec2 v) {\n\t\t\t\treturn mod(3.0 * v.y + 2.0 * v.x, 4.0);\n\t\t\t}\n\n\t\t\tfloat bayerDither4x4(vec2 v) {\n\t\t\t\tvec2 P1 = mod(v, 2.0);\n\t\t\t\tvec2 P2 = floor(0.5 * mod(v, 4.0));\n\t\t\t\treturn 4.0 * bayerDither2x2(P1) + bayerDither2x2(P2);\n\t\t\t}\n\n\t\t\tuniform float fadeIn;\n\t\t\tuniform float fadeOut;\n\n\t\t\t#endif\n\n\t\t\t${e}\n\t\t`)).replace(/#include <end_frag>/,(e=>`\n\t\t\t${e}\n\n\t\t\t#if FEATURE_FADE\n\n\t\t\tfloat bayerValue = bayerDither4x4(floor(mod(gl_FragCoord.xy, 4.0)));\n\t\t\tfloat bayerBins = 16.0;\n\t\t\tfloat dither = (0.5 + bayerValue) / bayerBins;\n\t\t\tif (dither >= fadeIn) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\tif (dither < fadeOut) {\n\t\t\t\tdiscard;\n\t\t\t}\n\n\t\t\t#endif\n\t\t`)),e.uniforms}(e))}}const Os=Symbol("HAS_POPPED_IN"),Ps=new t.Vector3,Is=new t.Vector3,Ds=new t.Quaternion,Bs=new t.Quaternion,Ns=new t.Vector3;function Fs(){const e=this._fadeManager,t=this.tiles;this._fadingBefore=e.fadeCount,this._displayActiveTiles=t.displayActiveTiles,t.displayActiveTiles=!0}function Us(){const e=this._fadeManager,t=this._fadeMaterialManager,s=this._displayActiveTiles,r=this._fadingBefore,i=this._prevCameraTransforms,{tiles:n,maximumFadeOutTiles:a}=this,o=n.$cameras._cameras;n.displayActiveTiles=s,e.update();const l=e.fadeCount;if(0!==r&&0!==l&&(n.dispatchEvent({type:"fade-change"}),n.dispatchEvent({type:"needs-render"})),s||n.visibleTiles.forEach((e=>{const t=e.cached.scene;t&&(t.visible=e.__inFrustum)})),a<this._fadingOutCount){let t=!0;o.forEach((e=>{if(!i.has(e))return;const s=e.worldMatrix,r=i.get(e);s.decompose(Is,Bs,Ns),r.decompose(Ps,Ds,Ns);const n=Bs.angleTo(Ds),a=Is.distanceTo(Ps);t=t&&(n>.25||a>.1)})),t&&e.completeAllFades()}o.forEach((e=>{i.get(e).copy(e.worldMatrix)})),e.forEachObject(((s,{fadeIn:r,fadeOut:i})=>{const a=s.cached.scene,o=e.isFadingOut(s);n.markTileUsed(s),a&&(t.setFade(a,r,i),o&&(a.visible=!0))}))}class ks{constructor(){this.creditsCount={}}_adjustAttributions(e,t){const s=this.creditsCount,r=e.split(/;/g);for(let e=0,i=r.length;e<i;e++){const i=r[e];i in s||(s[i]=0),s[i]+=t?1:-1,s[i]<=0&&delete s[i]}}addAttributions(e){this._adjustAttributions(e,!0)}removeAttributions(e){this._adjustAttributions(e,!1)}toString(){const e=Object.entries(this.creditsCount).sort(((e,t)=>{const s=e[1];return t[1]-s}));return e.map((e=>e[0])).join("; ")}}class Vs{constructor({apiToken:e,autoRefreshToken:t=!1,logoUrl:s=null,useRecommendedSettings:r=!0}){this.name="GOOGLE_CLOUD_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=e,this.autoRefreshToken=t,this.useRecommendedSettings=r,this.logoUrl=s,this.sessionToken=null,this.tiles=null,this._onLoadCallback=null,this._visibilityChangeCallback=null,this._tokenRefreshPromise=null,this._attributionsManager=new ks,this._logoAttribution={value:"",type:"image",collapsible:!1},this._attribution={value:"",type:"string",collapsible:!0}}init(e){null!=e&&(e.resetFailedTiles(),null==e.rootURL&&(e.rootURL="https://tile.googleapis.com/v1/3dtiles/root.json"),this.useRecommendedSettings&&(e.$tilesLoader.parseQueue.maxJobs=10,e.$tilesLoader.downloadQueue.maxJobs=30,e.errorTarget=20),this.tiles=e,this._onLoadCallback=({tileSet:t})=>{this.sessionToken=Gs(t.root),e.removeEventListener("load-tile-set",this._onLoadCallback)},this._visibilityChangeCallback=({tile:e,visible:t})=>{},e.addEventListener("load-tile-set",this._onLoadCallback),e.addEventListener("tile-visibility-change",this._visibilityChangeCallback))}getAttributions(e){this.tiles.visibleTiles.size>0&&(this.logoUrl&&(this._logoAttribution.value=this.logoUrl,e.push(this._logoAttribution)),this._attribution.value=this._attributionsManager.toString(),e.push(this._attribution))}preprocessURL(e){return e=new URL(e),/^http/.test(e.protocol)&&(e.searchParams.append("key",this.apiToken),null!==this.sessionToken&&e.searchParams.append("session",this.sessionToken)),e.toString()}dispose(){const{tiles:e}=this;e.removeEventListener("load-tile-set",this._onLoadCallback),e.removeEventListener("tile-visibility-change",this._visibilityChangeCallback)}async fetchData(e,t){null!==this._tokenRefreshPromise&&(await this._tokenRefreshPromise,e=this.preprocessURL(e));const s=await fetch(e,t);return s.status>=400&&s.status<=499&&this.autoRefreshToken?(await this._refreshToken(t),fetch(this.preprocessURL(e),t)):s}_refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.tiles.rootURL);t.searchParams.append("key",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then((e=>e.json())).then((e=>{this.sessionToken=Gs(e.root),this._tokenRefreshPromise=null})),this._tokenRefreshPromise.catch((e=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:e,url:t})}))}return this._tokenRefreshPromise}}function Gs(e){let t=null;return ee(e,(e=>{if(e.content&&e.content.uri){const[,s]=e.content.uri.split("?");return t=new URLSearchParams(s).get("session"),!0}return!1})),t}class zs extends t.Mesh{constructor(e,s=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new t.Geometry;i.setIndex(new t.Attribute(new t.Buffer(r,1))),i.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1]),3))),i.computeBoundingSphere();const n=new t.LineMaterial;n.diffuse.setHex(s),super(i,n),this.box=e}updateMatrix(e){const t=this.box;t.getCenter(this.position),t.isEmpty()?this.scale.multiplyScalar(0):(t.getSize(this.scale),this.scale.multiplyScalar(.5)),super.updateMatrix(e)}}zs.prototype.isBox3Helper=!0;class Hs extends t.Mesh{constructor(e,s=16776960,r=40){const i=[];for(let e=0;e<3;e++){const t=Ks[e],s=Ks[(e+1)%3];$s.set(0,0,0);for(let e=0;e<r;e++){let n;n=2*Math.PI*e/(r-1),$s[t]=Math.sin(n),$s[s]=Math.cos(n),i.push($s.x,$s.y,$s.z),n=2*Math.PI*(e+1)/(r-1),$s[t]=Math.sin(n),$s[s]=Math.cos(n),i.push($s.x,$s.y,$s.z)}}const n=new t.Geometry;n.addAttribute("a_Position",new t.Attribute(new t.Buffer(new Float32Array(i),3))),n.computeBoundingSphere();const a=new t.LineMaterial;a.diffuse.setHex(s),super(n,a),this.sphere=e}updateMatrix(e){const t=this.sphere;this.position.copy(t.center),t.isEmpty()?this.scale.setScalar(0):this.scale.setScalar(t.radius),super.updateMatrix(e)}}Hs.prototype.isSphereHelper=!0;const $s=new t.Vector3,Ks=["x","y","z"];const js=Symbol("ORIGINAL_MATERIAL"),Xs=Symbol("HAS_RANDOM_COLOR"),Ys=Symbol("HAS_RANDOM_NODE_COLOR"),Ws=Symbol("LOAD_TIME"),Qs=Symbol("PARENT_BOUND_REF_COUNT"),Js=new t.Sphere,qs=()=>{},Zs={};function er(e){if(!Zs[e]){const s=Math.random(),r=.5+.5*Math.random(),i=.375+.25*Math.random();Zs[e]=(new t.Color3).setHSL(s,r,i)}return Zs[e]}const tr=0,sr=1,rr=2,ir=3,nr=4,ar=5,or=6,lr=7,cr=8,dr=9,hr=10,ur=Object.freeze({NONE:tr,SCREEN_ERROR:sr,GEOMETRIC_ERROR:rr,DISTANCE:ir,DEPTH:nr,RELATIVE_DEPTH:ar,IS_LEAF:or,RANDOM_COLOR:lr,RANDOM_NODE_COLOR:cr,CUSTOM_COLOR:dr,LOAD_ORDER:hr});const pr=new t.Sphere,mr=new t.Vector3;const fr=new t.Quaternion;t.Matrix4.prototype.makeBasis=function(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this},t.Matrix4.prototype.setPosition=function(e,t,s){const r=this.elements;return e.isVector3?(r[12]=e.x,r[13]=e.y,r[14]=e.z):(r[12]=e,r[13]=t,r[14]=s),this},t.Matrix4.prototype.makeRotationFromEuler=function(e){const t=this.elements,s=e.x,r=e.y,i=e.z,n=Math.cos(s),a=Math.sin(s),o=Math.cos(r),l=Math.sin(r),c=Math.cos(i),d=Math.sin(i);if("XYZ"===e.order){const e=n*c,s=n*d,r=a*c,i=a*d;t[0]=o*c,t[4]=-o*d,t[8]=l,t[1]=s+r*l,t[5]=e-i*l,t[9]=-a*o,t[2]=i-e*l,t[6]=r+s*l,t[10]=n*o}else if("YXZ"===e.order){const e=o*c,s=o*d,r=l*c,i=l*d;t[0]=e+i*a,t[4]=r*a-s,t[8]=n*l,t[1]=n*d,t[5]=n*c,t[9]=-a,t[2]=s*a-r,t[6]=i+e*a,t[10]=n*o}else if("ZXY"===e.order){const e=o*c,s=o*d,r=l*c,i=l*d;t[0]=e-i*a,t[4]=-n*d,t[8]=r+s*a,t[1]=s+r*a,t[5]=n*c,t[9]=i-e*a,t[2]=-n*l,t[6]=a,t[10]=n*o}else if("ZYX"===e.order){const e=n*c,s=n*d,r=a*c,i=a*d;t[0]=o*c,t[4]=r*l-s,t[8]=e*l+i,t[1]=o*d,t[5]=i*l+e,t[9]=s*l-r,t[2]=-l,t[6]=a*o,t[10]=n*o}else if("YZX"===e.order){const e=n*o,s=n*l,r=a*o,i=a*l;t[0]=o*c,t[4]=i-e*d,t[8]=r*d+s,t[1]=d,t[5]=n*c,t[9]=-a*c,t[2]=-l*c,t[6]=s*d+r,t[10]=e-i*d}else if("XZY"===e.order){const e=n*o,s=n*l,r=a*o,i=a*l;t[0]=o*c,t[4]=-d,t[8]=l*c,t[1]=e*d+i,t[5]=n*c,t[9]=s*d-r,t[2]=r*d-s,t[6]=a*c,t[10]=i*d+e}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this},t.Matrix4.prototype.invert=function(){return this.getInverse(this)},t.Vector3.prototype.applyEuler=function(e){return this.applyQuaternion(fr.setFromEuler(e))},t.Vector3.prototype.isVector3=!0,t.Quaternion.prototype.angleTo=function(e){return 2*Math.acos(Math.abs(t.MathUtils.clamp(this.dot(e),-1,1)))},t.Quaternion.prototype.identity=function(){return this.set(0,0,0,1)},t.Object3D.prototype.removeFromParent=function(){const e=this.parent;return null!==e&&e.remove(this),this},e.B3DMLoader=yt,e.CMPTLoader=Zt,e.CesiumIonAuthPlugin=class{constructor({apiToken:e,assetId:t=null,autoRefreshToken:s=!1,useRecommendedSettings:r=!0}){this.name="CESIUM_ION_AUTH_PLUGIN",this.priority=-1/0,this.apiToken=e,this.assetId=t,this.autoRefreshToken=s,this.useRecommendedSettings=r,this.tiles=null,this.endpointURL=null,this._bearerToken=null,this._tileSetVersion=-1,this._tokenRefreshPromise=null,this._attributions=[],this._disposed=!1}init(e){null!==this.assetId&&(e.rootURL=`https://api.cesium.com/v1/assets/${this.assetId}/endpoint`),this.tiles=e,this.endpointURL=e.rootURL,e.resetFailedTiles()}loadRootTileSet(){return this._refreshToken().then((()=>this.tiles.invokeOnePlugin((e=>e!==this&&e.loadRootTileSet&&e.loadRootTileSet()))))}preprocessURL(e){return e=new URL(e),/^http/.test(e.protocol)&&-1!=this._tileSetVersion&&e.searchParams.append("v",this._tileSetVersion),e.toString()}fetchData(e,t){return null!==this.tiles.getPluginByName("GOOGLE_CLOUD_AUTH_PLUGIN")?null:Promise.resolve().then((async()=>{null!==this._tokenRefreshPromise&&(await this._tokenRefreshPromise,e=this.preprocessURL(e));const s=await fetch(e,t);return s.status>=400&&s.status<=499&&this.autoRefreshToken?(await this._refreshToken(t),fetch(this.preprocessURL(e),t)):s}))}getAttributions(e){this.tiles.visibleTiles.size>0&&e.push(...this._attributions)}_refreshToken(e){if(null===this._tokenRefreshPromise){const t=new URL(this.endpointURL);t.searchParams.append("access_token",this.apiToken),this._tokenRefreshPromise=fetch(t,e).then((e=>{if(this._disposed)return null;if(!e.ok)throw new Error(`CesiumIonAuthPlugin: Failed to load data with error code ${e.status}`);return e.json()})).then((e=>{if(this._disposed)return null;const s=this.tiles;if("externalType"in e){const t=new URL(e.options.url);s.rootURL=e.options.url,s.registerPlugin(new Vs({apiToken:t.searchParams.get("key"),autoRefreshToken:this.autoRefreshToken,useRecommendedSettings:this.useRecommendedSettings}))}else{if("TERRAIN"===e.type&&null===s.getPluginByName("QUANTIZED_MESH_PLUGIN")||"IMAGERY"===e.type&&s.getPluginByName("TMS_TILES_PLUGIN"),s.rootURL=e.url,s.fetchOptions.headers=s.fetchOptions.headers||{},s.fetchOptions.headers.Authorization=`Bearer ${e.accessToken}`,t.searchParams.has("v")&&-1===this._tileSetVersion){const t=new URL(e.url);this._tileSetVersion=t.searchParams.get("v")}this._bearerToken=e.accessToken,e.attributions&&(this._attributions=e.attributions.map((e=>({value:e.html,type:"html",collapsible:e.collapsible}))))}return this._tokenRefreshPromise=null,e})),this._tokenRefreshPromise.catch((e=>{this.tiles.dispatchEvent({type:"load-error",tile:null,error:e,url:t})}))}return this._tokenRefreshPromise}dispose(){this._disposed=!0}},e.DebugLoadParser=class{static parse(e,t){let s=null;return s="gltf"===Z(e.url)?t.loadFile(e.url).then((t=>{e.options.buffer=t})):t.loadFile(e.url,"arraybuffer").then((t=>{e.options.buffer=t})),s}},e.DebugTilesPlugin=class{static get ColorModes(){return ur}constructor(e){e={displayParentBounds:!1,displayBoxBounds:!1,displaySphereBounds:!1,displayRegionBounds:!1,colorMode:tr,maxDebugDepth:-1,maxDebugDistance:-1,maxDebugError:-1,customColorCallback:null,...e},this.name="DEBUG_TILES_PLUGIN",this.tiles=null,this._enabled=!0,this.extremeDebugDepth=-1,this.extremeDebugError=-1,this.boxGroup=null,this.sphereGroup=null,this.regionGroup=null,this._displayParentBounds=e.displayParentBounds,this.displayBoxBounds=e.displayBoxBounds,this.displaySphereBounds=e.displaySphereBounds,this.displayRegionBounds=e.displayRegionBounds,this.colorMode=e.colorMode,this.maxDebugDepth=e.maxDebugDepth,this.maxDebugDistance=e.maxDebugDistance,this.maxDebugError=e.maxDebugError,this.customColorCallback=e.customColorCallback,this.getDebugColor=(e,t)=>{t.setRGB(e,e,e)}}get enabled(){return this._enabled}set enabled(e){e!==this._enabled&&(this._enabled=e,this._enabled?this.tiles&&this.init(this.tiles):this.dispose())}get displayParentBounds(){return this._displayParentBounds}set displayParentBounds(e){this._displayParentBounds!==e&&(this._displayParentBounds=e,e?this.tiles.traverse((e=>{e.__visible&&this._onTileVisibilityChange(e,!0)})):ee(this.tiles.root,null,(e=>{e[Qs]=null,this._onTileVisibilityChange(e,e.__visible)})))}init(e){this.tiles=e,this.boxGroup=new t.Object3D,this.boxGroup.name="DebugTilesPlugin.boxGroup",e.add(this.boxGroup),this.boxGroup.updateMatrix(),this.sphereGroup=new t.Object3D,this.sphereGroup.name="DebugTilesPlugin.sphereGroup",e.add(this.sphereGroup),this.sphereGroup.updateMatrix(),this.regionGroup=new t.Object3D,this.regionGroup.name="DebugTilesPlugin.regionGroup",e.add(this.regionGroup),this.regionGroup.updateMatrix(),this._onLoadTileSetCB=()=>{this._initExtremes()},this._onLoadModelCB=({scene:e,tile:t})=>{this._onLoadModel(e,t)},this._onDisposeModelCB=({tile:e})=>{this._onDisposeModel(e)},this._onUpdateAfterCB=()=>{this._onUpdateAfter()},this._onTileVisibilityChangeCB=({scene:e,tile:t,visible:s})=>{this._onTileVisibilityChange(t,s)},e.addEventListener("load-tile-set",this._onLoadTileSetCB),e.addEventListener("load-model",this._onLoadModelCB),e.addEventListener("dispose-model",this._onDisposeModelCB),e.addEventListener("update-after",this._onUpdateAfterCB),e.addEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this._initExtremes(),e.traverse((e=>{e.cached.scene&&this._onLoadModel(e.cached.scene,e)})),e.visibleTiles.forEach((e=>{this._onTileVisibilityChange(e,!0)}))}getTileInformationFromActiveObject(e){let t=null;return this.tiles.activeTiles.forEach((s=>{if(t)return!0;const r=s.cached.scene;r&&r.traverse((r=>{r===e&&(t=s)}))})),t?{distanceToCamera:t.__distanceFromCamera,geometricError:t.geometricError,screenSpaceError:t.__error,depth:t.__depth,isLeaf:t.__isLeaf}:null}_initExtremes(){if(!this.tiles||!this.tiles.root)return;let e=-1,t=-1;ee(this.tiles.root,null,((s,r,i)=>{e=Math.max(e,i),t=Math.max(t,s.geometricError)})),this.extremeDebugDepth=e,this.extremeDebugError=t}_onUpdateAfter(){const e=this.tiles;if(!e.root)return;this.boxGroup.visible=this.displayBoxBounds,this.sphereGroup.visible=this.displaySphereBounds,this.regionGroup.visible=this.displayRegionBounds;let s=-1;s=-1===this.maxDebugDepth?this.extremeDebugDepth:this.maxDebugDepth;let r=-1;r=-1===this.maxDebugError?this.extremeDebugError:this.maxDebugError;let i=-1;-1===this.maxDebugDistance?(e.getBoundingSphere(Js),i=Js.radius):i=this.maxDebugDistance;const n=e.errorTarget,a=this.colorMode,o=e.visibleTiles;let l;a===hr&&(l=Array.from(o).sort(((e,t)=>e[Ws]-t[Ws]))),o.forEach((e=>{const o=e.cached.scene;let c,d,h;a===lr&&(c=Math.random(),d=.5+.5*Math.random(),h=.375+.25*Math.random()),o.traverse((o=>{a===cr&&(c=Math.random(),d=.5+.5*Math.random(),h=.375+.25*Math.random());const u=o.material;if(u){const p=o[js];if(a===tr&&u!==p)o.material.dispose(),o.material=o[js];else if(a!==tr&&u===p)if(o.material.drawMode===t.DRAW_MODE.POINTS){const e=new t.PointsMaterial;e.size=p.size,e.sizeAttenuation=p.sizeAttenuation,o.material=e}else o.material.isInstancedPBRMaterial?(o.material=new wt,o.material.metalness=0,o.material.roughness=1):o.material.isInstancedBasicMaterial?o.material=new Ht:(o.material=new t.PBRMaterial,o.material.metalness=0,o.material.roughness=1),o.material.shading=t.SHADING_TYPE.FLAT_SHADING,o.material.envMap=void 0;switch(a!==lr&&delete o.material[Xs],a!==cr&&delete o.material[Ys],a){case nr:{const t=e.__depth/s;this.getDebugColor(t,o.material.diffuse);break}case ar:{const t=e.__depthFromRenderedParent/s;this.getDebugColor(t,o.material.diffuse);break}case sr:{const t=e.__error/n;t>1?o.material.diffuse.setRGB(1,0,0):this.getDebugColor(t,o.material.diffuse);break}case rr:{const t=Math.min(e.cached.geometricError/r,1);this.getDebugColor(t,o.material.diffuse);break}case ir:{const t=Math.min(e.__distanceFromCamera/i,1);this.getDebugColor(t,o.material.diffuse);break}case or:e.children&&0!==e.children.length?this.getDebugColor(0,o.material.diffuse):this.getDebugColor(1,o.material.diffuse);break;case cr:o.material[Ys]||(o.material.diffuse.setHSL(c,d,h),o.material[Ys]=!0);break;case lr:o.material[Xs]||(o.material.diffuse.setHSL(c,d,h),o.material[Xs]=!0);break;case dr:this.customColorCallback?this.customColorCallback(e,o):console.warn("DebugTilesPlugin: customColorCallback not defined");break;case hr:{const t=l.indexOf(e);this.getDebugColor(t/(l.length-1),o.material.diffuse);break}}}}))}))}_onTileVisibilityChange(e,t){this.displayParentBounds?function(e,t=null){let s=e;for(;s;){const e=s.__depth,r=s.parent;t&&t(s,r,e),s=r}}(e,(s=>{null==s[Qs]&&(s[Qs]=0),t?s[Qs]++:s[Qs]>0&&s[Qs]--;const r=s===e&&t||this.displayParentBounds&&s[Qs]>0;this._updateBoundHelper(s,r)})):this._updateBoundHelper(e,t)}_createBoundHelper(e){const s=this.tiles,r=e.cached,{sphere:i,obb:n,region:a}=r.boundingVolume;if(n){const i=new t.Object3D;i.name="DebugTilesPlugin.boxHelperGroup",i.matrix.copy(n._originBoxTransform),i.matrixAutoUpdate=!1,i.matrixNeedsUpdate=!1;const a=new zs(n._originBox,er(e.__depth).getHex());a.raycast=qs,i.add(a),r.boxHelperGroup=i,s.visibleTiles.has(e)&&this.displayBoxBounds&&(this.boxGroup.add(i),i.updateMatrix(!0))}if(i){const t=new Hs(i,er(e.__depth).getHex());t.raycast=qs,r.sphereHelper=t,s.visibleTiles.has(e)&&this.displaySphereBounds&&(this.sphereGroup.add(t),t.updateMatrix(!0))}}_updateHelperMaterial(e,t){e.__visible||!this.displayParentBounds?t.opacity=1:t.opacity=.2,t.transparent=t.opacity<1}_updateBoundHelper(e,t){const s=e.cached;if(!s)return;const r=this.sphereGroup,i=this.boxGroup,n=this.regionGroup;t&&null==s.boxHelperGroup&&null==s.sphereHelper&&null==s.regionHelper&&this._createBoundHelper(e);const a=s.boxHelperGroup,o=s.sphereHelper,l=s.regionHelper;t?(a&&(i.add(a),a.updateMatrix(!0),this._updateHelperMaterial(e,a.children[0].material)),o&&(r.add(o),o.updateMatrix(!0),this._updateHelperMaterial(e,o.material)),l&&(n.add(l),l.updateMatrix(!0),this._updateHelperMaterial(e,l.material))):(a&&i.remove(a),o&&r.remove(o),l&&n.remove(l))}_onLoadModel(e,t){t[Ws]=performance.now(),e.traverse((e=>{const t=e.material;t&&(e[js]=t)}))}_onDisposeModel(e){const t=e.cached;t.boxHelperGroup&&(t.boxHelperGroup.children[0].geometry.dispose(),delete t.boxHelperGroup),t.sphereHelper&&(t.sphereHelper.geometry.dispose(),delete t.sphereHelper),t.regionHelper&&(t.regionHelper.geometry.dispose(),delete t.regionHelper)}dispose(){const e=this.tiles;e&&(e.removeEventListener("load-tile-set",this._onLoadTileSetCB),e.removeEventListener("load-model",this._onLoadModelCB),e.removeEventListener("dispose-model",this._onDisposeModelCB),e.removeEventListener("update-after",this._onUpdateAfterCB),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChangeCB),this.colorMode=tr,this._onUpdateAfter(),e.traverse((e=>{this._onDisposeModel(e)}))),this.boxGroup?.removeFromParent(),this.sphereGroup?.removeFromParent(),this.regionGroup?.removeFromParent()}},e.I3DMLoader=Yt,e.InstancedBasicMaterial=Ht,e.InstancedPBRMaterial=wt,e.OBB=s,e.PNTSLoader=Qt,e.ReorientationPlugin=class{constructor(e){e={up:"+z",recenter:!0,lat:null,lon:null,height:0,...e},this.tiles=null,this.up=e.up.toLowerCase().replace(/\s+/,""),this.lat=e.lat,this.lon=e.lon,this.height=e.height,this.recenter=e.recenter,this._callback=null}init(e){this.tiles=e,this._callback=()=>{const{up:t,lat:s,lon:r,height:i,recenter:n}=this;if(null!==s&&null!==r)this.transformLatLonHeightToOrigin(s,r,i);else{const{ellipsoid:s}=e,r=Math.min(s.radius.x,s.radius.y,s.radius.z);if(e.getBoundingSphere(pr),pr.center.getLength()>.5*r){const e={};s.getPositionToCartographic(pr.center,e),this.transformLatLonHeightToOrigin(e.lat,e.lon,e.height)}else{switch(e.euler.set(0,0,0),t){case"x":case"+x":e.euler.z=Math.PI/2;break;case"-x":e.euler.z=-Math.PI/2;break;case"y":case"+y":break;case"-y":e.euler.z=Math.PI;break;case"z":case"+z":e.euler.x=-Math.PI/2;break;case"-z":e.euler.x=Math.PI/2}e.position.copy(pr.center).applyEuler(e.euler).multiplyScalar(-1)}}n||e.position.setScalar(0),e.removeEventListener("load-tile-set",this._callback)},e.addEventListener("load-tile-set",this._callback)}transformLatLonHeightToOrigin(e,t,s=0){const r=this.tiles,{ellipsoid:i}=r;i.getRotationMatrixFromAzElRoll(e,t,0,0,0,r.matrix,D),i.getCartographicToPosition(e,t,s,mr),r.matrix.setPosition(mr).invert().decompose(r.position,r.quaternion,r.scale),r.updateMatrix()}dispose(){const e=this.tiles;e.position.setScalar(0),e.quaternion.identity(),e.scale.set(1,1,1),e.addEventListener("load-tile-set",this._callback)}},e.TileGLTFLoader=ss,e.Tiles3D=As,e.TilesFadePlugin=class{get fadeDuration(){return this._fadeManager.duration}set fadeDuration(e){this._fadeManager.duration=Number(e)}get fadingTiles(){return this._fadeManager.fadeCount}constructor(e){e={maximumFadeOutTiles:50,fadeRootTiles:!1,fadeDuration:250,...e},this.name="FADE_TILES_PLUGIN",this.priority=-2,this.tiles=null,this.batchedMesh=null,this._fadeManager=new Ss,this._fadeMaterialManager=new Cs,this._prevCameraTransforms=null,this._fadingOutCount=0,this.maximumFadeOutTiles=e.maximumFadeOutTiles,this.fadeRootTiles=e.fadeRootTiles,this.fadeDuration=e.fadeDuration}init(e){this._onLoadModel=({scene:e})=>{this._fadeMaterialManager.prepareScene(e)},this._onDisposeModel=({tile:e,scene:t})=>{this._fadeManager.deleteObject(e),this._fadeMaterialManager.deleteScene(t)},this._onAddCamera=({camera:e})=>{this._prevCameraTransforms.set(e,new t.Matrix4)},this._onDeleteCamera=({camera:e})=>{this._prevCameraTransforms.delete(e)},this._onTileVisibilityChange=({tile:e,visible:t})=>{const s=e.cached.scene;s&&(s.visible=!0)},this._onUpdateBefore=()=>{Fs.call(this)},this._onUpdateAfter=()=>{Us.call(this)},e.addEventListener("load-model",this._onLoadModel),e.addEventListener("dispose-model",this._onDisposeModel),e.addEventListener("add-camera",this._onAddCamera),e.addEventListener("delete-camera",this._onDeleteCamera),e.addEventListener("update-before",this._onUpdateBefore),e.addEventListener("update-after",this._onUpdateAfter),e.addEventListener("tile-visibility-change",this._onTileVisibilityChange);const s=this._fadeManager;s.onFadeSetStart=()=>{e.dispatchEvent({type:"fade-start"}),e.dispatchEvent({type:"needs-render"})},s.onFadeSetComplete=()=>{e.dispatchEvent({type:"fade-end"}),e.dispatchEvent({type:"needs-render"})},s.onFadeComplete=(t,s)=>{this._fadeMaterialManager.setFade(t.cached.scene,0,0),s||(e.invokeOnePlugin((e=>e!==this&&e.setTileVisible&&e.setTileVisible(t,!1))),this._fadingOutCount--)};const r=new Map;e.$cameras._cameras.forEach((e=>{r.set(e,new t.Matrix4)})),e.forEachLoadedModel(((e,t)=>{this._onLoadModel({scene:e})})),this.tiles=e,this._fadeManager=s,this._prevCameraTransforms=r}setTileVisible(e,t){const s=this._fadeManager,r=s.isFading(e);if(s.isFadingOut(e)&&this._fadingOutCount--,t){1===e.__depthFromRenderedParent?((e[Os]||this.fadeRootTiles)&&this._fadeManager.fadeIn(e),e[Os]=!0):this._fadeManager.fadeIn(e)}else this._fadingOutCount++,s.fadeOut(e);if(r)return!0;const i=this._fadeManager.isFading(e);return!(t||!i)}dispose(){const e=this.tiles;this._fadeManager.completeAllFades(),null!==this.batchedMesh&&this._onBatchedMeshDispose(),e.removeEventListener("load-model",this._onLoadModel),e.removeEventListener("dispose-model",this._onDisposeModel),e.removeEventListener("add-camera",this._onAddCamera),e.removeEventListener("delete-camera",this._onDeleteCamera),e.removeEventListener("update-before",this._onUpdateBefore),e.removeEventListener("update-after",this._onUpdateAfter),e.removeEventListener("tile-visibility-change",this._onTileVisibilityChange),e.forEachLoadedModel(((e,t)=>{this._fadeManager.deleteObject(t),e&&(e.visible=!0)}))}}}));
